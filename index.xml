<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Radu Matei - Developer Evangelist</title>
    <link>https://radu-matei.com/index.xml</link>
    <description>Recent content on Radu Matei - Developer Evangelist</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 06 Oct 2017 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://radu-matei.com/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Kubernetes 1.8 on Azure</title>
      <link>https://radu-matei.com/blog/k8s18-azure/</link>
      <pubDate>Fri, 06 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>https://radu-matei.com/blog/k8s18-azure/</guid>
      <description>

&lt;h1 id=&#34;table-of-content&#34;&gt;Table of Content&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#introduction&#34;&gt;Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#deploying-orchestrator-clusters-in-azure&#34;&gt;Deploying orchestrator clusters in Azure&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#getting-the-acs-engine-binary&#34;&gt;Getting the acs-engine binary&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#deploy-the-cluster&#34;&gt;Deploy the cluster&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#conclusion-feedback&#34;&gt;Conclusion and feedback&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;On September 28th, Kubernetes hit version 1.8 with improved support for Role Based Access Control (RBAC), TLS certificate rotation and other cool features. &lt;a href=&#34;http://blog.kubernetes.io/2017/09/kubernetes-18-security-workloads-and.html&#34;&gt;You can read the full blog post that announces the release here&lt;/a&gt; and you can see &lt;a href=&#34;https://github.com/kubernetes/kubernetes/releases/tag/v1.8.0&#34;&gt;the release on GitHub&lt;/a&gt; and the &lt;a href=&#34;https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG.md#v180&#34;&gt;associated changelog with all new features&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In this article we will explore how to deploy a Kubernetes cluster with version 1.8 on Azure.&lt;/p&gt;

&lt;p&gt;If you are familiar with deploying orchestrators in Azure, or you only want to see how to deploy Kubernetes 1.8, you can &lt;a href=&#34;#getting-the-acs-engine-binary&#34;&gt;skip the following section and go directly to where the action actually starts.&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;deploying-orchestrator-clusters-in-azure&#34;&gt;Deploying orchestrator clusters in Azure&lt;/h1&gt;

&lt;p&gt;There are a couple of ways to deploy an orchestrator cluster in Azure. First, there is Azure Container Service (that we used in the past to &lt;a href=&#34;https://radu-matei.com/blog/kubernetes-jenkins-azure/&#34;&gt;deploy a Kubernetes cluster&lt;/a&gt;). &lt;a href=&#34;https://azure.microsoft.com/en-us/services/container-service/&#34;&gt;Azure Container Service&lt;/a&gt; allows you to easily &lt;a href=&#34;https://docs.microsoft.com/en-us/azure/container-service/&#34;&gt;deploy Kubernetes, Docker Swarm or DC/OS clusters from the Azure Portal or using the &lt;code&gt;az&lt;/code&gt; command line&lt;/a&gt;. This is the way to go if you don&amp;rsquo;t want to customize your cluster and you are ok with the default values that Azure provides for you.&lt;/p&gt;

&lt;p&gt;Then there is a tool called &lt;a href=&#34;https://github.com/azure/acs-engine&#34;&gt;&lt;code&gt;acs-engine&lt;/code&gt;&lt;/a&gt;. This is basically the &amp;ldquo;engine&amp;rdquo; that Azure Container Service uses to deploy your clusters, and we will use it to deploy a custom version of our Kubernetes cluster, in this case the new 1.8 version.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;acs-engine&lt;/code&gt; takes a &lt;a href=&#34;https://github.com/Azure/acs-engine/blob/master/docs/clusterdefinition.md&#34;&gt;cluster definition file&lt;/a&gt; where you can specify options for your cluster (like orchestrator to use - Kubernetes, Docker Swarm Mode, DC/OS and their specific versions, networking policies, master and agent profiles and others) and generates &lt;a href=&#34;https://docs.microsoft.com/en-us/azure/azure-resource-manager/resource-group-authoring-templates&#34;&gt;ARM (Azure Resource Manager) templates&lt;/a&gt; that Azure uses to deploy all resources for your cluster (VMs for masters and agents with your orchestrator configured, load balancers, networking, storage adn other resources).&lt;/p&gt;

&lt;p&gt;Kubernetes 1.8 has just been released, and together with it came &lt;a href=&#34;https://github.com/Azure/acs-engine/releases&#34;&gt;v0.8.0 of &lt;code&gt;acs-engine&lt;/code&gt;&lt;/a&gt; with support for Kubernetes 1.8.&lt;/p&gt;

&lt;p&gt;You can follow this article on your local machine, inside a Docker container or using the Azure Cloud Shell, and all of these versions being very similar (basically you only change the OS version of the acs-engine binary).&lt;/p&gt;

&lt;h1 id=&#34;getting-the-acs-engine-binary&#34;&gt;Getting the acs-engine binary&lt;/h1&gt;

&lt;p&gt;In this step all you need to do is download the the binary associated with v0.8.0 of &lt;code&gt;acs-engine&lt;/code&gt; for your operating system. I will use the Azure Cloud Shell (which is Linux), but you can do the same thing for macOS (by getting the Darwin specific binaries) or for Windows.&lt;/p&gt;

&lt;p&gt;First you need to download the GitHub release archive for Linux:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;wget https://github.com/Azure/acs-engine/releases/download/v0.8.0/acs-engine-v0.8.0-linux-amd64.tar.gz&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Then, you need to unarchive it:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;tar -xvzf acs-engine-v0.8.0-linux-amd64.tar.gz&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;This will create a folder called &lt;code&gt;acs-engine-v0.8.0-linux-amd64&lt;/code&gt;, and inside it you will find (among the license and the readme) the &lt;code&gt;acs-engine&lt;/code&gt; binary.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/k8s18-azure/acs-engine-shell.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Now you only need to put it in your path (or move it to a directory that is in your path) and you have the &lt;code&gt;acs-engine&lt;/code&gt; binary accessible from anywhere.&lt;/p&gt;

&lt;p&gt;We will now use this binary inside the Azure Cloud Shell to deploy a Kubernetes 1.8 cluster to Azure, using a cluster definition template file.&lt;/p&gt;

&lt;h1 id=&#34;deploy-the-cluster&#34;&gt;Deploy the cluster&lt;/h1&gt;

&lt;p&gt;This is how a typical cluster definition file looks for Kubernetes. Compared to &lt;a href=&#34;https://github.com/Azure/acs-engine/blob/master/examples/kubernetes.json&#34;&gt;the example offered in the repo&lt;/a&gt;, this only adds the &lt;code&gt;orchestratorRelease&lt;/code&gt; property and sets it to &lt;code&gt;1.8&lt;/code&gt;.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/radu-matei/7ba751e0074621313b997c12ccf28dbe.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;The great thing about this version of &lt;code&gt;acs-engine&lt;/code&gt; is that you will only need one command to deploy this, and you pass a few parameters (in older versions you would generate ARM templates using &lt;code&gt;acs-engine&lt;/code&gt; and deploy them with the &lt;code&gt;az&lt;/code&gt; command line):&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;an Azure subscription id (you can find it using &lt;code&gt;az account show&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;a DNS prefix for your cluster&lt;/li&gt;
&lt;li&gt;the location of your cluster&lt;/li&gt;
&lt;li&gt;the cluster definition file from above&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;acs-engine deploy --subscription-id &amp;lt;your-subscription-id&amp;gt; \
    --dns-prefix &amp;lt;your-dns-prefix&amp;gt; --location westeurope \
    --auto-suffix --api-model kubernetes18.json
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Note the &lt;code&gt;orchestratorRelease&lt;/code&gt; property in the JSON file set to &lt;code&gt;1.8&lt;/code&gt;!
Note that it automatically creates all assets for you including a service principal and a resource group.&lt;/p&gt;

&lt;p&gt;Since you are in the Azure Cloud Shell, you are already authenticated into your Azure account. If you run elswhere, the will be another step involved where you login to &lt;code&gt;aka.ms/devicelogin&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/k8s18-azure/shell.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;After the deployment succeeds, you should see a resource group in your subscription with all your Kubernetes assets:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/k8s18-azure/resource-group.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The output of the command above is an &lt;code&gt;_output&lt;/code&gt; folder where you have your SSH keys and the &lt;code&gt;kubeconfig&lt;/code&gt; to access the cluster.&lt;/p&gt;

&lt;p&gt;Now to access the cluster.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Depending on which version of &lt;code&gt;kubectl&lt;/code&gt; you have installed, you might want to &lt;a href=&#34;https://kubernetes.io/docs/tasks/tools/install-kubectl/#install-kubectl-binary-via-curl&#34;&gt;upgrade to 1.8 as it is detailed here&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Now you need to point your &lt;code&gt;kubectl&lt;/code&gt; to the &lt;code&gt;kubeconfig&lt;/code&gt; file location. This has to correspond to the Azure location where you deployed your cluster - in my case West Europe:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;export KUBECONFIG=_output/kubernetes1dot8-59d7ee12/kubeconfig/kubeconfig.westeurope.json&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;At this point you can use &lt;code&gt;kubectl&lt;/code&gt; to get information about your cluster and your nodes:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;kubectl get nodes&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/k8s18-azure/k8s18.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Note the &lt;code&gt;v1.8.0&lt;/code&gt;!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Now you have a Kubernetes 1.8 cluster where you can go ahead and use all the awesome features!&lt;/p&gt;

&lt;h1 id=&#34;conclusion-feedback&#34;&gt;Conclusion, feedback&lt;/h1&gt;

&lt;p&gt;In this brief article we saw how to deploy a Kubernetes 1.8 cluster on Azure using &lt;code&gt;acs-engine&lt;/code&gt; and the Azure Cloud Shell.&lt;/p&gt;

&lt;p&gt;If you have any ideas, comments or feedback, please use the comments below :)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>About Me</title>
      <link>https://radu-matei.com/about/</link>
      <pubDate>Tue, 05 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>https://radu-matei.com/about/</guid>
      <description>

&lt;h1 id=&#34;who-am-i&#34;&gt;Who am I?&lt;/h1&gt;

&lt;p&gt;I&amp;rsquo;m a container enthusiast and open-source software developer. I like to see myself as a &amp;ldquo;friendly geek who accelerates developers to build epic stuff&amp;rdquo;, working as a Technical Evangelist @Microsoft.&lt;/p&gt;

&lt;p&gt;I am also the organizer of the &lt;a href=&#34;https://www.meetup.com/Bucharest-Container-Meetup/&#34;&gt;Bucharest Container Meetup&lt;/a&gt;, so if you are anytime in Bucharest, Romania, be sure to check for events.&lt;/p&gt;

&lt;h1 id=&#34;what-is-this-blog-about&#34;&gt;What is this blog about?&lt;/h1&gt;

&lt;p&gt;This blog is about containers, orchestrators, .NET Core and others.
I enjoy speaking at confrences and meetups. You can &lt;a href=&#34;https://radu-matei.com/speaking&#34;&gt;find my upcoming sesisons in the Speaking section&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;The views presented here are my own and are not affiliated with any organization I am part of.&lt;/em&gt;&lt;/p&gt;

&lt;h1 id=&#34;how-can-you-contact-me&#34;&gt;How can you contact me?&lt;/h1&gt;

&lt;p&gt;On the sidebar there is pretty much every place you can find me, including my email, so do not hesitate to comment or contact me.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Speaking</title>
      <link>https://radu-matei.com/speaking/</link>
      <pubDate>Tue, 05 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>https://radu-matei.com/speaking/</guid>
      <description>&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Date&lt;/th&gt;
&lt;th&gt;Event/Conference&lt;/th&gt;
&lt;th&gt;Talk&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;September 21&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://www.meetup.com/devops_hackers/events/243323836/&#34;&gt;Bucharest DevOps Meetup&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Easy Kubernetes Deployment with Jenkins, Helm and Draft&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;October 14&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;http://timisoara.codecamp.ro/&#34;&gt;CodeCamp Timisoara&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;The Hybrid Cluster: A CI/CD Story with Linux and Windows Containers&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;October 28&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;http://iasi.codecamp.ro/&#34;&gt;CodeCamp Iasi&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Easy Kubernetes Deployment with Jenkins, Helm and Draft&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;November 11&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;http://cluj.codecamp.ro/&#34;&gt;CodeCamp Cluj&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;The Hybrid Cluster: A CI/CD Story with Linux and Windows Containers&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;November 11&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;http://cluj.codecamp.ro/&#34;&gt;CodeCamp Cluj&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Easy Kubernetes Deployment with Jenkins, Helm and Draft&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</description>
    </item>
    
    <item>
      <title>The Hybrid Cluster: A CI/CD Story [Part 1] - Configuring a hybrid swarm mode cluster in Azure with acs-engine</title>
      <link>https://radu-matei.com/blog/hybrid-swarmmode/</link>
      <pubDate>Mon, 03 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>https://radu-matei.com/blog/hybrid-swarmmode/</guid>
      <description>

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;This is the first part in our (at least) two parts describing how to get started with a hybrid Docker Swarm Mode cluster. In this first part, we will focus on deploying a hybrid cluster on Azure.&lt;/p&gt;

&lt;p&gt;Now, you can create yourself a hybrid cluster within any private network where you have a Windows Server 2016 with Containers and a Linux machine - it can be locally, with VirtualBox, Hyper-V or VMWare, or it can be on your cloud provider of choice. The simplicity of Docker Swarm allows us to easily create a swarm within minutes of having our VMs deployed.&lt;/p&gt;

&lt;p&gt;Here is a list of resources you might want to get started with before diving into this article:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.docker.com/engine/swarm/swarm-tutorial/&#34;&gt;Getting started with Swarm Mode and Linux Containers - Docker docs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.microsoft.com/en-us/virtualization/windowscontainers/manage-containers/swarm-mode&#34;&gt;Getting started with Swarm Mode and Windows Containers - Microsoft docs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.microsoft.com/en-us/virtualization/windowscontainers/manage-containers/swarm-mode#linuxwindows-mixed-os-clusters&#34;&gt;Initializing a Linux+Windows mixed-os cluster - Microsoft docs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;how-is-this-article-different-compared-to-the-docs-above&#34;&gt;How is this article different compared to the docs above?&lt;/h2&gt;

&lt;p&gt;In this article we will focus on deploying the cluster on Azure programatically, using &lt;a href=&#34;https://github.com/Azure/acs-engine&#34;&gt;acs-engine&lt;/a&gt;, a tool that generates &lt;a href=&#34;https://docs.microsoft.com/en-us/azure/azure-resource-manager/resource-group-overview&#34;&gt;ARM (Azure Resource Manager) templates&lt;/a&gt; for Docker enabled clusters on Microsoft Azure. It will also deploy all resources necessary for our cluster, like load balancers, configure DNS for masters and agents and scale sets for agents and masters. More on this later.&lt;/p&gt;

&lt;p&gt;While you can &lt;a href=&#34;https://github.com/Azure/acs-engine&#34;&gt;find more information about acs-engine on the GitHub repo&lt;/a&gt;, in short, the tool takes a cluster definition file and outputs ARM templates that can be deployed using the &lt;a href=&#34;https://azure.github.io/projects/clis/&#34;&gt;various Azure command-line interfaces&lt;/a&gt; like Azure CLI 2.0 or Azure PowerShell.&lt;/p&gt;

&lt;h2 id=&#34;getting-started-prerequisites&#34;&gt;Getting started - prerequisites&lt;/h2&gt;

&lt;p&gt;This article will continue under the assumption that you have an active Azure subscription. If you don&amp;rsquo;t, there are various ways to get a free subscription, like &lt;a href=&#34;https://www.visualstudio.com/dev-essentials/&#34;&gt;Visual Studio Dev Essentials&lt;/a&gt; (see &lt;a href=&#34;https://github.com/awesome-opening-opportunities/technical-documentation/blob/master/docs/vs-dev-essentials.md&#34;&gt;this link on how to activate your free monthly $25&lt;/a&gt;), or a &lt;a href=&#34;https://azure.microsoft.com/en-us/free/&#34;&gt;free trial&lt;/a&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Before you get started, there is a &lt;a href=&#34;https://channel9.msdn.com/Events/DXPortugal/OSCAMP-Open-Source-Software-powered-by-Bright-Pixel/The-Hybrid-Swarm-Running-Windows-and-Linux-Apps-in-one-Docker-Cluster&#34;&gt;great talk by Docker Developer Advocate and Microsoft MVP Elton Stoneman titled: The Hybrid Swarm: Running Windows and Linux Apps in one Docker Cluster&lt;/a&gt; where he talks about the concepts involved in having a hybrid swarm cluster and that I highly recommend.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;understanding-all-types-of-containers&#34;&gt;Understanding all types of containers&lt;/h2&gt;

&lt;p&gt;First, there are Linux containers. They have been around for a while now (no, Docker did not invent them) and Docker created awesome tooling and integrations.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/hybrid-swarmmode/journey.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://blogs.msdn.microsoft.com/allthingscontainer/2016/10/14/why-containers/&#34;&gt;Photo credits to Bruno Terkaly, from this article&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Linux containers use the host kernel to run &amp;ldquo;containerized&amp;rdquo; workloads - that is execute the process inside the container using Linux kernel features like cgroups and namespaces. Of course, to run Linux containers you need a Linux kernel - this hasn&amp;rsquo;t changed and will not change any time soon.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://docs.microsoft.com/en-us/virtualization/windowscontainers/about/&#34;&gt;When we talk about the Windows ecosystem&lt;/a&gt;, we have Windows Server Containers and Hyper-V Containers.&lt;/p&gt;

&lt;p&gt;Windows Server Containers, much like Linux containers, share the kernel with the host and other containers. &amp;ldquo;These containers do not provide a hostile security boundary and should not be used to isolate untrusted code.&amp;rdquo; (&lt;a href=&#34;https://docs.microsoft.com/en-us/virtualization/windowscontainers/about/&#34;&gt;source - Microsoft docs&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;Hyper-V Containers - &amp;ldquo;expands on the isolation provided by Windows Server Containers by running each container in a highly optimized virtual machine. In this configuration, the kernel of the container host is not shared with other containers on the same host. These containers are designed for hostile multitenant hosting with the same security assurances of a virtual machine. Since these containers do not share the kernel with the host or other containers on the host, they can run kernels with different versions and configurations.&amp;rdquo; (&lt;a href=&#34;https://docs.microsoft.com/en-us/virtualization/windowscontainers/about/&#34;&gt;source - Microsoft docs&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;However, there&amp;rsquo;s a twist: announced at DockerCon 2017, you will be able to run Linux containers on Windows hosts using Hyper-V Isolation&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/hybrid-swarmmode/win-linux-containers.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://thenewstack.io/finally-linux-containers-really-will-run-windows-linuxkit/&#34;&gt;Image from The New Stack&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This is all possible through the new &lt;a href=&#34;https://github.com/linuxkit/linuxkit&#34;&gt;LinuxKit project&lt;/a&gt;, but more on this on a separate article in the future.&lt;/p&gt;

&lt;p&gt;After we deploy our cluster, we will be able to deploy all types of containers described above.&lt;/p&gt;

&lt;h2 id=&#34;the-acs-engine-cluster-definition&#34;&gt;The acs-engine cluster definition&lt;/h2&gt;

&lt;p&gt;As said earlier, we will use a JSON cluster definition file to, well, define our cluster.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/radu-matei/f610287201e4c08eb2e69eb5ebd02b2f.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;This is a pretty standard cluster definition file for acs-engine, except for the addition of &lt;code&gt;windowspool&lt;/code&gt;, a pool of Windows Server agents in our cluster.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;You can find &lt;a href=&#34;https://github.com/Azure/acs-engine/blob/master/docs/clusterdefinition.md&#34;&gt;in-depth documentation for the cluster definition on the acs-engine GitHub repo here.&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;From the definition file, we see that we have a Swarm Mode cluster, with 3 Linux masters, 3 Linux agents and 3 Windows Server 2016 agents. Before we can use this definition file, we need to add the required values for &lt;code&gt;dnxPrefix&lt;/code&gt; for the masters, Linux and Windows agents.&lt;/p&gt;

&lt;p&gt;You must also provide a username and public SSH key for the Linux VMs and a username and password for the Windows VMs, and you can change the default number of 3 for the agent and master count.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/hybrid-swarmmode/acs-swarmmode.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Compared to the image above, there is an additional VM Scale Set with the Windows agents. All VMs are in the same VNET, with the masters on a private subnet. All VMs are fully accessible to each other.&lt;/p&gt;

&lt;h2 id=&#34;deploying-the-cluster-to-azure&#34;&gt;Deploying the cluster to Azure&lt;/h2&gt;

&lt;p&gt;So far we only have a cluster definition (with values for FQDN, usernames and passwords). Before we can actually deploy, we need to generate the ARM templates using acs-engine.&lt;/p&gt;

&lt;p&gt;In order to do this, we will use the &lt;code&gt;acs-engine&lt;/code&gt; tool. After we have the ARM template, we will use the &lt;code&gt;az&lt;/code&gt; CLI to deploy them. You could install these either locally, or within containers, but the easiest way to do it is to use the &lt;a href=&#34;https://docs.microsoft.com/en-us/azure/cloud-shell/overview&#34;&gt;Azure Cloud Shell&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/hybrid-swarmmode/cloud-shell.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;List of tools and languages supported in the Azure Cloud Shell&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Log into &lt;a href=&#34;https://portal.azure.com&#34;&gt;portal.azure.com&lt;/a&gt; and request a cloud shell. You should see something like this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/hybrid-swarmmode/portal-shell.PNG&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Now we should &lt;a href=&#34;https://github.com/Azure/acs-engine/blob/master/docs/acsengine.md#downloading-and-building-acs-engine&#34;&gt;follow the instructions in the acs-engine documentation&lt;/a&gt; and install acs-engine in the Azure Cloud Shell.&lt;/p&gt;

&lt;p&gt;First, we need to create a new directory called &lt;code&gt;go&lt;/code&gt; and set it as &lt;code&gt;GOPATH&lt;/code&gt;: &lt;code&gt;mkdir go&lt;/code&gt; and &lt;code&gt;export GOPATH=/home/{yourusername}/go&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Then, we need to download the package for acs-engine: &lt;code&gt;go get github.com/Azure/acs-engine&lt;/code&gt;, then navigate to the source of the package and build it: &lt;code&gt;go build&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Then, we add the &lt;code&gt;bin&lt;/code&gt; folder from the &lt;code&gt;go&lt;/code&gt; directory in the path: &lt;code&gt;export PATH=$PATH:/home/{yourusername}/go/bin&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Now you should be able to execute &lt;code&gt;acs-engine&lt;/code&gt; from any directory:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/hybrid-swarmmode/acs-engine.PNG&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Now let&amp;rsquo;s create the ARM templates we will deploy: in a new directory, download the gist with the initial cluster definition (the gist file from above). You can either copy it yourself, or &lt;code&gt;wget&lt;/code&gt; the file:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;wget https://gist.githubusercontent.com/radu-matei/f610287201e4c08eb2e69eb5ebd02b2f/raw/d6a30f867b09d4baa64f78d2499a154096d053e2/swarmmode-hybrid.json&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;After you edit the file with your values, generate the ARM templates using &lt;code&gt;acs-engine generate swarmmode-hybrid.json&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/hybrid-swarmmode/acs-engine-generate.PNG&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;This will create an &lt;code&gt;_output&lt;/code&gt; directory that will contain the ARM template tht we will use for the deployment.&lt;/p&gt;

&lt;p&gt;First of all, we will create a new resource group: &lt;code&gt;az group create --location westeurope --name your-resourcegroup-name&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Note that you should choose the region closest to your location.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Then, using the generated files &lt;code&gt;azuredeploy.json&lt;/code&gt; and &lt;code&gt;azuredeploy.parameters.json&lt;/code&gt;, create a new deployment using the &lt;code&gt;az&lt;/code&gt; command-line interface:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;az group deployment create --name hybrid-swarmmode-deployment --resource-group {your-resource-group} --template-file azuredeploy.json  --parameters azuredeploy.parameters.json&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Note that you can also use a local installation of &lt;code&gt;az&lt;/code&gt;, or in a container, or any method of deploying ARM templates.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;After the deployment started, here is how the resource group should look like:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/hybrid-swarmmode/rg.PNG&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Notice the resources created in the resource group:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;3 public IPs for masters, Linux agents and Windows agents&lt;/li&gt;
&lt;li&gt;load balancers for masters, Linux agents and Windows agents&lt;/li&gt;
&lt;li&gt;VM scale sets for the agents and availability sets&lt;/li&gt;
&lt;li&gt;network interfaces and OS disks for the masters&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;connecting-to-the-cluster&#34;&gt;Connecting to the cluster&lt;/h2&gt;

&lt;p&gt;After the deployment succeeds, you are now ready to connect to the master. You will SSH into the masters using the user and SSH key you setup in the cluster definition file. The 3 FQDNs will have the following template:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;{yourfqdnname}.{azurelocation}.cloudapp.azure.com&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Each master can be publicly accessed using the FQDN and one of the ports (2200..220x) (So you will access the first master on 2200, the second master on 2201 and so on.). For example, to SSH into the first master, use the following:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ssh -i path-to-private-key azureuser@{yourfqdn}.{azurelocation}.cloudapp.azure.com -p 2200&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Then, if you list all nodes in the cluster you might first see this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/hybrid-swarmmode/docker-node-ls.PNG&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;This means we only see the 3 masters and the 3 Linux agents. This means that even though the Windows nodes were deployed, they did not join the swarm.&lt;/p&gt;

&lt;p&gt;A very quick solution is to reimage the Windows agents. This means restoring them to the initial state and executing all scripts that were executed when initializing the cluster.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A very probable cause of this could be that &lt;a href=&#34;https://github.com/Azure/acs-engine/blob/dd2edf94e182dd9006ddf3fa8f8388b4e5a1eed5/parts/Install-ContainerHost-And-Join-Swarm.ps1&#34;&gt;the script that joins the Windows agents to the cluster&lt;/a&gt; might get executed before the masters actually start.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;After reimaging or restarting the VMs, your cluster should look like this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/hybrid-swarmmode/node-ls-wc.PNG&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Now you have a full hybrid Swarm Mode cluster, with some Windows agents, as well as Linux ones:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/hybrid-swarmmode/node-inspect.PNG&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;deploying-services-to-the-cluster&#34;&gt;Deploying services to the cluster&lt;/h2&gt;

&lt;p&gt;From now on, you can treat this cluster as any other Docker Swarm Mode cluster: with the single mention that you cannot run Linux containers on Windows and Windows containers on Linux. This means that when starting services, we need to put some restrictions in place.&lt;/p&gt;

&lt;p&gt;We will deploy a simple Python web application on Linux that will use a Redis data store that we will run on Windows.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/microsoft-dx/docker-lab/tree/master/apps/python-redis&#34;&gt;The Python application can be found here&lt;/a&gt; and is very similar to the &lt;a href=&#34;https://docs.docker.com/compose/gettingstarted/&#34;&gt;Docker Compose one from the Official Docker Docs&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;script src=&#34;//gist.github.com/radu-matei/7543e906e3633075cd32231e46628bf1.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;The most important thing to notice in the stack file is the deployment constraint on the node operating system. As stated earlier, this is very important in the stack file as a Linux service will not run in a Windows host and vice-versa.&lt;/p&gt;

&lt;p&gt;You can see that the &lt;code&gt;redis&lt;/code&gt; service is based on the Windows version of Redis (not something that you would use in production, here just for showcase) and is based on the Nano Server image.&lt;/p&gt;

&lt;p&gt;To deploy this on the master, you need the file above. You can copy it, or &lt;code&gt;wget&lt;/code&gt; it directly: &lt;code&gt;wget https://gist.githubusercontent.com/radu-matei/7543e906e3633075cd32231e46628bf1/raw/f5e06e372c9a5c57f555e8580eee1c1a5ccb635e/hybrid-stack.yml&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Then, you need to &lt;a href=&#34;https://docs.docker.com/engine/reference/commandline/stack_deploy/&#34;&gt;create a new stack deployment&lt;/a&gt;:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;docker stack deploy --compose-file hybrid-stack.yml python-redis&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/hybrid-swarmmode/stack-deploy.PNG&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;This will create two new services, the web and Redis ones, and a new network for them.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/hybrid-swarmmode/service-ls.PNG&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://hub.docker.com/r/library/redis/&#34;&gt;Since the Nanoserver Redis image&lt;/a&gt; is around 340 MB, it will take a little to pull it, then start a container.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Now since the application that exposes ports is the one running on a Linux node (the web application), we will access it on the port 80 (the one exposed) of the Linux agent FQDN:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/hybrid-swarmmode/running.PNG&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;In this article we saw how to deploy a hybrid Swarm Mode cluster on Azure using acs-engine and how to deploy a mixed-OS containerized application on the cluster we created.&lt;/p&gt;

&lt;h2 id=&#34;next-steps&#34;&gt;Next Steps&lt;/h2&gt;

&lt;p&gt;Next, we will explore how to create a consistent CI/CD story with GitHub and Jenkins (with Linux and Windows slaves that are created dynamically for each build).&lt;/p&gt;

&lt;h2 id=&#34;feedback&#34;&gt;Feedback&lt;/h2&gt;

&lt;p&gt;If you think this article could be better, please provide your feedback in the comments below.&lt;/p&gt;

&lt;h2 id=&#34;thanks-for-reading&#34;&gt;Thanks for reading :)&lt;/h2&gt;
</description>
    </item>
    
    <item>
      <title>Creating a CI/CD workflow with Kubernetes, Jenkins and Azure Container Service</title>
      <link>https://radu-matei.com/blog/kubernetes-jenkins-azure/</link>
      <pubDate>Tue, 11 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>https://radu-matei.com/blog/kubernetes-jenkins-azure/</guid>
      <description>

&lt;h2 id=&#34;table-of-contents&#34;&gt;Table of Contents&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#introduction&#34;&gt;Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#deploying-a-kubernetes-cluster-on-azure-container-service&#34;&gt;Deploying a Kubernetes cluster on Azure Container Service&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#installing-and-configuring-the-kubernetes-cli&#34;&gt;Installing and configuring the Kubernetes CLI&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#deploying-a-jenkins-master-on-the-cluster&#34;&gt;Deploying a Jenkins master on the cluster&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#configuring-jenkins-to-work-with-kubernetes&#34;&gt;Configuring Jenkins to work with Kubernetes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#configuring-jenkins-to-dinamically-spawn-agents-docker-containers-for-builds&#34;&gt;Configuring Jenkins to dinamically spawn agents (Docker containers) for builds&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#what-is-happening-behind-the-scenes&#34;&gt;What is happening behind the scenes?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#the-docker-image-for-the-slaves&#34;&gt;The Docker image for the slaves&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#conclusion&#34;&gt;Conclusion&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#next-steps&#34;&gt;Next Steps&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#feedback&#34;&gt;Feedback&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://localhost:1313/blog/kubernetes-jenkins-azure/#deploying-a-jenkins-master-on-the-cluster&#34;&gt;If you already know how to deploy a Kubernetes cluster, please jump ahead to creating the Jenkins service.&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The purpose of writing this article is to show how to deploy and configure a Kubernetes cluster on Azure Container Service and install the Jenkins master as a Kubernetes service that will spawn slaves to build your workloads.&lt;/p&gt;

&lt;p&gt;You can, of course, install Jenkins in a VM, but you loose all the flexibility that running Kubernetes gives you.&lt;/p&gt;

&lt;p&gt;Only the master will run continously to receive webhooks and to spawn (not sure if this is the right word :D) slaves (these will be also Docker containers) to build and deploy your updates.&lt;/p&gt;

&lt;h2 id=&#34;deploying-a-kubernetes-cluster-on-azure-container-service&#34;&gt;Deploying a Kubernetes cluster on Azure Container Service&lt;/h2&gt;

&lt;p&gt;The easiest way (in my opinion) to deploy a Kubernetes cluster is through &lt;a href=&#34;https://docs.microsoft.com/en-us/cli/azure/install-azure-cli&#34;&gt;the new Azure CLI 2.0&lt;/a&gt;.
Since you are reading an article about Kubernetes, I will go ahead and assume you are familiar with Docker, so I will use the Docker option to use the Azure CLI:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;docker run -it -p 81:8080 azuresdk/azure-cli-python bash&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The reason I also mapped port 81 on the host (you can choose any available port on your machine) to port 8080 on the container (again, your choice) is because later we will create a proxy that will allow us to see the Kubernetes Dashboard. More on this later.&lt;/p&gt;

&lt;p&gt;You can find &lt;a href=&#34;https://github.com/Azure/azure-cli/blob/master/Dockerfile&#34;&gt;the Dockerfile for this image here&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Now you have a container with the new &lt;code&gt;az&lt;/code&gt; command line. First thing to do  - login to your Azure account using&lt;/p&gt;

&lt;p&gt;&lt;code&gt;az login&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;After following the instructions in the command line (open a browser, go to &lt;a href=&#34;http://aka.ms/devicelogin&#34;&gt;http://aka.ms/devicelogin&lt;/a&gt; and paste the code from the console), you are ready to explore your Azure resources from the command line.&lt;/p&gt;

&lt;p&gt;In order to verify that the desired subscription is the default one (in case you have multpile subscriptions), you can execute&lt;/p&gt;

&lt;p&gt;&lt;code&gt;az account show&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;If it is not, you can change it by using&lt;/p&gt;

&lt;p&gt;&lt;code&gt;az account set --subscription {subscription-id}&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Now if you execute &lt;code&gt;az account show&lt;/code&gt;, you will see the one you selected.&lt;/p&gt;

&lt;p&gt;The first thing you shoud do before actually deploying the Kubernetes cluster is create a &lt;a href=&#34;https://docs.microsoft.com/en-us/azure/azure-resource-manager/resource-group-overview#resource-groups&#34;&gt;resource group&lt;/a&gt;. This is done by executing the following command:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;az group create --name kubernetes-jenkins --location westeurope&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Note that you can select &lt;a href=&#34;https://azure.microsoft.com/en-us/regions/&#34;&gt;the closest Azure region&lt;/a&gt; to you when passing the parameter to &lt;code&gt;--location&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This is how it should look like if the deployment succeeded:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/kubernetes-jenkins-azure/az-group-show.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;At this point, you are ready to actually deploy the Kubernetes cluster:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;az acs create --orchestrator-type=kubernetes --resource-group=kubernetes-jenkins-ci --name=kubernetes-jenkins --dns-prefix=kubernetesci --generate-ssh-keys&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Note that these instructions are also available on &lt;a href=&#34;https://docs.microsoft.com/en-us/azure/container-service/container-service-kubernetes-walkthrough#create-your-kubernetes-cluster&#34;&gt;the official documentation for Kubernetes on Azure Container Service&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This will create a new Azure Container Service deployment in the resource group &lt;code&gt;kubernetes-jenkins&lt;/code&gt; with the name &lt;code&gt;kubernetes-jenkins&lt;/code&gt;, KLubernets as orchestrator and the DNS prefix of the master and nodes &lt;code&gt;kubernetesjenkins&lt;/code&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Note that this command will take around 10 minutes to complete.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;At this point, you can either see the deployed resources from the command line by executing&lt;/p&gt;

&lt;p&gt;&lt;code&gt;az acs show --resource-group kubernetes-jenkins --name kubernetes-jenkins&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Or by going to the &lt;a href=&#34;https://portal.azure.com&#34;&gt;Azure Portal&lt;/a&gt; to the Container Services blade:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/kubernetes-jenkins-azure/acs-cluster-portal.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;You can also see everything that got deployed for you (virtual machines, availability sets, storage accounts, network interfaces, network security groups, virtual networks, load balancers and route tables) by inspecting the resource group in the portal:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/kubernetes-jenkins-azure/resource-group.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;installing-and-configuring-the-kubernetes-cli&#34;&gt;Installing and configuring the Kubernetes CLI&lt;/h2&gt;

&lt;p&gt;Next, you install the Kubernetes CLI, &lt;a href=&#34;https://kubernetes.io/docs/user-guide/kubectl-overview/&#34;&gt;&lt;code&gt;kubectl&lt;/code&gt;&lt;/a&gt; by executing&lt;/p&gt;

&lt;p&gt;&lt;code&gt;az acs kubernetes install-cli&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/Azure/azure-cli/blob/master/src/command_modules/azure-cli-acs/azure/cli/command_modules/acs/custom.py#L273&#34;&gt;Since the Azure CLI is developed openly on GitHub, you can see exactly how the Azure CLI downloads and installs &lt;code&gt;kubectl&lt;/code&gt; here&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Then, you get the credentials for the cluster:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;az acs kubernetes get-credentials --resource-group=kubernetes-jenkins --name=kubernetes-jenkins&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;By deploying Kubernetes through Azure Container Service, the &lt;code&gt;az&lt;/code&gt; utilitary can manage the cluster credentials for you, but you can also use the configuration file you can find in &lt;code&gt;~/.kube/config&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Now, you are ready to use &lt;code&gt;kubectl&lt;/code&gt; as usual: &lt;code&gt;kubectl get nodes&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/kubernetes-jenkins-azure/kubectl-get-nodes.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;For a more detailed walkthrough on creating the cluster and creating your first public services, make sure to &lt;a href=&#34;https://docs.microsoft.com/en-us/azure/container-service/container-service-kubernetes-walkthrough&#34;&gt;complete this tutorial&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;deploying-a-jenkins-master-on-the-cluster&#34;&gt;Deploying a Jenkins master on the cluster&lt;/h2&gt;

&lt;p&gt;First of all, you need a &lt;code&gt;jenkins-master.yml&lt;/code&gt; file that describes the Jenkins service with persistent storage, public and private endpoints and resource limits. In order to get this file, simply execute the following command that will download the file from my Gist account:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;wget https://gist.githubusercontent.com/radu-matei/ccec29e108d0e01f50c8c1ea45a1dc58/raw/c32078736352dee3dbcf75e05f86fe801a4defe4/jenkins-master.yaml&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This file is based on the &lt;a href=&#34;https://github.com/jenkinsci/kubernetes-plugin/blob/master/src/main/kubernetes/gke.yml&#34;&gt;Jenkins documentation on deploying to Google Container Engine from GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This deployment will create a new namespace for the services, &lt;code&gt;kubernetes-plugin&lt;/code&gt; and will create the Jenkins master service based on the &lt;a href=&#34;https://hub.docker.com/r/jenkinsci/jenkins/&#34;&gt;jenkins:latest&lt;/a&gt; Docker image, and will expose ports 8080 (for the web interface) and 50000 (for communicating with the slaves), among with a persistent storage.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Take care when using the &lt;code&gt;:latest&lt;/code&gt; tag for images!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;kubectl create -f jenkins-master.yaml&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Besides the containers and services this &lt;code&gt;.yaml&lt;/code&gt; file creates, there is also some persistent storage. If we look at the &lt;code&gt;jenkins-master.yaml&lt;/code&gt; in the persistent storage part, we can see that at some point, the original &lt;code&gt;gke.yaml&lt;/code&gt; creates a &lt;a href=&#34;https://kubernetes.io/docs/concepts/storage/volumes/#gcepersistentdisk&#34;&gt;&lt;code&gt;gcePersistentDisk&lt;/code&gt;&lt;/a&gt;, which is Google Cloud Platform&amp;rsquo;s specific storage. What happens here is that Jenkins needs some persistent storage in order to store configuration for the master, so that if the pod serving the master fails, it can recreate it based on the persistant volume.&lt;/p&gt;

&lt;p&gt;If we look at the &lt;a href=&#34;https://kubernetes.io/docs/concepts/storage/persistent-volumes/#persistentvolumeclaims&#34;&gt;persistent volume claim&lt;/a&gt;, we see that it created an Azure Storage Account and a &lt;code&gt;.vhd&lt;/code&gt; where it deployed the storage.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/kubernetes-jenkins-azure/pvc.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;If we now go in the Azure Portal, to the resource group we created for the cluster, we can find this storage account:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/kubernetes-jenkins-azure/storage-account.png&#34; alt=&#34;&#34; /&gt;
And if we open the blobs blade we can actually see the volume storage there:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/kubernetes-jenkins-azure/storage.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;configuring-jenkins-to-work-with-kubernetes&#34;&gt;Configuring Jenkins to work with Kubernetes&lt;/h2&gt;

&lt;p&gt;At this point, if we go to the Kubernetes dashboard, in the Services part we should see Jenkins with a public IP (or external endpoints) configured:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/kubernetes-jenkins-azure/jenkins-endpoints.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;In order to see the Kubernetes dashboard you need to execute &lt;code&gt;kubectl proxy  --port 8080 --address=&#39;0.0.0.0&#39;&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;If we navigate to the HTTP endpoint of Jenkins (that is port 80), we should see the first-time installation view from Jenkins:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/kubernetes-jenkins-azure/jenkins-1st.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;In order to login we need to get a password from the machine running the service - in this case a Docker container running inside a Kubernetes pod. To see the pods either go in the Kubernetes dashboard:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/kubernetes-jenkins-azure/pods.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Or you can see it from the command line, but first we need to set the CLI context to the newly created namespace:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;kubectl config set-context $(kubectl config current-context) --namespace=kubernetes-plugin&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Now we can see the running pods:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;kubectl get pods&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/kubernetes-jenkins-azure/jenkins-pod.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Coming back to our previous task: retrieving the password that Jenkins set up at &lt;code&gt;/var/jenkins_home/secrets/initialAdminPassword&lt;/code&gt;. We need to execute a command inside this pod to get the password:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;kubectl exec -it jenkins-cqn0z cat /var/jenkins_home/secrets/initialAdminPassword&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/kubernetes-jenkins-azure/kubectl-get-password.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Note that you should replace &lt;code&gt;jenkins-cqn0z&lt;/code&gt; from the &lt;code&gt;kubectl exec&lt;/code&gt; with your own pod!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Now paste that string in the Jenkins setup page and you should be good to go.&lt;/p&gt;

&lt;p&gt;At this point, you would simply click on Install Suggested Plugins and it might work. It might also not work - &lt;code&gt;WARNING: No valid crumb was included in request&lt;/code&gt;, as in the photo below:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/kubernetes-jenkins-azure/crumb.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Try a few more times until it works and we will get solve this by enabling proxy compatibility once we have access to the service&amp;rsquo;s settings.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;As starting point for this I used &lt;a href=&#34;https://github.com/carlossg/jenkins-kubernetes-plugin&#34;&gt;this repo from carlossg&lt;/a&gt; and &lt;a href=&#34;https://github.com/jenkinsci/kubernetes-plugin&#34;&gt;the official documentation on the kubernetes-plugin from Jenkins&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Of course it didn&amp;rsquo;t really work without a lot of trial and error, hence the reason for writing this article.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;After clicking &lt;code&gt;Start using Jenkins&lt;/code&gt;, you are ready to Enable Proxy Compatibility from Configure Jenkins &amp;ndash;&amp;gt; Configure Global Security &amp;ndash;&amp;gt; Enable Proxy Compatibility - of course, not after a lot of tries and failure because &lt;code&gt;No valid crumb was included in request&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;configuring-jenkins-to-dinamically-spawn-agents-docker-containers-for-builds&#34;&gt;Configuring Jenkins to dinamically spawn agents (Docker containers) for builds&lt;/h2&gt;

&lt;p&gt;Since we want to have dynamically spawned agents (or slaves), we will keep 0 executors (from node settings):&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/kubernetes-jenkins-azure/executors.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Then, we need to install the &lt;a href=&#34;https://wiki.jenkins-ci.org/display/JENKINS/Kubernetes+Plugin&#34;&gt;Kubernetes Plugin for Jenkins&lt;/a&gt; - Manage Jenkins &amp;ndash;&amp;gt; Manage Plugins &amp;ndash;&amp;gt; Available &amp;ndash;&amp;gt; Search for &lt;code&gt;kubernetes plugin&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/kubernetes-jenkins-azure/kubernetes-plugin.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Then restart Jenkins after installing the plugin.&lt;/p&gt;

&lt;p&gt;Now you need to configure the Kubernetes plugin: Manage Jenkins &amp;ndash;&amp;gt; Configure System, and all the way to the bottom &amp;ndash;&amp;gt; Add a new cloud.&lt;/p&gt;

&lt;p&gt;Add the credentials to your Kubernetes cluster as in the picture below:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/kubernetes-jenkins-azure/kubernetes-credentials.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Then add the Kubernetes master FQDN (Fully Qualified Domain Name) and test the connection:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/kubernetes-jenkins-azure/test-connection.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Then add the Jenkins URL (with http!) and the Jenkins tunnel (without http and with the 50000 port!) and set a resonable container cap (how many containers should run at the same time):&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/kubernetes-jenkins-azure/jenkins-url-tunnel.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The other settings in the picture I left untouched.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Next we need to configure a container templat based on which Jenkins will spawn slaves to execute builds. This part is rather tricky and pretty undocumented, so it took me quite a lot. Here we go:&lt;/p&gt;

&lt;p&gt;We need to Add a Pod Template &amp;ndash;&amp;gt; Kubernetes Pod Template. The name of the template should be &lt;code&gt;jnlp&lt;/code&gt;, otherwise this will not work.&lt;/p&gt;

&lt;p&gt;Next we need to add a container template. The name of the container should also be &lt;code&gt;jnlp&lt;/code&gt;, or it will not work.&lt;/p&gt;

&lt;h2 id=&#34;the-docker-image-for-the-slaves&#34;&gt;The Docker image for the slaves&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/jenkinsci/kubernetes-plugin&#34;&gt;As the documentation states&lt;/a&gt;, you need to use a &lt;a href=&#34;https://hub.docker.com/r/jenkinsci/jnlp-slave/&#34;&gt;jnlp-slave image from Docker Hub&lt;/a&gt;. If we take a look at the Dockerfile for this image:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;FROM jenkinsci/slave:alpine
MAINTAINER Nicolas De Loof &amp;lt;nicolas.deloof@gmail.com&amp;gt;

COPY jenkins-slave /usr/local/bin/jenkins-slave

ENTRYPOINT [&amp;quot;jenkins-slave&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will surely work, but all this is going to do is give you a container based on the openjdk container (so with a Java SDK) and git.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://hub.docker.com/r/jenkinsci/slave/~/dockerfile/&#34;&gt;Dockerfile for the base image for the jnlp-slave&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;But we might have more and diverse workloads - and since we can configure the slave container only globally, we might just install more frameworks in this container - Node, Ruby, .NET Core - but this is just against what containerization stands for. We want to be able to build any kind of containerized workload with our Jenkins instance.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s what we want to do:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- be able to build any kind of workload on our Jenkins isntance
- deploy the built images / applications back to Kubernetes
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So clearly we need to update our Dockerfile by installing the Docker client and the kubectl CLI.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s have a look at how the Dockerfile would look like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;FROM jenkinsci/slave:alpine

USER root
RUN apk add --no-cache \
ca-certificates \
curl \
openssl

ENV DOCKER_BUCKET get.docker.com
ENV DOCKER_VERSION 17.04.0-ce
ENV DOCKER_SHA256 c52cff62c4368a978b52e3d03819054d87bcd00d15514934ce2e0e09b99dd100

RUN set -x \
&amp;amp;&amp;amp; curl -fSL &amp;quot;https://${DOCKER_BUCKET}/builds/Linux/x86_64/docker-${DOCKER_VERSION}.tgz&amp;quot; -o docker.tgz \
&amp;amp;&amp;amp; echo &amp;quot;${DOCKER_SHA256} *docker.tgz&amp;quot; | sha256sum -c - \
&amp;amp;&amp;amp; tar -xzvf docker.tgz \
&amp;amp;&amp;amp; mv docker/* /usr/local/bin/ \
&amp;amp;&amp;amp; rmdir docker \
&amp;amp;&amp;amp; rm docker.tgz \
&amp;amp;&amp;amp; docker -v

RUN curl -LO https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl

RUN chmod +x ./kubectl
RUN mv ./kubectl /usr/local/bin/kubectl

COPY docker-entrypoint.sh /usr/local/bin/

COPY jenkins-slave /usr/local/bin/jenkins-slave

RUN chmod +x /usr/local/bin/docker-entrypoint.sh
RUN chmod +x /usr/local/bin/jenkins-slave

ENTRYPOINT docker-entrypoint.sh; jenkins-slave

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It starts from the same base image as the Jenkins &lt;code&gt;jnlp-slave&lt;/code&gt;, but it also adds Docker and kubectl. I built and pushed this image to &lt;a href=&#34;https://hub.docker.com/r/radumatei/jenkins-slave-docker/&#34;&gt;radumatei/jnlp-slave-docker:kubectl&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;So we can use this as the base image for the slave containers.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/kubernetes-jenkins-azure/settings.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Since we want to mount the &lt;code&gt;/var/run/docker.sock&lt;/code&gt; from the host to the container so the containers can use the Docker engine installed on the node.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The solution is &lt;a href=&#34;http://jpetazzo.github.io/2015/09/03/do-not-use-docker-in-docker-for-ci/&#34;&gt;based on this article from Jrme Petazzoni&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Remember that in our Dockerfile we also installed kubectl. Since we need to actually modify deployments in the cluster using kubectl from inside the contaier, we need to authenticate the container in some way. Since the node that runs the slave pod that is doing the build is actually part of the cluster, this means at &lt;code&gt;/root/.kube&lt;/code&gt; there should be the information about the cluster which would allow us to actually make a deployment against the cluster. So we also mount &lt;code&gt;/root/.kube&lt;/code&gt; from the host to the container.&lt;/p&gt;

&lt;p&gt;This should be pretty much all setup involved. It might not sound much, but it is rather undocumented or not up to date.&lt;/p&gt;

&lt;p&gt;Before we setup the pipeline, let&amp;rsquo;s create a public service on Kubernetes that we will update after a build.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/kubernetes-jenkins-azure/public-service.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;While configuring the pipeline, you also need the Docker Hub credentials:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/kubernetes-jenkins-azure/docker-hub-credentials.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;So setup your own GitHub project (that has a Dockerfile at the root of the project) as a Jenkins pipeline with the following configuration:&lt;/p&gt;

&lt;p&gt;STEP 1:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker build -t ${DOCKER_HUB_USER}/dotnet-core-kubernetes:${BUILD_NUMBER} .
docker login -u ${DOCKER_HUB_USER} -p ${DOCKER_HUB_PASSWORD}
docker push ${DOCKER_HUB_USER}/dotnet-core-kubernetes:${BUILD_NUMBER}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;STEP 2:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;kubectl set image deployment/dotnet-core-kubernetes dotnet-core-kubernetes=${DOCKER_HUB_USER}/dotnet-core-kubernetes:${BUILD_NUMBER}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now if you configured the webhook correctly in GitHub, with every commit on the branches you specified should trigger a build for Jenkins:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/kubernetes-jenkins-azure/build.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Then, the kubectl command will actually update your application on the cluster.&lt;/p&gt;

&lt;h2 id=&#34;what-is-happening-behind-the-scenes&#34;&gt;What is happening behind the scenes?&lt;/h2&gt;

&lt;p&gt;With every initiated build, the Jenkins master will start a new pod in the Kubernetes cluster based on the Docker image you specified when configuring it (in this case &lt;a href=&#34;https://hub.docker.com/r/radumatei/jenkins-slave-docker/&#34;&gt;radumatei/jnlp-slave-docker:kubectl&lt;/a&gt;):&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/kubernetes-jenkins-azure/creating.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;It will pull that image and once the application starts, it will connect to port 50000 on the Jenkins service to register as available to serve builds.&lt;/p&gt;

&lt;p&gt;It will start the build steps on this container and you can see this in the logs from the build:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/kubernetes-jenkins-azure/build1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/kubernetes-jenkins-azure/build2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;After the build finishes (regardless of success or failure), the master will terminate the slave and all resources will be released:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/kubernetes-jenkins-azure/spike.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;In this article I tried to clearly show how to get started with a Jenkins master as a Kubernetes service that dynamically creates slaves to execute your build and then terminates them.&lt;/p&gt;

&lt;p&gt;The great advantage of this is that you only start containers once they have a task (in this case a build) to execute.&lt;/p&gt;

&lt;p&gt;We managed to build a complete workflow with Kubernetes and Jenkins that will automatically build and integrate your updates to your application.&lt;/p&gt;

&lt;h2 id=&#34;next-steps&#34;&gt;Next steps&lt;/h2&gt;

&lt;p&gt;As a next step I will investigate &lt;a href=&#34;https://github.com/kubernetes/helm&#34;&gt;deploying Jenkins using Helm&lt;/a&gt;, which I assume should be a much simpler task.&lt;/p&gt;

&lt;h2 id=&#34;feedback&#34;&gt;Feedback&lt;/h2&gt;

&lt;p&gt;If you stumbled upon this article, please take a minute to provide feedback to it - did it help, do you know a better or simpler way of achieving this?&lt;/p&gt;

&lt;p&gt;Your feedback is highly appreciated!&lt;/p&gt;

&lt;h2 id=&#34;thanks-for-reading&#34;&gt;Thanks for reading! :)&lt;/h2&gt;
</description>
    </item>
    
    <item>
      <title>Real-Time ASP .NET Core</title>
      <link>https://radu-matei.com/blog/real-time-aspnet-core/</link>
      <pubDate>Sat, 18 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>https://radu-matei.com/blog/real-time-aspnet-core/</guid>
      <description>

&lt;h2 id=&#34;what-is-this&#34;&gt;What is this?&lt;/h2&gt;

&lt;p&gt;This is an ASP .NET Core middleware for providing real-time functionality to your applications. To its core, this is a WebSockets middleware for ASP .NET Core applications with TypeScript / JavaScript and .NET clients.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This is an &lt;a href=&#34;https://github.com/radu-matei/websocket-manager&#34;&gt;&lt;strong&gt;open-source library&lt;/strong&gt; available (for using and contributing) on GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;why-wouldn-t-i-use-signalr-for-real-time&#34;&gt;Why wouldn&amp;rsquo;t I use SignalR for real-time?&lt;/h2&gt;

&lt;p&gt;Well, the reason is quite simple: SignalR for ASP .NET Core is still in its very incipient stages. A preview is expected mid-2017, while a release near the end of 2017, so most probably it will be available for ASP .NET Core 2.0.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/real-time-aspnet-core/timeline.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The preview and release information, as well as the photo above were taken from &lt;a href=&#34;https://vimeo.com/204078084&#34;&gt;this talk by Damian Edwards and David Fowler, the guys in charge of ASP .NET Core and SignalR&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Basically, this offers a way to provide real-time functionality to your application right now if you don&amp;rsquo;t want to wait until mid-2017 for a SignalR preview.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;At this moment, booting up a simple SignalR sample cannot be done under ASP .NET Core 1.1, the latest stable release of the framework.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;so-wait-is-this-related-to-signalr&#34;&gt;So wait. Is this related to SignalR?&lt;/h2&gt;

&lt;p&gt;Simple answer: &lt;strong&gt;NO. This is not an official release from Microsoft&lt;/strong&gt; and is not in any way related to the &lt;a href=&#34;https://github.com/aspnet/signalr&#34;&gt;SignalR project which is developed on GitHub in this repository&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;However, a lot of concepts were inspired from both the new and the old SignalR, so if you wrote SignalR in the past, a lot of the concepts will be familiar.&lt;/p&gt;

&lt;p&gt;Because the release of SignalR for ASP .NET Core was delayed for so long, I decided to write a very basic, stripped down (compared to the original SignalR) that only supports WebSockets (is based on &lt;code&gt;Microsoft.AspNetCore.WebSockets&lt;/code&gt;) with server support, TypeScript and C# clients.&lt;/p&gt;

&lt;p&gt;This started as a fun side project (and I am pretty sure it will stay this way once SignalR becomes ready for production).&lt;/p&gt;

&lt;h2 id=&#34;high-level-overview&#34;&gt;High-level overview&lt;/h2&gt;

&lt;p&gt;This library offers &lt;strong&gt;real-time functionality to ASP .NET Core applications&lt;/strong&gt;, using WebSockets. It also supports &lt;strong&gt;the client and the server calling each others&amp;rsquo; methods&lt;/strong&gt; (mainly like in the good old SignalR).&lt;/p&gt;

&lt;p&gt;In order to get real-time functionality in your application, you need to create a class (called &lt;code&gt;Handler&lt;/code&gt;, which inherits &lt;a href=&#34;https://github.com/radu-matei/websocket-manager/blob/master/src/WebSocketManager/WebSocketHandler.cs&#34;&gt;&lt;code&gt;WebSocketHandler&lt;/code&gt;&lt;/a&gt;), that is very similar to the &lt;code&gt;Hub&lt;/code&gt; class in SignalR.&lt;/p&gt;

&lt;p&gt;Then, in this &lt;code&gt;Handler&lt;/code&gt; class you can create public methods that the (JavaScript and C#) clients can call, and can call client methods.&lt;/p&gt;

&lt;p&gt;Another approach is for MVC applications, where you create the &lt;code&gt;Handler&lt;/code&gt; class without any public methods, but as a proxy, and provide notifications to the clients from a controller (again, very much like in SignalR).&lt;/p&gt;

&lt;p&gt;The library uses a fire-and-forget approach both on the client and the server, meaning that it tells the server / client what method to call and that&amp;rsquo;s it, it doesn&amp;rsquo;t track the execution of that method.&lt;/p&gt;

&lt;p&gt;Next, we will use at how to add this library to an ASP .NET Core application.&lt;/p&gt;

&lt;h2 id=&#34;getting-started-with-websocket-manager&#34;&gt;Getting started with websocket-manager&lt;/h2&gt;

&lt;p&gt;The easiest way to get started is to first clone / fork the project from GitHub.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/radu-matei/websocket-manager&#34;&gt;&lt;code&gt;git clone https://github.com/radu-matei/websocket-manager&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Then, in the &lt;a href=&#34;https://github.com/radu-matei/websocket-manager/tree/master/samples&#34;&gt;&lt;code&gt;samples&lt;/code&gt;&lt;/a&gt; directory, make a new directory and create a new .NET Core application using the &lt;code&gt;dotnet new&lt;/code&gt; command. This will be our web application, and the reason we create it in the &lt;code&gt;samples&lt;/code&gt; folder is because we will need to add a reference to the &lt;code&gt;websocket-manager&lt;/code&gt; project (since the package is not yet on NuGet).&lt;/p&gt;

&lt;p&gt;Create a new .NET Core application using the &lt;code&gt;dotnet new&lt;/code&gt; command, then open the folder in VS Code. First of all, we need to update &lt;code&gt;project.json&lt;/code&gt; to reference a few NuGet packages:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;Microsoft.AspNetCore.Server.Kestrel&amp;quot;:&amp;quot;1.1.0&amp;quot;&lt;/code&gt; (the Kestrel web server that makes this a web application)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;Microsoft.AspNetCore.StaticFiles&amp;quot;:&amp;quot;1.1.0&amp;quot;&lt;/code&gt; (package that allows us to server static files)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;Newtonsoft.Json&amp;quot;:&amp;quot;9.0.1&amp;quot;&lt;/code&gt; (we will not explicitly use Newtonsoft.Json, but this is a bug in the tooling where I also need to reference a package that I use in the library in the project using the library. This should not be necessary in future tooling releases.)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;WebSocketManager&amp;quot;: {
      &amp;quot;target&amp;quot;: &amp;quot;project&amp;quot;
    }&lt;/code&gt; - this is the reference to the &lt;code&gt;websocket-manager&lt;/code&gt; project in the &lt;code&gt;src&lt;/code&gt; folder&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This is how &lt;code&gt;project.json&lt;/code&gt; looks like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;version&amp;quot;: &amp;quot;1.0.0-*&amp;quot;,
  &amp;quot;buildOptions&amp;quot;: {
    &amp;quot;debugType&amp;quot;: &amp;quot;portable&amp;quot;,
    &amp;quot;emitEntryPoint&amp;quot;: true
  },
  &amp;quot;frameworks&amp;quot;: {
    &amp;quot;netcoreapp1.1&amp;quot;: {
      &amp;quot;dependencies&amp;quot;: {
        &amp;quot;Microsoft.NETCore.App&amp;quot;: {
          &amp;quot;type&amp;quot;: &amp;quot;platform&amp;quot;,
          &amp;quot;version&amp;quot;: &amp;quot;1.1.0&amp;quot;
        },
        &amp;quot;WebSocketManager&amp;quot;: {
          &amp;quot;target&amp;quot;: &amp;quot;project&amp;quot;
        },
        &amp;quot;Microsoft.AspNetCore.Server.Kestrel&amp;quot;: &amp;quot;1.1.0&amp;quot;,
        &amp;quot;Microsoft.AspNetCore.StaticFiles&amp;quot;: &amp;quot;1.1.0&amp;quot;,
        &amp;quot;Newtonsoft.Json&amp;quot;: &amp;quot;9.0.1&amp;quot;
      },
      &amp;quot;imports&amp;quot;: &amp;quot;dnxcore50&amp;quot;
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then, we need to update our &lt;code&gt;Program.cs&lt;/code&gt; to make this a web application, including our &lt;code&gt;Startup&lt;/code&gt; class:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        public static void Main(string[] args)
        {
            var host = new WebHostBuilder()
                .UseKestrel()
                .UseContentRoot(Directory.GetCurrentDirectory())
                .UseStartup&amp;lt;Startup&amp;gt;()
                .Build();

            host.Run();
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So far this looks just like all ASP .NET Core applications showcased on this blog before, just the bare minimum parts necessary.&lt;/p&gt;

&lt;p&gt;Now let&amp;rsquo;s add a &lt;code&gt;Startup&lt;/code&gt; class.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://radu-matei.github.io/blog/aspnet-core-startup/&#34;&gt;More on the &lt;code&gt;Startup&lt;/code&gt; class in this article.&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;First of all, in the &lt;code&gt;ConfigureServices&lt;/code&gt; method we need to add the &lt;code&gt;WebSocketManager&lt;/code&gt; service that is used across &lt;code&gt;websocket-manager&lt;/code&gt;. This extension method adds &lt;code&gt;WebSocketConnectionManager&lt;/code&gt; to the &lt;code&gt;services&lt;/code&gt;, as well as all classes that inherit &lt;code&gt;WebSocketHandler&lt;/code&gt; (more on this later).&lt;/p&gt;

&lt;p&gt;In the &lt;code&gt;Configure&lt;/code&gt; method, we need to use WebSockets and Static Files. (The full &lt;code&gt;Startup&lt;/code&gt; class will be here soon).&lt;/p&gt;

&lt;h2 id=&#34;building-a-chat-application&#34;&gt;Building a chat application&lt;/h2&gt;

&lt;p&gt;The all present example when talking about SignalR was a chat application, and I couldn&amp;rsquo;t think of a better example, so we will build an ASP .NET Core chat application, with a webpage and a console application that logs every message.&lt;/p&gt;

&lt;p&gt;We will need to add a &lt;code&gt;Handler&lt;/code&gt; class that will allow the clients to connect to our application. This class needs to inherit the &lt;code&gt;WebSocketHandler&lt;/code&gt; class from the library.&lt;/p&gt;

&lt;p&gt;Since this uses the ASP .NET Core built-in dependency injection, this class will have a constructor that passes all relevant components (in this case &lt;code&gt;WebSocketManager&lt;/code&gt; - that we will not use directly).&lt;/p&gt;

&lt;p&gt;This class will handle clients connecting and disconecting, exposes public methods that clients directly call (invoke) and allows the invocation of client methods.&lt;/p&gt;

&lt;p&gt;The library uses a&lt;a href=&#34;https://github.com/radu-matei/websocket-manager/blob/master/src/WebSocketManager.Common/Message.cs&#34;&gt; &lt;code&gt;Message&lt;/code&gt; class&lt;/a&gt; to pass messages between the server and clients, which contains a &lt;code&gt;MessageType&lt;/code&gt; (most likely this will be a method invocation) and a &lt;code&gt;Data&lt;/code&gt; field which can be used to hold any JSON-serialized object (since it is a &lt;code&gt;string&lt;/code&gt; field). This is how we will pass log messages to the clients.&lt;/p&gt;

&lt;h2 id=&#34;connection-and-disconnection-events&#34;&gt;Connection and Disconnection events&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;        public override async Task OnConnected(WebSocket socket)
        {
            await base.OnConnected(socket);

            var socketId = WebSocketConnectionManager.GetId(socket);

            var message = new Message()
            {
                MessageType = MessageType.Text,
                Data = $&amp;quot;{socketId} is now connected&amp;quot;
            };

            await SendMessageToAllAsync(message);
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;First of all, we need to call &lt;code&gt;await base.OnConnected&lt;/code&gt; so that the framework registers the connection. Then, we can retrieve the &lt;code&gt;ConnectionId&lt;/code&gt; from the &lt;code&gt;WebSocketConnectionManager&lt;/code&gt; so that we can send all clients (by using &lt;code&gt;SendMessageToAllAsync&lt;/code&gt;) a log about who connected.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The &lt;code&gt;SendMessageToAllAsync&lt;/code&gt; method will be mainly used to pass logs to the clients and will most likely be refactored to emphasise this aspect. But for now, you might want to send plain text messages to clients, rather than method invocations.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&#34;https://github.com/radu-matei/websocket-manager/blob/master/src/WebSocketManager/WebSocketHandler.cs#L70-L83&#34;&gt;&lt;code&gt;InvokeClientMethodAsync&lt;/code&gt; method&lt;/a&gt; also uses the &lt;code&gt;SendMessageAsync&lt;/code&gt; method, passing a serialized &lt;a href=&#34;https://github.com/radu-matei/websocket-manager/blob/master/src/WebSocketManager.Common/InvocationDescriptor.cs&#34;&gt;&lt;code&gt;InvocationDescriptor&lt;/code&gt;&lt;/a&gt; for the &lt;code&gt;Data&lt;/code&gt; field.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In a similar manner we treat the disconnection event:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        public override async Task OnDisconnected(WebSocket socket)
        {
            var socketId = WebSocketConnectionManager.GetId(socket);
            
            await base.OnDisconnected(socket);

            var message = new Message()
            {
                MessageType = MessageType.Text,
                Data = $&amp;quot;{socketId} disconnected&amp;quot;
            };
            await SendMessageToAllAsync(message);
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;The only notable difference here is that we retrieve the connection id before calling &lt;code&gt;base.OnDisconnected&lt;/code&gt;, since this method removes the connection id from the framework.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;creating-server-methods-and-invoking-client-mehtods&#34;&gt;Creating server methods and invoking client mehtods&lt;/h2&gt;

&lt;p&gt;All &lt;code&gt;public&lt;/code&gt; methods in a &lt;code&gt;Handler&lt;/code&gt; class can be invoked by connected clients.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public async Task SendMessage(string socketId, string message)
{
    await InvokeClientMethodToAllAsync(&amp;quot;receiveMessage&amp;quot;, socketId, message);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is how such a method would look like. When a client calls the &lt;code&gt;SendMessage&lt;/code&gt; method on the server, the server will tell all connected clients to invoke the &lt;code&gt;receiveMessage&lt;/code&gt; method, with &lt;code&gt;socketId&lt;/code&gt; and &lt;code&gt;message&lt;/code&gt; as parameters.&lt;/p&gt;

&lt;h2 id=&#34;the-full-chathandler-class&#34;&gt;The full &lt;code&gt;ChatHandler&lt;/code&gt; class&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;    public class ChatHandler : WebSocketHandler
    {
        public ChatHandler(WebSocketConnectionManager webSocketConnectionManager) 
                                                    : base(webSocketConnectionManager)
        {
        }

        public override async Task OnConnected(WebSocket socket)
        {
            await base.OnConnected(socket);

            var socketId = WebSocketConnectionManager.GetId(socket);

            var message = new Message()
            {
                MessageType = MessageType.Text,
                Data = $&amp;quot;{socketId} is now connected&amp;quot;
            };

            await SendMessageToAllAsync(message);
        }
   
        public async Task SendMessage(string socketId, string message)
        {
            await InvokeClientMethodToAllAsync(&amp;quot;receiveMessage&amp;quot;, socketId, message);
        }

        public override async Task OnDisconnected(WebSocket socket)
        {
            var socketId = WebSocketConnectionManager.GetId(socket);
            
            await base.OnDisconnected(socket);

            var message = new Message()
            {
                MessageType = MessageType.Text,
                Data = $&amp;quot;{socketId} disconnected&amp;quot;
            };
            await SendMessageToAllAsync(message);
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;plugging-the-handler-in-startup&#34;&gt;Plugging the handler in Startup&lt;/h2&gt;

&lt;p&gt;We created a &lt;code&gt;Handler&lt;/code&gt; class, but we need to register it in &lt;code&gt;Startup&lt;/code&gt; and map clients connecting to a specific path to this &lt;code&gt;ChatHandler&lt;/code&gt; class, since we can have multiple handlers in the same application.&lt;/p&gt;

&lt;p&gt;In the &lt;code&gt;Configure&lt;/code&gt; method inside &lt;code&gt;Startup&lt;/code&gt;, we need to map all clients connecting to a path in our application (in this case &amp;ldquo;/chat&amp;rdquo;) to be handled by a &lt;code&gt;Handler&lt;/code&gt; class, in this case &lt;code&gt;ChatHandler&lt;/code&gt; (given by the service provider).&lt;/p&gt;

&lt;p&gt;&lt;code&gt;app.MapWebSocketManager(&amp;quot;/chat&amp;quot;, serviceProvider.GetService&amp;lt;ChatHandler&amp;gt;());&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;This is the full &lt;code&gt;Configure&lt;/code&gt; method in &lt;code&gt;Startup&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        public void Configure(IApplicationBuilder app, IServiceProvider serviceProvider)
        {
            app.UseWebSockets();
            app.MapWebSocketManager(&amp;quot;/chat&amp;quot;, serviceProvider.GetService&amp;lt;ChatHandler&amp;gt;());

            app.UseStaticFiles();
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is pretty much it on the server side. Next, we will create web and .NET clients.&lt;/p&gt;

&lt;h2 id=&#34;creating-the-web-client&#34;&gt;Creating the web client&lt;/h2&gt;

&lt;p&gt;So far we created the server part of our chat application. Now let&amp;rsquo;s look at creating the JavaScript part for connecting to our application.&lt;/p&gt;

&lt;p&gt;First, we need to create a &lt;code&gt;wwwroot&lt;/code&gt; folder in the root of our web application, and in there create a new HTML file.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;You can take a look at the &lt;a href=&#34;https://github.com/radu-matei/websocket-manager/blob/master/src/WebSocketManager.Client.TS/src/Connection.ts&#34;&gt;TypeScript client on GitHub.&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;In an HTML page we will use the JavaScript transpiled version of the TypeScript client. To use, simply &lt;a href=&#34;https://rawgit.com/radu-matei/websocket-manager/master/src/WebSocketManager.Client.TS/dist/WebSocketManager.js&#34;&gt;include this script in your page that was generated by WebPack.&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;After including the &lt;code&gt;WebSocketManager&lt;/code&gt; script in your page, in order to create a new connection write:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;var connection = new WebSocketManager.Connection(&amp;quot;ws://localhost:5000/chat&amp;quot;);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Then, create client methods that the server can invoke:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;            connection.clientMethods[&amp;quot;receiveMessage&amp;quot;] = (socketId, message) =&amp;gt; {
                var messageText = socketId + &amp;quot; said: &amp;quot; + message;
               
                console.log(messageText);
                // do something with the message
            };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then, simply start the connection:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;connection.start();&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;And this is pretty much it. You can configure logging and have custom functionality for connection and disconnection events, but all those are optional.&lt;/p&gt;

&lt;p&gt;The following page has a text input area, a button and a message list - a very basic chat page.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Note the optional connection and disconnection methods.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;

&amp;lt;head&amp;gt;
	&amp;lt;meta charset=&amp;quot;utf-8&amp;quot; /&amp;gt;
	&amp;lt;title&amp;gt;Test Page&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;
	&amp;lt;h1&amp;gt;This should be mapped to &amp;quot;/chat&amp;quot;&amp;lt;/h1&amp;gt;
	&amp;lt;input type=text id=&amp;quot;textInput&amp;quot; placeholder=&amp;quot;Enter your text&amp;quot; /&amp;gt;
	&amp;lt;button id=&amp;quot;sendButton&amp;quot;&amp;gt;Send&amp;lt;/button&amp;gt;

	&amp;lt;ul id=&amp;quot;messages&amp;quot;&amp;gt;&amp;lt;/ul&amp;gt;


	&amp;lt;script data-main=&amp;quot;scripts/main&amp;quot; src=&amp;quot;https://rawgit.com/radu-matei/websocket-manager/master/src/WebSocketManager.Client.TS/dist/WebSocketManager.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;

	&amp;lt;script language=&amp;quot;javascript&amp;quot; type=&amp;quot;text/javascript&amp;quot;&amp;gt;
          
            var connection = new WebSocketManager.Connection(&amp;quot;ws://localhost:5000/chat&amp;quot;);
            connection.enableLogging = true;

            connection.connectionMethods.onConnected = () =&amp;gt; {
                //optional
                console.log(&amp;quot;You are now connected! Connection ID: &amp;quot; + connection.connectionId);
            }

            connection.connectionMethods.onDisconnected = () =&amp;gt; {
                //optional
                console.log(&amp;quot;Disconnected!&amp;quot;);
            }

            connection.clientMethods[&amp;quot;receiveMessage&amp;quot;] = (socketId, message) =&amp;gt; {
                var messageText = socketId + &amp;quot; said: &amp;quot; + message;
               
                console.log(messageText);
                appendItem(list, messageText);
            };

            connection.start();

            var list = document.getElementById(&amp;quot;messages&amp;quot;);
            var button = document.getElementById(&amp;quot;sendButton&amp;quot;); 
            button.addEventListener(&amp;quot;click&amp;quot;, function() {
            
                var input = document.getElementById(&amp;quot;textInput&amp;quot;);
                connection.invoke(&amp;quot;SendMessage&amp;quot;, connection.connectionId, input.value);
            
                input.value = &amp;quot;&amp;quot;;
            });
            
            function appendItem(list, message) {
                var item = document.createElement(&amp;quot;li&amp;quot;);
                item.appendChild(document.createTextNode(message));
                list.appendChild(item);
             }
    &amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;

&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is pretty much the entire chat application. You can find it on GitHub, as &lt;a href=&#34;https://github.com/radu-matei/websocket-manager/tree/master/samples/ChatApplication&#34;&gt;the &lt;code&gt;ChatApplication&lt;/code&gt; sample in the repo.&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;so-does-this-really-work&#34;&gt;So does this really work?&lt;/h2&gt;

&lt;p&gt;Simply start the ASP .NET Core web application and navigate to &lt;code&gt;http://localhost:5000/client.html&lt;/code&gt; (if you run directly the sample in the GitHub repository).&lt;/p&gt;

&lt;p&gt;Then, start another tab with the same page and check it out:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/real-time-aspnet-core/web-chat.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;the-net-client&#34;&gt;The .NET Client&lt;/h2&gt;

&lt;p&gt;As I said earlier, there is also a C# client. Simply start a new .NET Core console application, reference the &lt;code&gt;WebsocketManager.Client&lt;/code&gt; project from the repository and start a new connection. First, let&amp;rsquo;s look at &lt;code&gt;project.json&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/radu-matei/websocket-manager/tree/master/samples/EchoConsoleClient&#34;&gt;The C# client is available on GitHub, under the &lt;code&gt;samples&lt;/code&gt; folder.&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;version&amp;quot;: &amp;quot;1.0.0-*&amp;quot;,
  &amp;quot;buildOptions&amp;quot;: {
    &amp;quot;debugType&amp;quot;: &amp;quot;portable&amp;quot;,
    &amp;quot;emitEntryPoint&amp;quot;: true
  },
  &amp;quot;dependencies&amp;quot;: {},
  &amp;quot;frameworks&amp;quot;: {
    &amp;quot;netcoreapp1.1&amp;quot;: {
      &amp;quot;dependencies&amp;quot;: {
        &amp;quot;Microsoft.NETCore.App&amp;quot;: {
          &amp;quot;type&amp;quot;: &amp;quot;platform&amp;quot;,
          &amp;quot;version&amp;quot;: &amp;quot;1.1.0&amp;quot;
        },
        &amp;quot;WebSocketManager.Client&amp;quot;: {
          &amp;quot;target&amp;quot;: &amp;quot;project&amp;quot;
        },
        &amp;quot;WebSocketManager.Common&amp;quot;: {
          &amp;quot;target&amp;quot;: &amp;quot;project&amp;quot;
        }
      },
      &amp;quot;imports&amp;quot;: &amp;quot;dnxcore50&amp;quot;
    }
  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Note that I also had to include the &lt;code&gt;Common&lt;/code&gt; project - the same bug that made me include &lt;code&gt;Newtonsoft.Json&lt;/code&gt; in the web application - hopefully with the new tooling of .NET Core this will not be necessary.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Then, the program itself is rather simple:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Program 
{
    private static Connection _connection;
    public static void Main(string[] args)
    {
        StartConnectionAsync();

        _connection.On(&amp;quot;receiveMessage&amp;quot;, (arguments) =&amp;gt; 
        {
            Console.WriteLine($&amp;quot;{arguments[0]} said: {arguments[1]}&amp;quot;);
        });

        Console.ReadLine();
        StopConnectionAsync();
    }

    public static async Task StartConnectionAsync()
    {
        _connection = new Connection();
        await _connection.StartConnectionAsync(&amp;quot;ws://localhost:5000/chat&amp;quot;);
    }

    public static async Task StopConnectionAsync()
    {
        await _connection.StopConnectionAsync();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;While keeping the web application running, start this console application as well and the behavior should be similar to:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/real-time-aspnet-core/console-chat.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;integrating-this-in-an-mvc-application&#34;&gt;Integrating this in an MVC application&lt;/h2&gt;

&lt;p&gt;Most applications are not chat applications. And in most ASP .NET Core applications MVC is used. This library can also be integrated with MVC, so you can have most of the traffic going through MVC and only the notifications going through WebSocketManager.&lt;/p&gt;

&lt;p&gt;Since the client will not invoke &lt;code&gt;Handler&lt;/code&gt; methods directly, the &lt;code&gt;Handler&lt;/code&gt; class only contains the constructor:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public class NotificationsMessageHandler : WebSocketHandler
    {
        public NotificationsMessageHandler(WebSocketConnectionManage webSocketConnectionManager) 
                        : base(webSocketConnectionManager)
        {
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then, in the MVC Controller simply have a property of the &lt;code&gt;Handler&lt;/code&gt; type and use it to invoke client methods inside controller methods:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public class MessagesController : Controller
    {
        private NotificationsMessageHandler _notificationsMessageHandler { get; set; }

        public MessagesController(NotificationsMessageHandler notificationsMessageHandler)
        {
            _notificationsMessageHandler = notificationsMessageHandler;
        }

        [HttpGet]
        public async Task SendMessage([FromQueryAttribute]string message)
        {
           await _notificationsMessageHandler.InvokeClientMethodToAllAsync(&amp;quot;receiveMessage&amp;quot;, message);
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And this is pretty much it!&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/real-time-aspnet-core/mvc.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;As I stated many times so far, this started as a fun side project and will probably remain so. The new SignalR will bring awesome new features and I will surely enjoy working with it.&lt;/p&gt;

&lt;p&gt;But until it is ready to play with, this brings an alternative to bringing real-time functionality to your ASP .NET Core applications.&lt;/p&gt;

&lt;h2 id=&#34;contributing-to-this-project-https-github-com-radu-matei-websocket-manager&#34;&gt;&lt;a href=&#34;https://github.com/radu-matei/websocket-manager&#34;&gt;Contributing to this project&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/radu-matei/websocket-manager&#34;&gt;Contributions of any type are welcomed! Please visit the GitHub repository and create issues and pull requests.&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;feedback-wanted&#34;&gt;Feedback wanted&lt;/h2&gt;

&lt;p&gt;If you stumbled upon this article, please take a moment and provide some feedback both on the library itself and on the way the article is written. Any feedback is immensely appreciated, as well as questions and observations.&lt;/p&gt;

&lt;h2 id=&#34;thanks-for-reading&#34;&gt;Thanks for reading :)&lt;/h2&gt;
</description>
    </item>
    
    <item>
      <title>Creating a WebSockets middleware for ASP .NET Core</title>
      <link>https://radu-matei.com/blog/aspnet-core-websockets-middleware/</link>
      <pubDate>Fri, 30 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>https://radu-matei.com/blog/aspnet-core-websockets-middleware/</guid>
      <description>

&lt;h2 id=&#34;update-february-2017&#34;&gt;UPDATE - February 2017&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://radu-matei.github.ioblog/real-time-aspnet-core/&#34;&gt;This article describes the latest development of websocket-manager and how to use it in your application&lt;/a&gt;.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;While the general aspects provided in this article about creating a websockets middleware for Asp .Net Core are still valid, the specific information about the websocket-manager project have changed, since I updated a lot of parts.&lt;/p&gt;

&lt;p&gt;The version of the project described in this article can still be found in the &lt;a href=&#34;https://github.com/radu-matei/websocket-manager/tree/blog-article&#34;&gt;&lt;code&gt;blog-article&lt;/code&gt;&lt;/a&gt; branch on GitHub.&lt;/p&gt;

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;WebSocket is a computer communications protocol, providing full-duplex communication channels over a single TCP connection.&lt;/p&gt;

&lt;p&gt;WebSocket is designed to be implemented in web browsers and web servers, but it can be used by any client or server application. The WebSocket Protocol is an independent TCP-based protocol.&lt;/p&gt;

&lt;p&gt;More from &lt;a href=&#34;https://en.wikipedia.org/wiki/WebSocket&#34;&gt;Wikipedia on WebSockets&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In the traditional paradigm of the web, the client was the one responsible for initiating the communication with a server, and the server could not send data back unless it had been previously requested by the client.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/aspnet-core-websockets-middleware/request.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;With WebSockets, you can send data between the server and the client over a single TCP connection, and usually WebSockets are used to provide real-time functionality to modern applications.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/aspnet-core-websockets-middleware/sockets.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://www.pubnub.com/wp-content/uploads/2014/09/WebSockets-Diagram.png&#34;&gt;Image from pubnub.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;what-is-this-article-about&#34;&gt;What is this article about?&lt;/h2&gt;

&lt;p&gt;This article is about WebSockets in ASP.NET Core. We will learn how to use them in a simple web application by building a middleware that manages WebSocket connections and sends messages to multiple clients.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;You can find a &lt;a href=&#34;https://github.com/radu-matei/websocket-manager/tree/blog-article&#34;&gt;repository containing the source code of this article on GitHub&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I created a branch for this article since I will most likely update things in the future. For the latest version, check the &lt;code&gt;master&lt;/code&gt; or &lt;code&gt;dev&lt;/code&gt; branches.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;For the past few months I&amp;rsquo;ve been meaning to write a middleware for ASP .NET Core but never quite got the right idea for it. &lt;a href=&#34;https://radu-matei.github.io/categories/signalr/&#34;&gt;I have also been playing with the old SignalR on ASP .NET Core&lt;/a&gt; (which by the way, got discontinued and &lt;a href=&#34;https://github.com/aspnet/signalr&#34;&gt;work is being done in a new repo here&lt;/a&gt;), so I was aware of the WebSockets package but didn&amp;rsquo;t have the chance to play with it.&lt;/p&gt;

&lt;p&gt;Then I decided that for a side project I would need some real-time functionality, and since I was on ASP .NET Core and SignalR was not yet ready to be played with, I decided to write a simple middleware to manage WebSocket connections.&lt;/p&gt;

&lt;p&gt;Now, the middleware we are about to build is at most useful if you know the clients will support WebSocket connectivity (unlike a Windows 7 PC for example) and is only intended as an fun side project, in no case having production in mind.&lt;/p&gt;

&lt;p&gt;It was also built on the experience I had using SignalR for a while now, so you if find yourself wondering: &lt;em&gt;Didn&amp;rsquo;t I see something similar with SignalR?&lt;/em&gt;, the answer is most likely &lt;em&gt;Yes, you did!&lt;/em&gt;. This middleware resembles SignalR in sending real-time data, but only has WebSockets as transport, doesn&amp;rsquo;t handle reconnection events and currently does not support the server and the clients calling each others&amp;rsquo; methods.&lt;/p&gt;

&lt;p&gt;That being said, let&amp;rsquo;s start exploring how to use WebSockets in ASP .NET Core.&lt;/p&gt;

&lt;h2 id=&#34;getting-started-with-websockets-in-asp-net-core&#34;&gt;Getting started with WebSockets in ASP .NET Core&lt;/h2&gt;

&lt;p&gt;There is no point in writing a &amp;ldquo;WebSockets 101&amp;rdquo; article since there are a few that explain very well what you need in order to get started and I will list the articles I used when getting started:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/aspnet/websockets&#34;&gt;the WebSockets repository on GitHub contains all source code for this package&lt;/a&gt; and it really helps you to understand how everything works&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://zbrad.github.io/tools/wscore/&#34;&gt;article from Brad Merrill that also contains GitHub repository&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://dotnetthoughts.net/using-websockets-in-aspnet-core/&#34;&gt;article by Anuraj P from dotnetthoughts&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Basically, you need to:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;add a reference to &lt;code&gt;Microsoft.AspNetCore.WebSockets&lt;/code&gt; in &lt;code&gt;project.json&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;add &lt;code&gt;app.UseWebSockets()&lt;/code&gt; in the &lt;code&gt;Configure&lt;/code&gt; method inside the &lt;code&gt;Startup&lt;/code&gt; class&lt;/li&gt;
&lt;li&gt;create a response pipeline that handles WebSockets requests&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;Both articles referenced above contain step-by-step examples on how to get this working&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/aspnet/WebSockets/tree/dev/samples/EchoApp&#34;&gt;In the official WebSockets repository on GitHub you can find a sample of a full application that echoes all messages received&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;asp-net-core-middleware&#34;&gt;ASP .NET Core Middleware&lt;/h2&gt;

&lt;p&gt;First of all, it is important to understand what middleware is and how the new request pipeline works in ASP .NET Core, and there is a &lt;a href=&#34;https://docs.microsoft.com/en-us/aspnet/core/fundamentals/middleware&#34;&gt;great article on that from the Official ASP .NET Core Documentation&lt;/a&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Middleware are software components that are assembled into an application pipeline to handle requests and responses. Each component chooses whether to pass the request on to the next component in the pipeline, and can perform certain actions before and after the next component is invoked in the pipeline. Request delegates are used to build the request pipeline. The request delegates handle each HTTP request.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/aspnet-core-websockets-middleware/request-pipeline.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.microsoft.com/en-us/aspnet/core/fundamentals/middleware/_static/request-delegate-pipeline.png&#34;&gt;Image from the Official ASP .NET Core Documentation&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The new pipeline consists of a series of &lt;code&gt;RequestDelegate&lt;/code&gt; objects being called one after the next, and each component can perform operations before and after the next delegate, or can short-cirtuit the pipeline, handle the request itself and not pass the context further.&lt;/p&gt;

&lt;p&gt;Before writing the middleware itself, we need a few classes that deal with connections and handling messages.&lt;/p&gt;

&lt;h2 id=&#34;writing-a-websocket-connection-manager&#34;&gt;Writing a WebSocket Connection Manager&lt;/h2&gt;

&lt;p&gt;The first thing we notice when using the WebSocket package is that everything is low-level: we deal with individual connections, buffers and cancellation tokens. There is no built-in way of storing sockets, nor are they identified in any way. So we will build a class that keeps all active sockets in a thread-safe collection and assigns each a unique ID, while also maintaning the collection (getting, adding and removing sockets).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;using System;
using System.Collections.Concurrent;
using System.Linq;
using System.Net.WebSockets;
using System.Threading;
using System.Threading.Tasks;

namespace WebSocketManager
{
    public class WebSocketConnectionManager
    {
        private ConcurrentDictionary&amp;lt;string, WebSocket&amp;gt; _sockets = new ConcurrentDictionary&amp;lt;string, WebSocket&amp;gt;();

        public WebSocket GetSocketById(string id)
        {
            return _sockets.FirstOrDefault(p =&amp;gt; p.Key == id).Value;
        }

        public ConcurrentDictionary&amp;lt;string, WebSocket&amp;gt; GetAll()
        {
            return _sockets;
        }

        public string GetId(WebSocket socket)
        {
            return _sockets.FirstOrDefault(p =&amp;gt; p.Value == socket).Key;
        }
        public void AddSocket(WebSocket socket)
        {
            _sockets.TryAdd(CreateConnectionId(), socket);
        }

        public async Task RemoveSocket(string id)
        {
            WebSocket socket;
            _sockets.TryRemove(id, out socket);

            await socket.CloseAsync(closeStatus: WebSocketCloseStatus.NormalClosure, 
                                    statusDescription: &amp;quot;Closed by the WebSocketManager&amp;quot;, 
                                    cancellationToken: CancellationToken.None);
        }

        private string CreateConnectionId()
        {
            return Guid.NewGuid().ToString();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As I said, it holds the sockets and the socket IDs in a concurrent dictionary and deals with getting, adding and removing sockets.&lt;/p&gt;

&lt;h2 id=&#34;writing-a-websocket-handler&#34;&gt;Writing a WebSocket Handler&lt;/h2&gt;

&lt;p&gt;Now that we have a way of keeping track of the connected clients, we want a class that handles connection and disconnection events and manages sending and receiving messages from the socket. Let&amp;rsquo;s see how a class like this might look like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;using System;
using System.Net.WebSockets;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace WebSocketManager
{
    public abstract class WebSocketHandler
    {
        protected WebSocketConnectionManager WebSocketConnectionManager { get; set; }

        public WebSocketHandler(WebSocketConnectionManager webSocketConnectionManager)
        {
            WebSocketConnectionManager = webSocketConnectionManager;
        }

        public virtual async Task OnConnected(WebSocket socket)
        {
            WebSocketConnectionManager.AddSocket(socket);
        }

        public virtual async Task OnDisconnected(WebSocket socket)
        {
            await WebSocketConnectionManager.RemoveSocket(WebSocketConnectionManager.GetId(socket));
        }

        public async Task SendMessageAsync(WebSocket socket, string message)
        {
            if(socket.State != WebSocketState.Open)
                return;

            await socket.SendAsync(buffer: new ArraySegment&amp;lt;byte&amp;gt;(array: Encoding.ASCII.GetBytes(message),
                                                                  offset: 0, 
                                                                  count: message.Length),
                                   messageType: WebSocketMessageType.Text,
                                   endOfMessage: true,
                                   cancellationToken: CancellationToken.None);          
        }

        public async Task SendMessageAsync(string socketId, string message)
        {
            await SendMessageAsync(WebSocketConnectionManager.GetSocketById(socketId), message);
        }

        public async Task SendMessageToAllAsync(string message)
        {
            foreach(var pair in WebSocketConnectionManager.GetAll())
            {
                if(pair.Value.State == WebSocketState.Open)
                    await SendMessageAsync(pair.Value, message);
            }
        }

        public abstract Task ReceiveAsync(WebSocket socket, WebSocketReceiveResult result, byte[] buffer);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first thing to notice is that the class is &lt;code&gt;abstract&lt;/code&gt;. This means &lt;strong&gt;you need to inherit it&lt;/strong&gt; and provide actual implementation for the &lt;code&gt;ReceiveAsync&lt;/code&gt; method, as well as you can &lt;code&gt;override&lt;/code&gt; the methods marked as &lt;code&gt;virtual&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s the &lt;code&gt;OnConnected&lt;/code&gt; and &lt;code&gt;OnDisconnected&lt;/code&gt; methods that are executed whenever a new socket connects or an existing one sends a &lt;code&gt;Close&lt;/code&gt; message.&lt;/p&gt;

&lt;p&gt;These methods are &lt;code&gt;virtual&lt;/code&gt;, meaning that you can provide your own functionality for connecting and disconnecting events.&lt;/p&gt;

&lt;p&gt;There is also the &lt;code&gt;SendMessageAsync&lt;/code&gt; which sends a message to a specific &lt;code&gt;socketId&lt;/code&gt; and &lt;code&gt;SendMessageToAllAsync&lt;/code&gt;, which sends a message to all connected clients.&lt;/p&gt;

&lt;h2 id=&#34;the-middleware-itself&#34;&gt;The middleware itself&lt;/h2&gt;

&lt;p&gt;So far we built classes that help maintaning a record of connected sockets and handle sending and receiving messages to and from those sockets. Now it&amp;rsquo;s time to build the actual middleware:&lt;/p&gt;

&lt;p&gt;As any middleware, it needs to receive a &lt;code&gt;RequestDelegate&lt;/code&gt; for the &lt;code&gt;next&lt;/code&gt; component in the pipeline, while executing operations on the &lt;code&gt;HttpContext&lt;/code&gt; before and after invoking the next component, and it needs an &lt;code&gt;async Task Invoke&lt;/code&gt; method. It doesn&amp;rsquo;t have to inherit or implement anything, just to have the &lt;code&gt;Invoke&lt;/code&gt; method.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;You will notice in this version of the middleware that the invocation of the &lt;code&gt;next&lt;/code&gt; component is commented out. This is because an exception thrown by Kestrel when this is the last middleware registered in the pipeline. I will investigate this and update the class as necessary.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;using System.Net.WebSockets;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Http;

namespace WebSocketManager
{
    public class WebSocketManagerMiddleware
    {
        private readonly RequestDelegate _next;
        private WebSocketHandler _webSocketHandler { get; set; }

        public WebSocketManagerMiddleware(RequestDelegate next, 
                                          WebSocketHandler webSocketHandler)
        {
            _next = next;
            _webSocketHandler = webSocketHandler;
        }

        public async Task Invoke(HttpContext context)
        {
            if(!context.WebSockets.IsWebSocketRequest)
                return;
            
            var socket = await context.WebSockets.AcceptWebSocketAsync();
            await _webSocketHandler.OnConnected(socket);
            
            await Receive(socket, async(result, buffer) =&amp;gt;
            {
                if(result.MessageType == WebSocketMessageType.Text)
                {
                    await _webSocketHandler.ReceiveAsync(socket, result, buffer);
                    return;
                }

                else if(result.MessageType == WebSocketMessageType.Close)
                {
                    await _webSocketHandler.OnDisconnected(socket);
                    return;
                }

            });
            
            //TODO - investigate the Kestrel exception thrown when this is the last middleware
            //await _next.Invoke(context);
        }

        private async Task Receive(WebSocket socket, Action&amp;lt;WebSocketReceiveResult, byte[]&amp;gt; handleMessage)
        {
            var buffer = new byte[1024 * 4];

            while(socket.State == WebSocketState.Open)
            {
                var result = await socket.ReceiveAsync(buffer: new ArraySegment&amp;lt;byte&amp;gt;(buffer),
                                                       cancellationToken: CancellationToken.None);

                handleMessage(result, buffer);                
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The middleware is passed an implementation of &lt;code&gt;WebSocketHandler&lt;/code&gt; and a &lt;code&gt;RequestDelegate&lt;/code&gt;. If the request is not a WebSocket request, it just exits the middleware.&lt;/p&gt;

&lt;p&gt;If it is a WebSockets request, then it accepts the connection and passes the socket to the &lt;code&gt;OnConnected&lt;/code&gt; method from the &lt;code&gt;WebSocketHandler&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Then, while the socket is in the &lt;code&gt;Open&lt;/code&gt; state, it awaits for the receival of new data. When it receives the data, it decides wether to pass the context to the &lt;code&gt;ReceiveAsync&lt;/code&gt; method of &lt;code&gt;WebSocketHandler&lt;/code&gt; (notice why you need to pass an actual implementation of the abstract &lt;code&gt;WebSocketHandler&lt;/code&gt; class) or to the &lt;code&gt;OnDisconnected&lt;/code&gt; method (if the message type is &lt;code&gt;Close&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;And basically this is the middleware. There is also a static class for adding extension methods that we will cover briefly.&lt;/p&gt;

&lt;h2 id=&#34;the-extension-methods-for-adding-the-middleware&#34;&gt;The extension methods for adding the middleware&lt;/h2&gt;

&lt;p&gt;Most likely in modern applications you want to send notifications and messages only to clients connected to a specific part of the application (think SignalR Hubs).&lt;/p&gt;

&lt;p&gt;With this middleware, you can map different paths of your application with specific implementations of &lt;code&gt;WebSocketHandler&lt;/code&gt;, so you would get completely isolated environments (and different instances of &lt;code&gt;WebSocketConnectionManager&lt;/code&gt;, but more on this later).&lt;/p&gt;

&lt;p&gt;So mapping the middeware is done using the following extension method on &lt;code&gt;IApplicationBuilder&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        public static IApplicationBuilder MapWebSocketManager(this IApplicationBuilder app, 
                                                              PathString path,
                                                              WebSocketHandler handler)
        {
            return app.Map(path, (_app) =&amp;gt; _app.UseMiddleware&amp;lt;WebSocketManagerMiddleware&amp;gt;(handler));
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It receives a path and it maps that path using with the &lt;code&gt;WebSocketManagerMiddleware&lt;/code&gt; which is passed the specific implementation of &lt;code&gt;WebSockethandler&lt;/code&gt; you provided as argument for the &lt;code&gt;MapWebSocketManager&lt;/code&gt; extension method.&lt;/p&gt;

&lt;p&gt;You also need to add some services in order to use them, and this is done in another extension method on &lt;code&gt;IServiceCollection&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        public static IServiceCollection AddWebSocketManager(this IServiceCollection services)
        {
            services.AddTransient&amp;lt;WebSocketConnectionManager&amp;gt;();

            foreach(var type in Assembly.GetEntryAssembly().ExportedTypes)
            {
                if(type.GetTypeInfo().BaseType == typeof(WebSocketHandler))
                {
                    services.AddSingleton(type);
                }
            }

            return services;
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Besides from adding the &lt;code&gt;WebSocketConnectionManager&lt;/code&gt; service, it also searches the executing assemly for types that inherit &lt;code&gt;WebSocketHandler&lt;/code&gt; and it registers them as singleton (so that every request gets the same instance of the message handler) using reflection.&lt;/p&gt;

&lt;p&gt;And this is pretty much the middleware. Now we will take a look at how we would use it in ASP .NET Core applications, and just like in the case of SignalR, there are two scenarios for usage:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;one where the client actually sends WebSockets requests&lt;/li&gt;
&lt;li&gt;one where the client does some MVC stuff and the other clients get notified&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;At this moment the samples only handle string as messages, but I will handle JSON messages being sent.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;scenario-1-client-sending-messages-through-websockets&#34;&gt;Scenario 1 - Client Sending messages through WebSockets&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;You can &lt;a href=&#34;https://github.com/radu-matei/websocket-manager/tree/blog-article/samples/ChatApplication&#34;&gt;find the working application and the source code on GitHub here&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Using the middleware we just created we will build a chat application (I know, everybody demoes chat applications when playing around with WebSockets).&lt;/p&gt;

&lt;p&gt;Besides being a public chat application, it will also be able to map very basic &lt;em&gt;chat rooms&lt;/em&gt; by creating (in this example) two message handlers and isolating clients from one page from the others.&lt;/p&gt;

&lt;p&gt;As I said earlier, in order to configure the newly created pipeline, we need to call the extension method &lt;code&gt;MapWebSocketManager&lt;/code&gt; in the following way:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;app.MapWebSocketManager(&amp;quot;/path&amp;quot;, instanceOfWebSocketHandler);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s see a real project&amp;rsquo;s &lt;code&gt;Startup&lt;/code&gt; class:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;using System;
using Microsoft.AspNetCore.Builder;
using Microsoft.Extensions.DependencyInjection;

using WebSocketManager;

namespace ChatApplication
{
    public class Startup
    {
        public void Configure(IApplicationBuilder app, IServiceProvider serviceProvider)
        {
            app.UseWebSockets();

            app.MapWebSocketManager(&amp;quot;/ws&amp;quot;, serviceProvider.GetService&amp;lt;ChatMessageHandler&amp;gt;());
            app.MapWebSocketManager(&amp;quot;/test&amp;quot;, serviceProvider.GetService&amp;lt;TestMessageHandler&amp;gt;());

            app.UseStaticFiles();
        }

        public void ConfigureServices(IServiceCollection services)
        {
            services.AddWebSocketManager();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;First we need to &lt;code&gt;UseWebSockets()&lt;/code&gt; (working on putting this inside the extension methods so you don&amp;rsquo;t call it manually), then map the paths you want to be handled by the middleware.&lt;/p&gt;

&lt;p&gt;We said that we need to pass the &lt;code&gt;MapWebSocketManager&lt;/code&gt; method an implementation of &lt;code&gt;WebSocketHandler&lt;/code&gt;. Remember that in the extension method we registered all types that inherited &lt;code&gt;WebSocketHandler&lt;/code&gt; as singletons in the framework. So at this moment we can use the &lt;code&gt;IServiceProvider&lt;/code&gt; to give us instances of those classes.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s have a look at an actual implementation of &lt;code&gt;WebSocketHandler&lt;/code&gt;, &lt;code&gt;ChatMessageHandler&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;using System.Net.WebSockets;
using System.Text;
using System.Threading.Tasks;
using WebSocketManager;

namespace ChatApplication
{
    public class ChatMessageHandler : WebSocketHandler
    {
        public ChatMessageHandler(WebSocketConnectionManager webSocketConnectionManager) : base(webSocketConnectionManager)
        {
        }

        public override async Task OnConnected(WebSocket socket)
        {
            await base.OnConnected(socket);

            var socketId = WebSocketConnectionManager.GetId(socket);
            await SendMessageToAllAsync($&amp;quot;{socketId} is now connected&amp;quot;);
        }

        public override async Task ReceiveAsync(WebSocket socket, WebSocketReceiveResult result, byte[] buffer)
        {
            var socketId = WebSocketConnectionManager.GetId(socket);
            var message = $&amp;quot;{socketId} said: {Encoding.UTF8.GetString(buffer, 0, result.Count)}&amp;quot;;

            await SendMessageToAllAsync(message);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It overrides the &lt;code&gt;OnConnected&lt;/code&gt; method to send a message to everybody broadcasting that a new client connected and it implements the &lt;code&gt;ReceiveAsync&lt;/code&gt; method (by just broadcasting the method to all clients).&lt;/p&gt;

&lt;p&gt;Basically, &lt;code&gt;TestMessageHandler&lt;/code&gt; does mostly the same things, but in a real world application you would have different functionality.&lt;/p&gt;

&lt;p&gt;Now let&amp;rsquo;s add a web client that connects through WebSockets:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;

&amp;lt;head&amp;gt;
	&amp;lt;meta charset=&amp;quot;utf-8&amp;quot; /&amp;gt;
	&amp;lt;title&amp;gt;Real-Time Notifications&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;
    &amp;lt;h1&amp;gt;This should be mapped to &amp;quot;/ws&amp;quot;&amp;lt;/h1&amp;gt;
	&amp;lt;input type=text id=&amp;quot;textInput&amp;quot; placeholder=&amp;quot;Enter your text&amp;quot;/&amp;gt;
	&amp;lt;button id=&amp;quot;sendButton&amp;quot;&amp;gt;Send&amp;lt;/button&amp;gt;

	&amp;lt;ul id=&amp;quot;messages&amp;quot;&amp;gt;&amp;lt;/ul&amp;gt;

    	&amp;lt;script language=&amp;quot;javascript&amp;quot; type=&amp;quot;text/javascript&amp;quot;&amp;gt;
        var uri = &amp;quot;ws://&amp;quot; + window.location.host + &amp;quot;/ws&amp;quot;;
        function connect() {
            socket = new WebSocket(uri);
            socket.onopen = function(event) {
                console.log(&amp;quot;opened connection to &amp;quot; + uri);
            };
            socket.onclose = function(event) {
                console.log(&amp;quot;closed connection from &amp;quot; + uri);
            };
            socket.onmessage = function(event) {
                appendItem(list, event.data);
                console.log(event.data);
            };
            socket.onerror = function(event) {
                console.log(&amp;quot;error: &amp;quot; + event.data);
            };
        }
        connect();
        var list = document.getElementById(&amp;quot;messages&amp;quot;);
        var button = document.getElementById(&amp;quot;sendButton&amp;quot;); 
        button.addEventListener(&amp;quot;click&amp;quot;, function() {
            
            var input = document.getElementById(&amp;quot;textInput&amp;quot;);
            sendMessage(input.value);
            
            input.value = &amp;quot;&amp;quot;;
        });
        function sendMessage(message) { 
            console.log(&amp;quot;Sending: &amp;quot; + message);
            socket.send(message);
        }
        function appendItem(list, message) {
            var item = document.createElement(&amp;quot;li&amp;quot;);
            item.appendChild(document.createTextNode(message));
            list.appendChild(item);
        }    
    &amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is a very simple web page that has an input form and a button. It connects to the server on the &amp;ldquo;/ws&amp;rdquo; path, so all requests will be mapped to &lt;code&gt;ChatMessageHandler&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/aspnet-core-websockets-middleware/chat.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;We can see that messages are passed real-time to all connected clients. Let&amp;rsquo;s add another page that connects to a different path - &amp;ldquo;/test&amp;rdquo; and pass another handler, &lt;code&gt;TestMessageHandler&lt;/code&gt; and another client, &lt;code&gt;test.html&lt;/code&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Remember that you can &lt;a href=&#34;https://github.com/radu-matei/websocket-manager/tree/blog-article/samples/ChatApplication&#34;&gt;find the full working sample on GitHub here&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Let&amp;rsquo;s see what happens now:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/aspnet-core-websockets-middleware/separate-chat.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;You can clearly see that clients receive messages based on the page they are connected to.&lt;/p&gt;

&lt;p&gt;In this case, clients would send data directly through a websocket and the socket events would get handled directly in the specific implementation of &lt;code&gt;WebSocketHandler&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;scenario-2-receiving-real-time-notifications-from-a-controller&#34;&gt;Scenario 2 - Receiving real-time notifications from a controller&lt;/h2&gt;

&lt;p&gt;This time we will build an MVC application and have client send data through the MVC pipeline. Then, the notifications would get fired from within the controller.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;You can &lt;a href=&#34;https://github.com/radu-matei/websocket-manager/tree/blog-article/samples/MvcSample&#34;&gt;find the sample on GitHub, in the &lt;code&gt;MvcSample&lt;/code&gt; folder&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;We will build a standard MVC application and we will add the &lt;code&gt;WebSocketManagerMiddleware&lt;/code&gt; we created. &lt;a href=&#34;https://github.com/radu-matei/websocket-manager/blob/blog-article/samples/MvcSample/Startup.cs&#34;&gt;Here&amp;rsquo;s the &lt;code&gt;Startup&lt;/code&gt; class of this application&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public class Startup
    {
        public void Configure(IApplicationBuilder app, IServiceProvider serviceProvider)
        {
            app.UseStaticFiles();
            app.UseWebSockets();

            app.UseMvc(routes =&amp;gt;
            {
                routes.MapRoute(
                    name: &amp;quot;default&amp;quot;,
                    template: &amp;quot;api/{controller}/{action}/{id?}&amp;quot;
                );
            });

            app.MapWebSocketManager(&amp;quot;/notifications&amp;quot;, serviceProvider.GetService&amp;lt;NotificationsMessageHandler&amp;gt;());
        }

        public void ConfigureServices(IServiceCollection services)
        {
            services.AddMvc();
            services.AddWebSocketManager();
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since this time the handler class only manages the connected clients and will not handle requests itself, we can leave the &lt;code&gt;ReceiveAsync&lt;/code&gt; method unimplemented:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public class NotificationsMessageHandler : WebSocketHandler
    {
        public NotificationsMessageHandler(WebSocketConnectionManager webSocketConnectionManager) : base(webSocketConnectionManager)
        {
        }

        public override Task ReceiveAsync(WebSocket socket, WebSocketReceiveResult result, byte[] buffer)
        {
            throw new NotImplementedException();
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And the controller:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public class MessagesController : Controller
    {
        private NotificationsMessageHandler _notificationsMessageHandler { get; set; }

        public MessagesController(NotificationsMessageHandler notificationsMessageHandler)
        {
            _notificationsMessageHandler = notificationsMessageHandler;
        }

        [HttpGet]
        public async Task SendMessage([FromQueryAttribute]string message)
        {
           await _notificationsMessageHandler.SendMessageToAllAsync(message);
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the controller we will have a &lt;code&gt;NotificationsMessageHandler&lt;/code&gt; instance that will handle the sending of notifications to all connected clients.&lt;/p&gt;

&lt;p&gt;The HTML page is very similar to the previous ones, but this time the message will be sent using the API we created, so through HTTP and not WebSockets, so basically only the &lt;code&gt;sendMessage&lt;/code&gt; method is different:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        function sendMessage(message) { 
            console.log(&amp;quot;Sending: &amp;quot; + message);
            
            $.ajax({
                url: &amp;quot;http://&amp;quot; + window.location.host + &amp;quot;/api/messages/sendmessage?message=&amp;quot; + message,
                method: &#39;GET&#39;
            });
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Notice I only added &lt;code&gt;jQuery&lt;/code&gt; so the HTTP request would be simpler (using &lt;code&gt;AJAX&lt;/code&gt;), it has noting to do with the WebSockets.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Let&amp;rsquo;s see how it works:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/aspnet-core-websockets-middleware/mvc-sample.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Basically, the user doesn&amp;rsquo;t see any difference, but the client is sending data through an HTTP request and receiving it through WebSockets.&lt;/p&gt;

&lt;h2 id=&#34;extra-console-client&#34;&gt;Extra - Console client&lt;/h2&gt;

&lt;p&gt;You can also use a C# console client to connect to the application we created.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;You can &lt;a href=&#34;https://github.com/radu-matei/websocket-manager/blob/blog-article/samples/EchoConsoleClient/Program.cs&#34;&gt;find the source code of this sample on GitHub here&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Note that this console client is pretty much &lt;a href=&#34;https://github.com/aspnet/SignalR/blob/dev/samples/WebSocketSample/Program.cs&#34;&gt;a clone of a WebSocket sample from the SignalR repository&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This sample uses the &lt;code&gt;System.Net.WebSockets&lt;/code&gt; namespace which contains the &lt;code&gt;ClientWebSocket&lt;/code&gt; class (pretty weird name if you ask me).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;using System;
using System.Net.WebSockets;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace EchoConsoleClient
{
    public class Program
    {
        public static void Main(string[] args)
        {
            RunWebSockets().GetAwaiter().GetResult();
        }

        private static async Task RunWebSockets()
        {
            var client = new ClientWebSocket();
            await client.ConnectAsync(new Uri(&amp;quot;ws://localhost:5000/test&amp;quot;), CancellationToken.None);

            Console.WriteLine(&amp;quot;Connected!&amp;quot;);

            var sending = Task.Run(async() =&amp;gt; 
            {
                string line;
                while((line = Console.ReadLine()) != null &amp;amp;&amp;amp; line != String.Empty)
                {
                    var bytes = Encoding.UTF8.GetBytes(line);

                    await client.SendAsync(new ArraySegment&amp;lt;byte&amp;gt;(bytes), WebSocketMessageType.Text, true, CancellationToken.None);
                }

                await client.CloseOutputAsync(WebSocketCloseStatus.NormalClosure, &amp;quot;&amp;quot;, CancellationToken.None);
            });

            var receiving = Receiving(client);

            await Task.WhenAll(sending, receiving);
        }

        private static async Task Receiving(ClientWebSocket client)
        {
            var buffer = new byte[1024 * 4];

            while(true)
            {
                var result = await client.ReceiveAsync(new ArraySegment&amp;lt;byte&amp;gt;(buffer), CancellationToken.None);

                if(result.MessageType == WebSocketMessageType.Text)
                    Console.WriteLine(Encoding.UTF8.GetString(buffer, 0, result.Count));

                else if(result.MessageType == WebSocketMessageType.Close)
                {
                    await client.CloseOutputAsync(WebSocketCloseStatus.NormalClosure, &amp;quot;&amp;quot;, CancellationToken.None);
                    break;
                }
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At this point there is no high level client for WebSockets, so this is how you manage the connection from the client perspective.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Note that both the Chat application and this console client sample must be running.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/aspnet-core-websockets-middleware/console-sample.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Note that in order for a Terminal console to appear when starting the application you need to set the &lt;code&gt;&amp;quot;externalConsole&amp;quot;: true&lt;/code&gt; in &lt;code&gt;launch.json&lt;/code&gt; in VS Code.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;next-steps&#34;&gt;Next Steps&lt;/h2&gt;

&lt;p&gt;In the first place, I should investigate why Kestrel throws an exception when this is the last middleware in the pipeline (maybe it is the intended behaviour?). Then, I should also decide wether I have to create a class that wraps the socket ID and the socket itself in a single object (not sure wether I need this or not).&lt;/p&gt;

&lt;p&gt;Another thing I want to do is to see if there is a way to know wether a middleware has been added to the pipeline (so I place &lt;code&gt;app.UseWebSockets()&lt;/code&gt; in the extension method and not have the user add it). I know that &lt;a href=&#34;https://github.com/aspnet/HttpAbstractions/blob/master/src/Microsoft.AspNetCore.Http/Internal/ApplicationBuilder.cs/#L16&#34;&gt;there is a private field on &lt;code&gt;ApplicationBuilder&lt;/code&gt; called &lt;code&gt;_components&lt;/code&gt; that holds all added middleware, but it is not accessible from &lt;code&gt;app&lt;/code&gt;&lt;/a&gt;, and also understand what happens if you add the same middleware twice.&lt;/p&gt;

&lt;p&gt;This started as a fun side project (and I am pretty sure it will stay this way once SignalR becomes ready for production). Still, if I found the time, I would love to &lt;strong&gt;implement the client and server calling each others&amp;rsquo; methods bit from SignalR&lt;/strong&gt;. I find it to be really cool and think there are some cool things to learn from there.&lt;/p&gt;

&lt;p&gt;And last but not least, I will investigate sending JSON objects as messages rather than simple strings and the necessity of writing JavaScript and C# clients. Most likely that won&amp;rsquo;t happen, but it would be nice if I had the time.&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s take a step back and see what we have done:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;we&amp;rsquo;ve started by investigating the &lt;code&gt;WebSocekts&lt;/code&gt; package from ASP .NET Core&lt;/li&gt;
&lt;li&gt;we&amp;rsquo;ve taken a look at ASP .NET Core middleware&lt;/li&gt;
&lt;li&gt;we&amp;rsquo;ve written a connection manager for WebSocket connections&lt;/li&gt;
&lt;li&gt;we&amp;rsquo;ve written an abstract handler class that deals with connection and disconnection events, while also sending and receiving messages&lt;/li&gt;
&lt;li&gt;we&amp;rsquo;ve built the actual middleware&lt;/li&gt;
&lt;li&gt;we&amp;rsquo;ve added some extension methods to register services and add the middleware in the pipeline&lt;/li&gt;
&lt;li&gt;then we built some samples that demonstrate:

&lt;ul&gt;
&lt;li&gt;how to write a pure-sockets chat application&lt;/li&gt;
&lt;li&gt;how to integrate this middleware with MVC and send notifications to connected clients&lt;/li&gt;
&lt;li&gt;how to build a very simple console client written in C#&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;feedback-wanted&#34;&gt;Feedback wanted&lt;/h2&gt;

&lt;p&gt;If you stumbled upon this article, please take a moment and provide some feedback both on the middleware itself and on the way the article is written. Any feedback is immensely appreciated, as well as questions and observations.&lt;/p&gt;

&lt;p&gt;Also, if you want to &lt;a href=&#34;https://github.com/radu-matei/websocket-manager&#34;&gt;contribute to this middleware, you can find the repository on GitHub&lt;/a&gt;. Any contribution is greatly appreciated.&lt;/p&gt;

&lt;h2 id=&#34;thanks-for-reading&#34;&gt;Thanks for reading! :)&lt;/h2&gt;
</description>
    </item>
    
    <item>
      <title>Dockerizing an ASP.NET Core application with GitHub, Docker Cloud and Azure</title>
      <link>https://radu-matei.com/blog/aspnet-core-docker-azure/</link>
      <pubDate>Sat, 26 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>https://radu-matei.com/blog/aspnet-core-docker-azure/</guid>
      <description>

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;In this article, we will take the simplest ASP.NET Core application, run it with Docker locally, then create Continuous Integration and Continuous Deployment flows using a GitHub repository, Docker Cloud and an Azure virtual machine that will act as a node for Docker Cloud.&lt;/p&gt;

&lt;p&gt;If you don&amp;rsquo;t want to create an ASP.NET Core application but are interested in the CI/CD workflow, or if you already have a GitHub repository with a complete application with a Dockerfile, &lt;a href=&#34;!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!&#34;&gt;you might want to skip to the part we start creating the CI/CD workflow.&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;moving-parts-and-used-components&#34;&gt;Moving parts and used components&lt;/h2&gt;

&lt;p&gt;The main part of a CI/CD workflow like this is the application itself. It can be however complicated, but in this case I want to emphasize the workflow itself and will only build a very simple application with ASP.NET Core.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Note that you can use this article with any single-container application you want to build.&lt;/p&gt;

&lt;p&gt;However, if you want to build multi-container applications, you will most likely need a way to compose and orchestrate those containers. In future articles, we will also deal with multi-container applications, but in this one we will keep things easy.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;We will create a GitHub repository that we will use to create a Docker image and push it to Docker Hub.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Docker Hub is a cloud-based registry service which allows you to link to code repositories, build your images and test them, stores manually pushed images, and links to Docker Cloud so you can deploy images to your hosts. It provides a centralized resource for container image discovery, distribution and change management, user and team collaboration, and workflow automation throughout the development pipeline.&lt;/p&gt;

&lt;p&gt;More information about Docker Hub on &lt;a href=&#34;https://docs.docker.com/docker-hub/&#34;&gt;the Official Docker Documentation&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Then, we will configure an Azure VM to be a node for Docker Cloud and Docker Cloud will automatically publish containers to that VM. Then, every time there are changes in the GitHub repository, Docker Cloud will build the image and publish the container again automatically.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;More information about Docker Cloud on &lt;a href=&#34;https://docs.docker.com/docker-cloud/overview/&#34;&gt;the Official Docker Documentation&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/aspnet-core-docker-azure/ci-cd-workflow.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.docker.com/2016/04/cicd-with-docker-cloud/&#34;&gt;Photo source on the Docker Blog&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;create-a-github-repository&#34;&gt;Create a GitHub repository&lt;/h2&gt;

&lt;p&gt;First, we need a GitHub repository. If you already have a repo with an application you want to use you can do that. However, I will create a new repo and clone it on my computer.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Note that you can follow this article regardless of your computer OS. It can be done with Windows, Linux or macOS.&lt;/p&gt;

&lt;p&gt;In creating this article, I used macOS, with Docker for Mac and Visual Studio Code.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/aspnet-core-docker-azure/github-new-repo.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Since this is a .NET Core application, I chose to add a &lt;code&gt;.gitignore&lt;/code&gt; file that will ignore all .NET specific output files after building the application.&lt;/p&gt;

&lt;p&gt;Create the repository, then clone it somewhere locally on your computer. In my case, I would execute &lt;code&gt;git clone https://github.com/radu-matei/aspnet-core-docker-azure&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;creating-the-asp-net-core-application&#34;&gt;Creating the ASP.NET Core application&lt;/h2&gt;

&lt;p&gt;This will be the part with the least focus in this article, since we have covered building ASP.NET Core applications for a while now and you can find a lot resources on this topic, including some on this site.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;For ASP.NET Core tutorials, you can &lt;a href=&#34;https://radu-matei.github.io/categories/aspnet-core/&#34;&gt;take a look at some resources on this blog&lt;/a&gt;, consult the &lt;a href=&#34;https://docs.microsoft.com/en-us/aspnet/core/&#34;&gt;official documentation&lt;/a&gt;, or you can watch this &lt;a href=&#34;https://mva.microsoft.com/en-US/training-courses/introduction-to-aspnet-core-10-16841&#34;&gt;Microsoft Virtual Academy course presented by Scott Hanselman and Maria Naggaga&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Basically, we will create the same application as explained in &lt;a href=&#34;https://radu-matei.github.io/blog/aspnet-core-startup/&#34;&gt;this blog post&lt;/a&gt;, but we will build it against .NET Core 1.0.1 (which is the latest stable version at the moment of writing this article).&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;While .NET Core 1.0.1 is the latest version at the moment of writing this article, you can also use other versions, since the Docker images are available on Docker Hub.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In the folder that was just created from cloning the repository, execute &lt;code&gt;dotnet new&lt;/code&gt; in order to create a new .NET Core application.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/aspnet-core-docker-azure/git-clone-dotnet.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Now depending on the .NET Core version you have installed on your machine, &lt;code&gt;project.json&lt;/code&gt; will look slightly different:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;Microsoft.NETCore.App&amp;quot;: {
  &amp;quot;type&amp;quot;: &amp;quot;platform&amp;quot;,
  &amp;quot;version&amp;quot;: &amp;quot;1.0.1&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since &lt;code&gt;1.0.1&lt;/code&gt; is the latest stable version, we will use it as example for this application.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;You can use any version available on your machine and as image from Microsoft on Docker Hub.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Add the required Kestrel dependency in &lt;code&gt;project.json&lt;/code&gt;, keeping in mind that the version is &lt;code&gt;1.0.1&lt;/code&gt; and respond to any incoming request with a message and the current date and time of the server:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public static void Main(string[] args)
        {
            var host = new WebHostBuilder()
                .UseKestrel()
                .Configure(app =&amp;gt; app.Run(context =&amp;gt; 
                {
                    return context.Response.WriteAsync($&amp;quot;Hello, Universe! It is {DateTime.Now}&amp;quot;);
                }))
                .Build();

            host.Run();
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And this is the entire ASP.NET Core application we will use for this article.&lt;/p&gt;

&lt;h2 id=&#34;writing-the-dockerfile&#34;&gt;Writing the Dockerfile&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Docker can build images automatically by reading the instructions from a Dockerfile. A Dockerfile is a text document that contains all the commands a user could call on the command line to assemble an image. Using docker build users can create an automated build that executes several command-line instructions in succession.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://docs.docker.com/engine/reference/builder/&#34;&gt;More information on the Dockerfile on the Official Docker Documentation&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Basically, the Dockerfile is like a recipe for building container images. It is a script composed of multiple commands executed succesively to create images based on other images.&lt;/p&gt;

&lt;p&gt;You have two options for writing the Dockerfile: you can write it manually, or you can have VS Code write it for you. If you &lt;a href=&#34;https://code.visualstudio.com/Docs/languages/dockerfile&#34;&gt;install the VS Code Docker extension&lt;/a&gt;, press F1 and search for Docker, you should see something similar to:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/aspnet-core-docker-azure/vscode-docker.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;In this case, we will write the Dockerfile manually, mainly because we want to understand all the things involved.&lt;/p&gt;

&lt;p&gt;Create a new file called &lt;code&gt;Dockerfile&lt;/code&gt; (without extension) to the root of the application (in this case in the same folder as &lt;code&gt;project.json&lt;/code&gt; and &lt;code&gt;Program.cs&lt;/code&gt;) with the following content:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;FROM microsoft/dotnet:1.0.1-sdk-projectjson

COPY . /app
WORKDIR /app

RUN [&amp;quot;dotnet&amp;quot;, &amp;quot;restore&amp;quot;]
RUN [&amp;quot;dotnet&amp;quot;, &amp;quot;build&amp;quot;]

EXPOSE 5000/tcp
ENV ASPNETCORE_URLS http://*:5000

ENTRYPOINT [&amp;quot;dotnet&amp;quot;, &amp;quot;run&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The content of the Dockerfile is pretty self-explanatory:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;it gets a base image that has &lt;code&gt;dotnet&lt;/code&gt; installed, the &lt;code&gt;microsoft/dotnet:1.0.1-sdk-projectjson&lt;/code&gt; image&lt;/li&gt;
&lt;li&gt;it copies the source of the application inside the container, in the &lt;code&gt;/app&lt;/code&gt; folder&lt;/li&gt;
&lt;li&gt;it sets the &lt;code&gt;/app&lt;/code&gt; folder as the working folder where the commands will be executed from&lt;/li&gt;
&lt;li&gt;executes &lt;code&gt;dotnet restore&lt;/code&gt; and &lt;code&gt;dotnet build&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;expoes the 5000 port&lt;/li&gt;
&lt;li&gt;sets the environment variable for ASP .NET Core in the container&lt;/li&gt;
&lt;li&gt;when the container starts it will execute the &lt;code&gt;dotnet run&lt;/code&gt; command&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;In this case, we both build and run the application inside the container. In a production environment, we would only use the &lt;code&gt;dotnet runtime&lt;/code&gt; image from Microsoft that is only able to execute applications and not build them. This would result in a much smaller footprint of the image.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;building-the-image&#34;&gt;Building the image&lt;/h2&gt;

&lt;p&gt;At this point, we have configured the application (which wasn&amp;rsquo;t that hard), we have a definition for Docker, our Dockerfile, but we haven&amp;rsquo;t built an image or a container so far.&lt;/p&gt;

&lt;p&gt;The end result is for us to start a container. Every container is built upon an image, that is composed of the application itself and its dependencies.&lt;/p&gt;

&lt;p&gt;To build the image, simply run the following command in the same folder with the Dockerfile:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;docker build -t aspnet-core-docker-azure&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/aspnet-core-docker-azure/docker-build-1.png&#34; alt=&#34;&#34; /&gt;
&lt;img src=&#34;https://radu-matei.com/img/article-photos/aspnet-core-docker-azure/docker-build-2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;You can clearly see how each step in the Dockerfile is executed succesively and how at every step an intermediate container gets created. This is done so that if the execution fails at let&amp;rsquo;s say STEP 7, all progress made up to that point doesn&amp;rsquo;t get lost. After every successful step executed, the previous container is removed.&lt;/p&gt;

&lt;p&gt;Running &lt;code&gt;docker images&lt;/code&gt; should show you the newly created image containing your application and its dependencies (among other images that you might have).&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/aspnet-core-docker-azure/docker-images.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Notice though that the base for our image also got pulled from Docker Hub - &lt;code&gt;microsoft/dotnet:1.0.1-sdk-projectjson&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;running-a-new-container&#34;&gt;Running a new container&lt;/h2&gt;

&lt;p&gt;Now that we built our image it&amp;rsquo;s time to run a new container based on that image.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;docker run -d -p 8080:5000 -t aspnet-core-docker-azure&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s examine the aruments passed along the &lt;code&gt;docker run&lt;/code&gt; command:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;-d&lt;/code&gt; - the container will run in &lt;code&gt;detached&lt;/code&gt; mode, so we won&amp;rsquo;t see logs from the container as output&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;-p 8080:5000&lt;/code&gt; - this will map the 5000 port inside the container (that the application is running on&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;remember the Dockerfile) to port 8080 from the host&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;-t&lt;/code&gt; - the tag of the image this container is based on&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This command started our container, so Docker must have executed &lt;code&gt;dotnet run&lt;/code&gt; inside the container (remember the last line in the Dockerfile), so the application should have started.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/aspnet-core-docker-azure/docker-run.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The output of this command is the id of the newly created container, so we can verify that the container is running using the &lt;code&gt;docker ps&lt;/code&gt; command:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/aspnet-core-docker-azure/docker-ps.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;We can see the id of the container, the image it is based on, the command used as entrypoint and the port mapping: 8080 on the host to 5000 inside the container.&lt;/p&gt;

&lt;p&gt;So if we navigate to &lt;code&gt;http://localhost:8080&lt;/code&gt; we should see our application running:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/aspnet-core-docker-azure/docker-run-browser.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;So far we created a very simple ASP .NET Core application and we ran it locally inside Docker.We  haven&amp;rsquo;t used the GitHub repo, Docker Hub, Docker Cloud or Azure just yet. This is where we start doing so.&lt;/p&gt;

&lt;h2 id=&#34;setup-an-azure-vm-as-node-for-docker-cloud&#34;&gt;Setup an Azure VM as node for Docker Cloud&lt;/h2&gt;

&lt;p&gt;While Docker Cloud allows you to run containers and build images on some free tier servers, you would most likely want to do it on your own machine.&lt;/p&gt;

&lt;p&gt;If you link the Docker Cloud account with your cloud subscription (in this case Azure), you can create nodes and clusters directly from the Docker Cloud portal.&lt;/p&gt;

&lt;p&gt;In this case we will normally create a VM from the Azure Portal (or from any other cloud provider or on-premise) and install the Docker Cloud agent.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/aspnet-core-docker-azure/docker-cloud-bring-node.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;I created an Ubuntu Server 14.04 VM (at the moment of writing this article, only Ubuntu 14.04 and 15.04 are supported by Docker Cloud).&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/aspnet-core-docker-azure/azure-create-vm-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;After the deployment succeeds, we will need to open some ports on that VM so the Docker Cloud self discovery service can work. &lt;a href=&#34;https://docs.microsoft.com/en-us/azure/virtual-machines/virtual-machines-windows-nsg-quickstart-portal&#34;&gt;In this article you can see the detalied process on how to open ports for Azure VMs.&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;We recommend you open incoming port 2375 in your firewall for Docker Cloud to communicate with the Docker daemon running in the node. For the overlay network to work, you must open port 6783/tcp and 6783/udp.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;You have to find the &lt;code&gt;Network Security Group&lt;/code&gt; tab from the VM settings, then the &lt;code&gt;Network Security Group&lt;/code&gt; tab then the &lt;code&gt;Inbound Security Roules&lt;/code&gt; tab.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/aspnet-core-docker-azure/azure-network-security.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;As the Docker Cloud documentation states, we should open ports 2375 and 6783/tcp and udp.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/aspnet-core-docker-azure/docker-2375.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Then do the same for 6783/tcp and 6783/udp, and since this VM will host the running container, I will also open a port for HTTP - which will automatically open port 80.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If you plan to run multiple containers at the same time that expose ports on this machine, you should open more ports to be accessible from outside the VM.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I will also setup a DNS name for the VM so that I don&amp;rsquo;t have to remember the IP of the machine:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/aspnet-core-docker-azure/azure-vm-dns.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;At this point, you should be able to SSH into the machine and install the Docker Cloud agent.&lt;/p&gt;

&lt;p&gt;On macOS, Linux or Bash on Windows, to SSH into a machine:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ssh user-name@your-machine-dns-or-ip&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;In my case, I would run
 &lt;code&gt;ssh radu-matei@ubuntu-docker-cloud.westeurope.cloudapp.azure.com&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/aspnet-core-docker-azure/azure-vm-ssh.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;After this, I could just paste the command that installs the Docker Cloud agent:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;curl -Ls https://get.cloud.docker.com/ | sudo -H sh -s your-unique-hash&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;You might still see some Tutum references in the scripts, as this was the name of the company acquired by Docker that initially developed the functionality behind Docker Cloud.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;After the command above successfully executed and you refreshed your Docker Cloud tab, you should see your newly created node.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/aspnet-core-docker-azure/docker-node.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;This is all the required setup for a VM to be a Docker Cloud node.&lt;/p&gt;

&lt;h2 id=&#34;creating-a-repository-in-docker-cloud&#34;&gt;Creating a repository in Docker Cloud&lt;/h2&gt;

&lt;p&gt;By now, the GitHub repository with the application should be up to date, since we will use it to create a new Docker Cloud repository that will automatically build images on every git push in the GitHub repo.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/aspnet-core-docker-azure/docker-create-repo.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;By default, the webhook will be setup for the master branch on every push, but you can also set it up for specific events, like certain releases.&lt;/p&gt;

&lt;p&gt;By default, the newly created image will be public, but you can make it private. Note that you have a limited number of private repositories in the free tier.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/aspnet-core-docker-azure/docker-repo-info.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;After it was created and Docker Cloud successfully tested the connection with GitHub, we should set the build process so that it uses the node we just provided and not the shared one provided by Docker Cloud:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/aspnet-core-docker-azure/docker-repo-build.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If you configured automated notifications on Slack, every time there is an event related to the service you are creating, you will have notifications on Slack.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/aspnet-core-docker-azure/slack-notifications.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;After you click &lt;code&gt;Save and Build&lt;/code&gt; the image building will start on the machine you provided.&lt;/p&gt;

&lt;p&gt;At any time you can see the logs from building the image in the &lt;code&gt;Builds&lt;/code&gt; tab.
&lt;img src=&#34;https://radu-matei.com/img/article-photos/aspnet-core-docker-azure/build-logs.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Now if you go to Docker Hub you should see your newly created image.&lt;/p&gt;

&lt;h2 id=&#34;creating-a-service-based-on-the-image-we-created&#34;&gt;Creating a service based on the image we created&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;A service is a group of containers of the same image:tag. Services make it simple to scale your application. With Docker Cloud, you simply drag a slider to change the number of containers in a service.&lt;/p&gt;

&lt;p&gt;Before you can deploy a service in Docker Cloud, you must have at least one node deployed. If you havent done this yet follow the tutorial to deploy a node .&lt;/p&gt;

&lt;p&gt;When you create a service in the Docker Cloud web interface, a wizard walks you through configuring the service in three steps.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Choose a Container Image Images can come from Docker Clouds Jumpstarts library, your personal Docker Hub account or Docker Hubs public index, or from third party registries you connect.&lt;/li&gt;
&lt;li&gt;Configure the Service From here, give the service a name, set the initial number of containers, expose/publish ports, modify the run command or entrypoint, set memory and CPU limits.&lt;/li&gt;
&lt;li&gt;Set Environment variables Set the edit environment variables and link your service to other existing services in Docker Cloud.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;More on Docker Cloud services on &lt;a href=&#34;https://docs.docker.com/docker-cloud/getting-started/your_first_service/&#34;&gt;the Official Docker Documentation&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;We will create a service based on the image we just created.&lt;/p&gt;

&lt;p&gt;The only custom settings will be to enable the &lt;code&gt;AUTOREDEPLOY&lt;/code&gt; option and to specify the port to be 80 on the machine.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/aspnet-core-docker-azure/autoredeploy.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/aspnet-core-docker-azure/port.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;After hitting the create, it will create the service and already start a container based on this service.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/aspnet-core-docker-azure/service-starting.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;If we go to the containers tab, we can see the container running.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/aspnet-core-docker-azure/containers.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;testing-the-application&#34;&gt;Testing the application&lt;/h2&gt;

&lt;p&gt;Remember the DNS we assigned to the Azure VM? In my case it was &lt;code&gt;http://ubuntu-docker-cloud.westeurope.cloudapp.azure.com/&lt;/code&gt;. Normally, the container should have started on port 80 (the default HTTP port) on this machine.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s try and access that exact URL:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/aspnet-core-docker-azure/public-app.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;At this point, you can create additional service and start containers on this machine, provided you open ports on the VM with the procedure described above.&lt;/p&gt;

&lt;h2 id=&#34;updating-the-application&#34;&gt;Updating the application&lt;/h2&gt;

&lt;p&gt;Because we setup the image based on the GitHub repository and we checked the &lt;code&gt;AUTOREDEPLOY&lt;/code&gt; option, every time we will push on the master branch of the repository, the entire system will update itself.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s slightly modify the application and push the modifications. This should trigger the auto build and auto redeploy of the container and without us doing anything, the modifications should be live.&lt;/p&gt;

&lt;p&gt;I just changed the message the application responds with and pushed the modifications to the master branch. This should trigger the build and redeploy of the container.&lt;/p&gt;

&lt;p&gt;You should see the new build in the &lt;code&gt;Recent Builds&lt;/code&gt; tab from the &lt;code&gt;Repositories&lt;/code&gt; page:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/aspnet-core-docker-azure/recent-builds.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;You can also see all events in Slack:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/aspnet-core-docker-azure/slack-build-events.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;After the build and redeploy are successful, accessing the application should reflect the modifications:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/aspnet-core-docker-azure/public-app-updated.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;This is basically how the entire process looks like. It is not production ready, as it does not have any testing workflow put in place and the application is rather simple.&lt;/p&gt;

&lt;p&gt;Real world scenarions would most certainly involve more containers, so composing and orchestrating containers, as well as testing.&lt;/p&gt;

&lt;p&gt;We will try to deal with these aspects in future articles, but for now we created a very simple CI/CD workflow using GitHub, Docker Cloud and an Azure VM.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Get started with Raspberry Pi3, Sense HAT and Azure IoT Suite</title>
      <link>https://radu-matei.com/blog/rpi-sensehat-telemetry/</link>
      <pubDate>Mon, 10 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>https://radu-matei.com/blog/rpi-sensehat-telemetry/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;You can check &lt;a href=&#34;https://github.com/radu-matei/rpi-sensehat-cloud-telemetry&#34;&gt;the GitHub repository of this project for the full source code&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;In this blog post, we will get started with the &lt;a href=&#34;https://www.raspberrypi.org/products/raspberry-pi-3-model-b/&#34;&gt;Raspberry Pi3&lt;/a&gt;, the &lt;a href=&#34;https://www.raspberrypi.org/products/sense-hat/&#34;&gt;Sense HAT&lt;/a&gt; and Azure IoT Suite.
More specifically, from the IoT Suite we will use IoT Hub, and Stream Analytics, which we will detail a little later.&lt;/p&gt;

&lt;p&gt;The end goal of this little project is to acquire data from the sensors, upload the data to IoT Hub, which feeds it into Stream Analytics, with outputs to an Azure SQL database (for storage) and to Service Bus (for consuming the data in real-time from various applications).&lt;/p&gt;

&lt;h2 id=&#34;what-is-sense-hat&#34;&gt;What is Sense HAT?&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;The Sense HAT is an add-on board for Raspberry Pi, made espacially for the &lt;a href=&#34;https://astro-pi.org/&#34;&gt;Astro Pi&lt;/a&gt; mission to go in Space.
The Sense HAT has an 8x8 RGB LED matrix, a five-button joystick and includes the following sensors:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Gyroscope&lt;/li&gt;
&lt;li&gt;Accelerometer&lt;/li&gt;
&lt;li&gt;Magnetometer&lt;/li&gt;
&lt;li&gt;Barometric pressure sensor&lt;/li&gt;
&lt;li&gt;Humidity sensors&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;https://www.raspberrypi.org/wp-content/uploads/2015/06/astro-pi-hat.png&#34; alt=&#34;Sense HAT&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The Sense HAT - image from &lt;a href=&#34;https://www.raspberrypi.org/products/sense-hat/&#34;&gt;the official Raspberry Pi website&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Basically, the Sense HAT is a board that has integrated sensors and a joystick, with an additional 8x8 LED matrix. It is a very fun board to play with and I recommend it if you don&amp;rsquo;t want (or know, for that matter) to get tangled in wires and in calculating resistances.&lt;/p&gt;

&lt;h2 id=&#34;assembling-the-two-boards&#34;&gt;Assembling the two boards&lt;/h2&gt;

&lt;p&gt;In order to get started, firstly we need to assemble the HAT on the Pi.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/raspberrypilearning/astro-pi-guide/3ca15fd5e2a44121f0ac9bbcaf64f3c2f0b51a54/images/sense-hat-assembly.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Image from &lt;a href=&#34;https://www.raspberrypi.org/learning/astro-pi-guide/assemble.md&#34;&gt;the official Raspberry Pi website&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;After carefully assembling the two boards (watching not to bend the pins of either boards) and putting the screws and the hexagonal stand-offs in place, you are ready to go. If successful, the end result should look similar to this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/rpi-sensehat-telemetry/rpi-sensehat-assembly.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;You can &lt;a href=&#34;https://developer.microsoft.com/en-us/windows/iot/docs/kitsetuprpi&#34;&gt;follow the instructions here to install Windows IoT Core on your Raspberry Pi&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Assuming you assembled the board and installed Windows on your Raspberry, we are ready to get started.&lt;/p&gt;

&lt;h2 id=&#34;creating-a-windows-universal-app-that-will-run-on-the-raspberry&#34;&gt;Creating a Windows Universal App that will run on the Raspberry&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;At this moment there is no official .NET library to work with the Sense HAT. There is an official Python library and you &lt;a href=&#34;http://pythonhosted.org/sense-hat/&#34;&gt;can get started with it here.&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;While there is no official .NET library, there is a library developed by &lt;a href=&#34;http://www.laserbrain.se/&#34;&gt;Mattias Larsson&lt;/a&gt; which provides exactly the functionality we need. You can &lt;a href=&#34;https://github.com/emmellsoft&#34;&gt;find the source code on GitHub&lt;/a&gt; and &lt;a href=&#34;https://www.nuget.org/packages/Emmellsoft.IoT.RPi.SenseHat/&#34;&gt;the package on NuGet&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;If you are a complete beginner with Windows IoT Core and the Raspberry Pi3, I strongly recommend you go through this step-by-step tutorial on how to get started with the installing, configuring and writing your first app on the Raspberry Pi3 with Windows IoT Core:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.microsoft.com/en-us/windows/iot/Docs/GetStarted/rpi3/sdcard/stable/GetStartedStep1.htm&#34;&gt;Step 1 of 4: Get the Tools&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.microsoft.com/en-us/windows/iot/Docs/GetStarted/rpi3/sdcard/stable/getstartedstep2&#34;&gt;Step 2 of 4: Set up your device&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.microsoft.com/en-us/windows/iot/Docs/GetStarted/rpi3/sdcard/stable/getstartedstep3&#34;&gt;Step 3 of 4: Set up Visual Studio&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.microsoft.com/en-us/windows/iot/Docs/GetStarted/rpi3/sdcard/stable/getstartedstep4&#34;&gt;Step 4 of 4: Write your first app&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;After this, you can find multiple examples with various hardware components and software services, from the &lt;a href=&#34;https://developer.microsoft.com/en-us/windows/iot&#34;&gt;Windows IoT developer website&lt;/a&gt; or from &lt;a href=&#34;http://microsoft.hackster.io&#34;&gt;Hackster&lt;/a&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://msdn.microsoft.com/en-us/windows/uwp/get-started/create-a-hello-world-app-xaml-universal&#34;&gt;Here you can find a very brief introduction to creating UWP apps and a Hello, World example.&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;creating-the-app-architecture&#34;&gt;Creating the app architecture&lt;/h2&gt;

&lt;p&gt;At this point, we can choose between two approaches:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;have the entire logic (including the communication with the Sense HAT and the cloud) in the UWP application&lt;/li&gt;
&lt;li&gt;create separate (and reusable) class library projects that can be referenced from the UWP application&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For this project, we will go with the second approach (and you can already &lt;a href=&#34;https://github.com/radu-matei/rpi-sensehat-cloud-telemetry&#34;&gt;review the source code on GitHub&lt;/a&gt;).&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;In this case, I went with the following naming conventions for the solution and the projects:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;the name of the solution: &lt;code&gt;RPiSenseHatTelemetry&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;the name of various projects: &lt;code&gt;RPiSenseHatTelemetry.SpecificProjectFunctionality&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;To get started, open Visual Studio and create a new Universal Windows app for Windows 10. There is nothing specific for Raspberry Pi or Sense HAT yet, just a typical UWP app. (In my case, the naming was: &lt;code&gt;RPiSenseHatTelemetry.Uwp&lt;/code&gt;).&lt;/p&gt;

&lt;h2 id=&#34;the-telemetry-collected-and-analyzed&#34;&gt;The telemetry collected and analyzed&lt;/h2&gt;

&lt;p&gt;In this very simple example, we will only get the temperature telemetry, with the Celsius value and the timestamp of the measurement.
Since we plan on taking more telemetry than temperature (and use these classes in other projects), we will create a project called &lt;code&gt;RPiSenseHatTelemetry.Common&lt;/code&gt; that we will reference later.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public class TemperatureTelemetry
    {
        public string Time { get; set; }

        public double Temperature { get; set; }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;the-sense-hat-communication-project&#34;&gt;The Sense HAT Communication Project&lt;/h2&gt;

&lt;p&gt;Right now, we need to have specific functionality for communicating with the Sense HAT. In a new class library project (in this case called: &lt;code&gt;RPiSenseHatTelemetry.SenseHatCommunication&lt;/code&gt;), add the NuGet package for the Sense HAT: &lt;code&gt;Install-Package Emmellsoft.IoT.RPi.SenseHat&lt;/code&gt;. This will add a bunch of files and folders to your project (mainly for demo and testing purposes) that we will not use, all we need is the reference to the &lt;code&gt;Emmellsoft.IoT.RPi.SenseHat&lt;/code&gt; dll.&lt;/p&gt;

&lt;p&gt;The main thing that we will use from this library is exposed through the &lt;code&gt;ISenseHat&lt;/code&gt; interface, which you can find in &lt;a href=&#34;https://github.com/emmellsoft/RPi.SenseHat/blob/master/RPi.SenseHat/Rpi.SenseHat/ISenseHat.cs&#34;&gt;the library&amp;rsquo;s GitHub repository&lt;/a&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The best place to learn how to use this library is &lt;a href=&#34;https://github.com/emmellsoft/RPi.SenseHat/tree/master/RPi.SenseHat/RPi.SenseHat.Demo/Demos&#34;&gt;the demo section of the repository&lt;/a&gt;. There you can find how to create a compass, how to make disco lights from the 8x8 LED matrix or write the temperature on the LED matrix.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;We will create a new class that will only expose funtionality related with the temperature telemetry, but you can expand this class to do all the things you want.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;using System;
using System.Threading;
using System.Threading.Tasks;
using Emmellsoft.IoT.Rpi.SenseHat;
using RPiSenseHatTelemetry.Common;

    public class SenseHat : IDisposable
    {
        private ISenseHat _senseHat { get; set; }

        public async Task Activate()
        {
            _senseHat = await SenseHatFactory.GetSenseHat().ConfigureAwait(false);

            _senseHat.Display.Clear();
            _senseHat.Display.Update();
        }

        public TemperatureTelemetry GetTemperature()
        {
            while (true)
            {
                _senseHat.Sensors.HumiditySensor.Update();

                if (_senseHat.Sensors.Temperature.HasValue)
                {
                    return new TemperatureTelemetry()
                    {
                        Time = DateTime.UtcNow.AddHours(3).ToString(&amp;quot;yyyy-MM-dd HH:mm:ss.fff&amp;quot;),
                        Temperature = Math.Round(_senseHat.Sensors.Temperature.Value, 2)
                    };
                }

                else new ManualResetEventSlim(false).Wait(TimeSpan.FromSeconds(0.5));
            }
        }

        public void Dispose()
        {
            _senseHat.Dispose();
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We will obtain the actual object that does the communication with the board through &lt;code&gt;SenseHatFactory&lt;/code&gt; and we will use this object throughout our class.
In the &lt;code&gt;Activate&lt;/code&gt; method, we get the reference to the &lt;code&gt;ISenseHat&lt;/code&gt; object through the factory, then we turn off the LED matrix (since we don&amp;rsquo;t want to have it on at all times when it&amp;rsquo;s running).&lt;/p&gt;

&lt;p&gt;We also have a &lt;code&gt;Dispose&lt;/code&gt; method, since the &lt;code&gt;_senseHat&lt;/code&gt; is disposable.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;GetTemperature&lt;/code&gt; method is pretty straightforward: we check if the temperature sensor has value. If it does, we create a new &lt;code&gt;TemperatureTelemetry&lt;/code&gt; object with the corresponding timestamp and temperature that we return. If the sensor doesn&amp;rsquo;t have a value, we wait half a second and try again.&lt;/p&gt;

&lt;p&gt;This is the entire code that deals with the Sense HAT.&lt;/p&gt;

&lt;h2 id=&#34;displaying-the-temperature-in-the-uwp-app&#34;&gt;Displaying the temperature in the UWP app&lt;/h2&gt;

&lt;p&gt;In the &lt;code&gt;MainPage&lt;/code&gt; of the UWP app, we need to have a &lt;code&gt;SenseHat&lt;/code&gt; property in order to get the temperature once every three seconds, that we then display.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public sealed partial class MainPage : Page
    {
        private SenseHat _senseHat { get; set; }

        public MainPage()
        {
            this.InitializeComponent();

            _senseHat = new SenseHat();
            this.ActivateSenseHat();

            this.Loaded += (sender, e) =&amp;gt;
            {
                DispatcherTimer timer = new DispatcherTimer();

                timer.Tick += async (x, y) =&amp;gt;
                {
                    var temperatureTelemetry = _senseHat.GetTemperature();
                    this.temperatureTextBlock.Text = &amp;quot;Temperature: &amp;quot; + 
                                                      temperatureTelemetry.Temperature.ToString() + 
                                                      &amp;quot;at &amp;quot; + 
                                                      temperatureTelemetry.Time;
                };

                timer.Interval = TimeSpan.FromSeconds(3);
                timer.Start();
            };
        }

        private async void ActivateSenseHat()
        {
           await _senseHat.Activate();
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After the page has loaded, we use a &lt;code&gt;DispatcherTimer&lt;/code&gt; object and every 3 seconds we get a new value from the sensors and display it in the UWP app.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Later, in the same place as we displayed in the app, we will send the data to IoT Hub and we will write the value on the HAT LED matrix.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;communicating-with-the-cloud-azure-iot-hub&#34;&gt;Communicating with the Cloud - Azure IoT Hub&lt;/h2&gt;

&lt;p&gt;First of all, we need to create an Azure IoT Hub. To do this, simply &lt;a href=&#34;https://azure.microsoft.com/en-gb/documentation/articles/iot-hub-csharp-csharp-getstarted/#create-an-iot-hub&#34;&gt;follow the instructions here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/rpi-sensehat-telemetry/iot-hub.JPG&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;At this point, you can &lt;a href=&#34;https://github.com/Azure/azure-iot-sdks/blob/master/tools/DeviceExplorer/doc/how_to_use_device_explorer.md&#34;&gt;start using the Device Explorer&lt;/a&gt; - a small application that you can use to see the IoT Hubs from Azure and their connected devices.
From here, you can add devices that are authorized to send data to the IoT Hub and see the messages that arrive on the IoT Hub in real-time, while also having the ability to send messages to the device.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/rpi-sensehat-telemetry/device-explorer.JPG&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;In this case, I created a device called &lt;code&gt;RPi.SenseHat&lt;/code&gt; that sends the temperature telemetry to the hub.&lt;/p&gt;

&lt;p&gt;To communicate with the cloud, I created a separate project - &lt;code&gt;RPiSenseHatTelemetry.CloudCommunication&lt;/code&gt;, where I created a class called &lt;code&gt;IoTHubCommunication&lt;/code&gt; that deals with sending a receiving messages from the cloud.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;using System;
using System.Text;
using System.Threading.Tasks;
using Microsoft.Azure.Devices.Client;

    public class IoTHubConnection : IDisposable
    {
        private DeviceClient _deviceClient { get; set; }

        public IoTHubConnection()
        {
            _deviceClient = DeviceClient.CreateFromConnectionString(GetConnectionString(), TransportType.Amqp);
        }

        public async Task SendEventAsync(string payload)
        {
            await _deviceClient.SendEventAsync(new Message(Encoding.ASCII.GetBytes(payload)));
        }

        public async Task&amp;lt;string&amp;gt; ReceiveEventAsync()
        {
            while (true)
            {
                var receivedMessage = await _deviceClient.ReceiveAsync();

                if (receivedMessage != null)
                {
                    var messageData = Encoding.ASCII.GetString(receivedMessage.GetBytes());
                    await _deviceClient.CompleteAsync(receivedMessage);
                    return messageData;
                }
                await Task.Delay(TimeSpan.FromSeconds(1));
            }
        }


        private string GetConnectionString()
        {
            return &amp;quot;your-connection-string&amp;quot;;
        }

        public void Dispose()
        {
            _deviceClient.Dispose();
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Basically, the methods we will use are &lt;code&gt;SendEventAsync&lt;/code&gt;, which sends an event asynchronously and &lt;code&gt;ReceiveEventAsync&lt;/code&gt; which receives and event asynchronously.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;You can also use a VS extension to add a class that makes the communication with an IoT Hub you select. &lt;a href=&#34;https://blogs.windows.com/buildingapps/2016/03/03/connect-your-windows-app-to-azure-iot-hub-with-visual-studio/#ULITBWxjbHHrwkSo.97&#34;&gt;Here you can find a tutorial on how to start publising events from a UWP app with Azure IoT Hub&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;adding-cloud-communication-to-the-uwp-app&#34;&gt;Adding cloud communication to the UWP app&lt;/h2&gt;

&lt;p&gt;To add the cloud communication to the UWP app, simply create a new instance of our newly created class, &lt;code&gt;IoTHubConnection&lt;/code&gt; and use the &lt;code&gt;SendEventAsync&lt;/code&gt; method in the &lt;code&gt;MainPage.xaml.cs&lt;/code&gt; file.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    timer.Tick += async (x, y) =&amp;gt;
    {
        var temperatureTelemetry = _senseHat.GetTemperature();
        this.temperatureTextBlock.Text = &amp;quot;Temperature: &amp;quot; + 
                                            temperatureTelemetry.Temperature.ToString() + 
                                            &amp;quot;at &amp;quot; + 
                                            temperatureTelemetry.Time;

        await _iotHubConnection.SendEventAsync(JsonConvert.SerializeObject(temperatureTelemetry));
    };
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;sending-the-data-from-iot-hub-to-stream-analytics&#34;&gt;Sending the data from IoT Hub to Stream Analytics&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;You can &lt;a href=&#34;https://azure.microsoft.com/en-us/documentation/articles/stream-analytics-introduction/&#34;&gt;get started on what is Stream Analytics here&lt;/a&gt;.
This is an &lt;a href=&#34;https://azure.microsoft.com/en-us/documentation/articles/stream-analytics-build-an-iot-solution-using-stream-analytics/&#34;&gt;introduction on building IoT solutions with Stream Analytics&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Right now we have data going from the Raspberry Pi to the IoT Hub, but nothing more happens with that data. At first, we will send the data to an Azure SQL database.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This is a &lt;a href=&#34;https://azure.microsoft.com/en-us/documentation/articles/sql-database-get-started/&#34;&gt;step-by-step tutorial on how to create an Azure SQL database.&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;After creating the Stream Analytics service in Azure, we need to add input data, in this case from the IoT Hub:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/rpi-sensehat-telemetry/stream-analytics-input.JPG&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;We also need to configure an output, an Azure SQL database:
&lt;img src=&#34;https://radu-matei.com/img/article-photos/rpi-sensehat-telemetry/stream-analytics-output.JPG&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Notice how we also need to configure a table for our data to be stored. This table should have the same structure as our &lt;code&gt;TemperatureTelemetry&lt;/code&gt; objects that we send.&lt;/p&gt;

&lt;p&gt;This is the script I used for creating the table for the temperature telemetry:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CREATE TABLE [dbo].[TemperatureTelemetry] (
    [Time]        DATETIME   NULL,
    [Temperature] FLOAT (53) NOT NULL
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At this point, we need a Stream Analytics query that takes the data from IoT Hub and puts it into our SQL database:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SELECT
    Time, Temperature
INTO
    [sql-database-output]
FROM
    [rpi-sensehat-iot-hub-input]
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;The names &lt;code&gt;sql-database-output&lt;/code&gt; and &lt;code&gt;rpi-sensehat-iot-hub-input&lt;/code&gt; are the names I gave the SQL database as output and the IoT Hub as input, respectively.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;testing-and-running-the-application&#34;&gt;Testing and running the application&lt;/h2&gt;

&lt;p&gt;Right now, we can run the application remotely from Visual Studio to our Raspberry Pi by finding the IP in the IoT Dashboard application:
&lt;img src=&#34;https://radu-matei.com/img/article-photos/rpi-sensehat-telemetry/iot-dashboard.JPG&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;We can also connect from our browser through the device portal:
&lt;img src=&#34;https://radu-matei.com/img/article-photos/rpi-sensehat-telemetry/device-portal.JPG&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;We can also create a remote desktop connection to our Raspberry:
&lt;img src=&#34;https://radu-matei.com/img/article-photos/rpi-sensehat-telemetry/remote-client.JPG&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;From Visual Studio, we deploy our application to a remote device:
&lt;img src=&#34;https://radu-matei.com/img/article-photos/rpi-sensehat-telemetry/set-remote.JPG&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;After the application is successfully deployed, we will see data coming into the IoT Hub through the Device Explorer, and also in the SQL database we created as output for the Stream Analytics job.&lt;/p&gt;

&lt;p&gt;And here is the data that arrives in the SQL database:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/rpi-sensehat-telemetry/powershell-telemetry.JPG&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The query above is made through PowerShell, through a custom script I made for querying and making commands to a SQL database without the SQL Server Management Studio.
You can &lt;a href=&#34;https://github.com/radu-matei/excel-to-web-sql/blob/master/src/PowerShell%20Scripts/Execute-SqlStatement.ps1&#34;&gt;find the script here with demo usage&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;next-steps&#34;&gt;Next steps&lt;/h2&gt;

&lt;p&gt;In a following article, we will configure an additional output for the Stream Analytics job, a Service Bus that will allow us to use the messages real-time in a web (or even mobile) application, with custom alerts. We will also create a command from the IoT Hub based on an alert from the Stream Analytics job that will turn on or off the LED matrix (and will even control an Arduino connected through USB). We will also write the current temperature on the LED matrix.&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;We created a very simple UWP app that takes data from the Sense HAT sensors, displays it on the screen, then sends it through Azure IoT Hub, then to a Stream Analytics job that outputs it into an Azure SQL database.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ASP.NET Core MVC and SignalR Core</title>
      <link>https://radu-matei.com/blog/aspnet-core-mvc-signalr/</link>
      <pubDate>Fri, 09 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://radu-matei.com/blog/aspnet-core-mvc-signalr/</guid>
      <description>

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;In this article we will take a look at how to integrate ASP.NET Core MVC with SignalR Core (at the moment of writing this article, the latest version of SignalR is &lt;a href=&#34;https://dotnet.myget.org/feed/aspnetcore-ci-dev/package/nuget/Microsoft.AspNetCore.SignalR.Server&#34;&gt;&lt;code&gt;0.2.0-alpha1-22107&lt;/code&gt;&lt;/a&gt;) and how to use the SignalR context outside hubs (and solve the current issues with the custom resolvers that will be detailed later) to update clients.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This article assumes a basic understanding of ASP.NET Core MVC and will not try to explain all concepts here. &lt;a href=&#34;https://radu-matei.github.io/blog/aspnet-core-api/&#34;&gt;This article&lt;/a&gt; does an introduction to ASP.NET Core MVC and has the basic application structure needed for this article.&lt;/p&gt;

&lt;p&gt;In order to get started with SignalR Core, &lt;a href=&#34;https://radu-matei.github.io/blog/signalr-core/&#34;&gt;take a look at this article&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;We will build on &lt;a href=&#34;https://radu-matei.github.io/blog/aspnet-core-api/&#34;&gt;this application&lt;/a&gt; and add real time functionality to it.&lt;/p&gt;

&lt;p&gt;It is a very simple application that will enable the creation of posts (much like messages) and it took us through adding the MVC services, creating models, controllers and consuming some data. Now, we want all connected users to see in real time when somebody adds posts in the page without refreshing it.&lt;/p&gt;

&lt;h2 id=&#34;configure-the-application&#34;&gt;Configure the application&lt;/h2&gt;

&lt;p&gt;NuGet has the ability to get packages from more than one source, and we need it to download alpha packages that are only available on the MyGet server of the ASP.NET team, besides the ASP.NET Core packages available on NuGet. So in the root of the application add a file called &lt;code&gt;NuGet.Config&lt;/code&gt; with the following content:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;
&amp;lt;configuration&amp;gt;
    &amp;lt;packageSources&amp;gt;
        &amp;lt;clear/&amp;gt;
            &amp;lt;add key=&amp;quot;aspnetcidev&amp;quot; value=&amp;quot;https://dotnet.myget.org/F/aspnetcore-ci-dev/api/v3/index.json&amp;quot;/&amp;gt;
            &amp;lt;add key=&amp;quot;api.nuget.org&amp;quot; value=&amp;quot;https://api.nuget.org/v3/index.json&amp;quot;/&amp;gt;
    &amp;lt;/packageSources&amp;gt;
&amp;lt;/configuration&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;add-the-required-packages&#34;&gt;Add the required packages&lt;/h2&gt;

&lt;p&gt;For this application, we will need the Kestrel web server (of course), the MVC packages so we can use controllers, static files so we can have HTML and JavaScript files served, SignalR and WebSockets:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;Microsoft.AspNetCore.Server.Kestrel&amp;quot;: &amp;quot;1.0.0&amp;quot;,
&amp;quot;Microsoft.AspNetCore.Mvc&amp;quot;: &amp;quot;1.0.0&amp;quot;,
&amp;quot;Microsoft.AspNetCore.StaticFiles&amp;quot;: &amp;quot;1.0.0&amp;quot;,
&amp;quot;Microsoft.AspNetCore.SignalR.Server&amp;quot;: &amp;quot;0.2.0-*&amp;quot;,
&amp;quot;Microsoft.AspNetCore.WebSockets&amp;quot;: &amp;quot;0.2.0-*&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;program-cs&#34;&gt;&lt;code&gt;Program.cs&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;Besides adding the &lt;code&gt;UseContentRoot&lt;/code&gt; statement, the &lt;code&gt;Main&lt;/code&gt; method is pretty much standard for an ASP.NET Core application.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; public static void Main(string[] args)
 {
     var host = new WebHostBuilder()
         .UseKestrel()
         .UseContentRoot(Directory.GetCurrentDirectory())
         .UseStartup&amp;lt;Startup&amp;gt;()
         .Build();

     host.Run();
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;post-ipostrepository-and-postrepository&#34;&gt;&lt;code&gt;Post&lt;/code&gt;, &lt;code&gt;IPostRepository&lt;/code&gt; and &lt;code&gt;PostRepository&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://radu-matei.github.io/blog/aspnet-core-api/&#34;&gt;This article&lt;/a&gt; explains all these components thoroughly, but let&amp;rsquo;s see briefly what each one does:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Post
{
    public int Id { get; set; }
    public string UserName { get; set; }
    public string Text { get; set; }

    public Post(int id, string userName, string text)
    {
        Id = id;
        UserName = userName;
        Text = text;
    }

    public Post()
    {
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Post&lt;/code&gt; will be the model that users add in the application. It is a straightforward C# class with three auto-implemented properties and two constructors.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Each user that enters can publish a post containing his user name and a text, so our Post class only contains two properties for the UserName and Text of the post and an Id.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;using System.Collections.Generic;

public interface IPostRepository
{
    List&amp;lt;Post&amp;gt; GetAll();
    Post GetPost(int id);
    void AddPost(Post post);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Regardless of where that data is going to be stored, there should be a consistent way of reading and writing, and we will achieve this through an interface, IPostRepository, that will expose the minimum necessary methods: a method to read all posts, a method to add a post and a method to retrieve a post with a specified id.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;using System.Collections.Generic;
using System.Linq;

public class PostRepository : IPostRepository
{
    private List&amp;lt;Post&amp;gt; _posts = new List&amp;lt;Post&amp;gt;()
    {
        new Post(1, &amp;quot;Obi-Wan Kenobi&amp;quot;,&amp;quot;These are not the droids you&#39;re looking for&amp;quot;),
        new Post(2, &amp;quot;Darth Vader&amp;quot;,&amp;quot;I find your lack of faith disturbing&amp;quot;)
    };
    public void AddPost(Post post)
    {
        _posts.Add(post);
    }

    public List&amp;lt;Post&amp;gt; GetAll()
    {
        return _posts;
    }

    public Post GetPost(int id)
    {
        return _posts.FirstOrDefault(p =&amp;gt; p.Id == id);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;We implemented the &lt;code&gt;IPostRepository&lt;/code&gt; interface through an in-memory class called &lt;code&gt;PostRepository&lt;/code&gt; that holds the data in a list. Since we have the three methods to access the data, there is no need to expose the post list outside the class, so it is be private. Besides the list, we only need to implement the three methods from the interface.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;the-postscontroller&#34;&gt;The &lt;code&gt;PostsController&lt;/code&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;using System.Collections.Generic;
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.SignalR.Infrastructure;

public class PostsController : Controller
{
    private IPostRepository _postRepository { get; set; }

    public PostsController(IPostRepository postRepository)
    {
        _postRepository = postRepository;
    }

    [HttpGet]
    public List&amp;lt;Post&amp;gt; GetPosts()
    {
        return _postRepository.GetAll();
    }

    [HttpGet]
    public Post GetPost(int id)
    {
        return _postRepository.GetPost(id);
    }

    [HttpPost]
    public void AddPost(Post post)
    {
        _postRepository.AddPost(post);
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From this controller, we will update all clients when a post was added using SignalR by getting the context of the hub and calling client methods  using a &lt;code&gt;ConnectionManager&lt;/code&gt;. We will see later how to achieve this.&lt;/p&gt;

&lt;h2 id=&#34;add-a-hub&#34;&gt;Add a hub&lt;/h2&gt;

&lt;p&gt;In this application, we will use the hub as a proxy: clients will not call hub methods directly. SignalR will be used to provide server updates - that is the server notifies all clients that something happened, so the clients must first connect to a hub.&lt;/p&gt;

&lt;p&gt;So the hub class will be incredibly simple:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;using Microsoft.AspNetCore.SignalR;

public class PostsHub : Hub
{
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We will see how to use the hub context outside of the hub a little later.&lt;/p&gt;

&lt;h2 id=&#34;camel-case-issues-and-custom-contract-resolvers&#34;&gt;Camel case issues and custom contract resolvers&lt;/h2&gt;

&lt;p&gt;At this moment, MVC uses camel case notation to pass JSON to clients. That means that even if on the server you write your class properties with Pascal case notation (as you should!), JavaScript clients would get Camel cased objects.&lt;/p&gt;

&lt;p&gt;This behavior is new to ASP.NET Core and was not present in the older versions when SignalR was used and built, so SignalR and its clients all expect Pascal case objects, while the objects passed between MVC and its clients are camel cased. This means we cannot reuse metods across the JavaScript client, thing we cannot tolerate.&lt;/p&gt;

&lt;p&gt;So we are going to make SignalR pass objects in camel case. Basically, we are going to &amp;ldquo;recycle&amp;rdquo; &lt;a href=&#34;https://github.com/SignalR/SignalR/issues/500#issuecomment-7453751&#34;&gt;this old SignalR GitHub issue&lt;/a&gt; and adapt it to our versions of ASP.NET and SignalR.&lt;/p&gt;

&lt;h2 id=&#34;add-a-custom-contract-resolvers&#34;&gt;Add a custom contract resolvers&lt;/h2&gt;

&lt;p&gt;A first try could be to change the default contract resolver to a &lt;code&gt;CamelCasePropertyNamesContractResolver()&lt;/code&gt; inside the &lt;code&gt;ConfigureServices&lt;/code&gt; method:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var settings = new JsonSerializerSettings();
settings.ContractResolver = new CamelCasePropertyNamesContractResolver();

var serializer = JsonSerializer.Create(settings);
services.Add(new ServiceDescriptor(typeof(JsonSerializer), 
             provider =&amp;gt; serializer, 
             ServiceLifetime.Transient));

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;While this is not far from what we are going to do, at this moment we simply cannot force all components to pass camel case objects because it would break current conventions in place.&lt;/p&gt;

&lt;p&gt;Simply put, if you try this the JavaScript client will no longer connect, because all connection and internal communication is tansformed to camel case.&lt;/p&gt;

&lt;p&gt;We are at the point where we need all of the application objects to be passed camel cased, and all connection and SignalR internal objects to be unmodified.&lt;/p&gt;

&lt;p&gt;We will write a custom contract resolver that looks at the assembly of the object type and if it is not an internal SignalR object (if it is not from the same assembly as &lt;code&gt;Connection&lt;/code&gt;, a class from SignalR), then it modifies it to be camel case:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;using System;
using System.Reflection;
using Microsoft.AspNetCore.SignalR.Infrastructure;
using Newtonsoft.Json.Serialization;

    public class SignalRContractResolver : IContractResolver
    {
        private readonly Assembly _assembly;
        private readonly IContractResolver _camelCaseContractResolver;
        private readonly IContractResolver _defaultContractSerializer;

        public SignalRContractResolver()
        {
            _defaultContractSerializer = new DefaultContractResolver();
            _camelCaseContractResolver = new CamelCasePropertyNamesContractResolver();
            _assembly = typeof(Connection).GetTypeInfo().Assembly;
        }


        public JsonContract ResolveContract(Type type)
        {
            if (type.GetTypeInfo().Assembly.Equals(_assembly))
                return _defaultContractSerializer.ResolveContract(type);

            return _camelCaseContractResolver.ResolveContract(type);
        }

    }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So in &lt;code&gt;ConfigureServices&lt;/code&gt; we register our contract resolver very similarly to what we had earlier:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var settings = new JsonSerializerSettings();
settings.ContractResolver = new SignalRContractResolver();

var serializer = JsonSerializer.Create(settings);
services.Add(new ServiceDescriptor(typeof(JsonSerializer), 
             provider =&amp;gt; serializer, 
             ServiceLifetime.Transient));
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Note that most likely, this will be done more elegantly in future releases.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;the-configure-method&#34;&gt;The &lt;code&gt;Configure&lt;/code&gt; method&lt;/h2&gt;

&lt;p&gt;Again, the &lt;code&gt;Configure&lt;/code&gt; method is pretty straightforward: we add static files support, configure MVC and add WebSockets and SignalR.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public void Configure(IApplicationBuilder app)
    {
        app.UseStaticFiles();

        app.UseMvc(routes =&amp;gt; 
        {
            routes.MapRoute(
                    name: &amp;quot;default&amp;quot;,
                    template: &amp;quot;api/{controller}/{action}/{id?}&amp;quot;
            );
        });

        app.UseWebSockets();
        app.UseSignalR();
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;calling-client-methods-outside-hubs&#34;&gt;Calling client methods outside hubs&lt;/h2&gt;

&lt;p&gt;In the previous versions of SignalR, in order to call client methods and manage groups outside a hub you would need to make use of the &lt;code&gt;GlobalHost&lt;/code&gt;, which is no longer available in the new version.&lt;/p&gt;

&lt;p&gt;So we will use an instance of &lt;code&gt;ConnectionManager&lt;/code&gt;, specifically the &lt;code&gt;GetHubContext&amp;lt;&amp;gt;()&lt;/code&gt; method. We need to register this service so we can use it in the controller:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;_connectionManager.GetHubContext&amp;lt;PostsHub&amp;gt;().someClientMethod(parameters)&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;the-configureservices-method&#34;&gt;The &lt;code&gt;ConfigureServices&lt;/code&gt; method&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;    public void ConfigureServices(IServiceCollection services)
    {
        var settings = new JsonSerializerSettings();
        settings.ContractResolver = new SignalRContractResolver();

        var serializer = JsonSerializer.Create(settings);

        services.Add(new ServiceDescriptor(typeof(JsonSerializer), 
                     provider =&amp;gt; serializer, 
                     ServiceLifetime.Transient));

        services.AddSingleton&amp;lt;IPostRepository, PostRepository&amp;gt;();

        services.AddSignalR(options =&amp;gt; 
        {
            options.Hubs.EnableDetailedErrors = true;
        });
        
        services.AddMvc();
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We added the new contract resolver, we added the &lt;code&gt;PostRepository&lt;/code&gt; and we added SignalR. Now we need to use it in the controller:&lt;/p&gt;

&lt;h2 id=&#34;the-updated-controller&#34;&gt;The updated controller&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;using System.Collections.Generic;
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.SignalR.Infrastructure;

public class PostsController : Controller
{
    private IPostRepository _postRepository { get; set; }
    private IConnectionManager _connectionManager {get; set; }

    public PostsController(IPostRepository postRepository, IConnectionManager connectionManager)
    {
        _postRepository = postRepository;
        _connectionManager = connectionManager;
    }

    [HttpGet]
    public List&amp;lt;Post&amp;gt; GetPosts()
    {
        return _postRepository.GetAll();
    }

    [HttpGet]
    public Post GetPost(int id)
    {
        return _postRepository.GetPost(id);
    }

    [HttpPost]
    public void AddPost(Post post)
    {
        _postRepository.AddPost(post);
        _connectionManager.GetHubContext&amp;lt;PostsHub&amp;gt;().Clients.All.publishPost(post);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Every time someone adds a new post, all connected users will be notified and will call the &lt;code&gt;publishPost&lt;/code&gt; method.&lt;/p&gt;

&lt;h2 id=&#34;the-client&#34;&gt;The client&lt;/h2&gt;

&lt;p&gt;The client will be exactly the same as in SignalR 2.2.x:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;
	&amp;lt;meta charset=&amp;quot;utf-8&amp;quot; /&amp;gt;

    &amp;lt;script src=&amp;quot;http://ajax.aspnetcdn.com/ajax/jQuery/jquery-2.2.0.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&amp;quot;http://ajax.aspnetcdn.com/ajax/signalr/jquery.signalr-2.2.0.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&amp;quot;/signalr/hubs&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    
    &amp;lt;input id=&amp;quot;userNameInput&amp;quot; type=&amp;quot;text&amp;quot; placeholder=&amp;quot;Enter your user name...&amp;quot; /&amp;gt;
    &amp;lt;input id=&amp;quot;textInput&amp;quot; type=&amp;quot;text&amp;quot; placeholder=&amp;quot;Enter your status...&amp;quot; /&amp;gt;

    &amp;lt;button id=&amp;quot;publishPostButton&amp;quot;&amp;gt;Publish post!&amp;lt;/button&amp;gt;

    &amp;lt;ul id=&amp;quot;postsList&amp;quot;&amp;gt;&amp;lt;/ul&amp;gt;
    
    &amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
        $.ajax({
            url: &#39;/api/Posts/GetPosts&#39;,
            method: &#39;GET&#39;,
            dataType: &#39;JSON&#39;,
            success: addPostsList
        });

        function addPostsList(posts) {
            $.each(posts, function (index) {
                var post = posts[index];
                addPost(post);
            });
        }

        function addPost(post) {
            $(&amp;quot;#postsList&amp;quot;).append(
                    &#39;&amp;lt;li&amp;gt;&amp;lt;b&amp;gt;&#39; + post.userName + &#39;&amp;lt;/b&amp;gt;&amp;lt;br&amp;gt;&#39; + post.text + &#39;&amp;lt;/li&amp;gt;&amp;lt;br&amp;gt;&#39;
                 );
        }

        var hub = $.connection.postsHub;

        hub.client.publishPost = addPost;

        $(&amp;quot;#publishPostButton&amp;quot;).click(function () {

            var post = {
                userName: $(&amp;quot;#userNameInput&amp;quot;).val() || &amp;quot;Guest&amp;quot;,
                text: $(&amp;quot;#textInput&amp;quot;).val()
            };
            $.ajax({
                url: &#39;/api/Posts/AddPost&#39;,
                method: &#39;POST&#39;,
                data: post
            });
        });
        
        $.connection.hub.logging = true;
        $.connection.hub.start();
    &amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now if you open two browser tabs and start adding messages, you can see all pages updating in real time.&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;In this article we saw how to use MVC Core and SignalR for providing real time data to users.&lt;/p&gt;

&lt;p&gt;Since SignalR is still in alpha, at this moment there are some issues to be addressed and many breaking changes to come and I will try to keep this example up-to-date.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Getting started with SignalR Core</title>
      <link>https://radu-matei.com/blog/signalr-core/</link>
      <pubDate>Wed, 07 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://radu-matei.com/blog/signalr-core/</guid>
      <description>

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;ASP.NET SignalR is a library for ASP.NET developers that simplifies the process of adding real-time web functionality to applications. Real-time web functionality is the ability to have server code push content to connected clients instantly as it becomes available, rather than having the server wait for a client to request new data.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The 1.0.0 version of ASP.NET Core didn&amp;rsquo;t include a version of SignalR, so the team plans to release SignalR in the 1.2 iteration of the framework with some functionality that should make any SignalR developer happy: rewrite of the JavaScript client using TypeScript without the jQuery dependency, no more &lt;code&gt;GlobalHost&lt;/code&gt; and integration with the dependency injection engine from ASP.NET Core, remove the forever frame transport completely or support binary transfer.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;For the complete discussion for the SignalR planning, &lt;a href=&#34;https://github.com/aspnet/SignalR-Server/issues/196&#34;&gt;see this issue on the GitHub repository&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Since we are almost a year away from the official release of the framework, everything you are about to see is by no means production ready and will most likely suffer breaking changes over time. I will try to keep this article up-to-date with the various changes that will take place around SignalR over time.&lt;/p&gt;

&lt;p&gt;At this moment, there is a &lt;code&gt;0.2.0&lt;/code&gt; alpha version of &lt;a href=&#34;https://dotnet.myget.org/feed/aspnetcore-dev/package/nuget/Microsoft.AspNetCore.SignalR.Server&#34;&gt;&lt;code&gt;Microsoft.AspNetCore.SignalR.Server&lt;/code&gt;&lt;/a&gt; that makes it possible to use SignalR with an ASP.NET Core application, but it doesn&amp;rsquo;t implement the changes mentioned above just yet and you still use the same JavaScript client with the jQuery dependency.&lt;/p&gt;

&lt;h2 id=&#34;adding-nuget-config&#34;&gt;Adding NuGet.Config&lt;/h2&gt;

&lt;p&gt;In order to get access to the development packages of SignalR (of any package, really), we need to add a &lt;code&gt;NuGet.Config&lt;/code&gt; file that allows NuGet to get packages from multiple sources, in our case from the ASP.NET continous integration server from MyGet.&lt;/p&gt;

&lt;p&gt;In the same folder as &lt;code&gt;Program.cs&lt;/code&gt; and &lt;code&gt;Startup.cs&lt;/code&gt;, add a &lt;code&gt;NuGet.Config&lt;/code&gt; file with the following content:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;
&amp;lt;configuration&amp;gt;
    &amp;lt;packageSources&amp;gt;
        &amp;lt;clear/&amp;gt;
            &amp;lt;add key=&amp;quot;aspnetcidev&amp;quot; value=&amp;quot;https://dotnet.myget.org/F/aspnetcore-ci-dev/api/v3/index.json&amp;quot;/&amp;gt;
            &amp;lt;add key=&amp;quot;api.nuget.org&amp;quot; value=&amp;quot;https://api.nuget.org/v3/index.json&amp;quot;/&amp;gt;
    &amp;lt;/packageSources&amp;gt;
&amp;lt;/configuration&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;adding-the-required-packages&#34;&gt;Adding the required packages&lt;/h2&gt;

&lt;p&gt;We need to add the following packages:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;Microsoft.AspNetCore.Server.Kestrel&amp;quot;:&amp;quot;1.0.0&amp;quot;,
&amp;quot;Microsoft.AspNetCore.StaticFiles&amp;quot;: &amp;quot;1.0.0&amp;quot;,
&amp;quot;Microsoft.AspNetCore.SignalR.Server&amp;quot;: &amp;quot;0.2.0-*&amp;quot;,
&amp;quot;Microsoft.AspNetCore.WebSockets&amp;quot;: &amp;quot;0.2.0-*&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;configure-the-application&#34;&gt;Configure the application&lt;/h2&gt;

&lt;p&gt;Besides the usual configuration needed for a web application, we also need to add support for serving static files. If we use the current directory, the framework will search for a directory called &lt;code&gt;wwwroot&lt;/code&gt; and serve the file from there.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        public static void Main(string[] args)
        {
            var host = new WebHostBuilder()
                .UseKestrel()
                .UseContentRoot(Directory.GetCurrentDirectory())
                .UseStartup&amp;lt;Startup&amp;gt;()
                .Build();

            host.Run();
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next we need to add the required services in &lt;code&gt;Startup&lt;/code&gt;. In the &lt;code&gt;ConfigureServices&lt;/code&gt; method we need to &lt;code&gt;AddSignalR&lt;/code&gt;, with support for detailed errors in the browser console.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public void ConfigureServices(IServiceCollection services)
    {
        services.AddSignalR(options =&amp;gt; 
        {
            options.Hubs.EnableDetailedErrors = true;
        });
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, in the &lt;code&gt;Configure&lt;/code&gt; method, we need to serve static files, use websockets and use SignalR:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public void Configure(IApplicationBuilder app)
    {
        app.UseStaticFiles();
        app.UseWebSockets();
        app.UseSignalR();
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;At this moment, in order to get the framework to use websockets, you need to add &lt;code&gt;app.UseWebSockets()&lt;/code&gt;. If you don&amp;rsquo;t add the websockets support in your application, the transport will fall back to the next available transport.&lt;/p&gt;

&lt;p&gt;According to &lt;a href=&#34;https://github.com/aspnet/SignalR-Server/issues/220&#34;&gt;this GitHub issue&lt;/a&gt;, it is still not decided wether you will need to add the websockets reference as a separate operation or if it will be included in the &lt;code&gt;AddSignalR()&lt;/code&gt; call.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;At this point, you can add &lt;code&gt;Hub&lt;/code&gt; classes and JavaScript clients in exactly the same way as for &lt;code&gt;2.2.0&lt;/code&gt; or &lt;code&gt;2.2.1&lt;/code&gt;. Note that in future releases this will most likely be different, as changes in the client start appearing.&lt;/p&gt;

&lt;h2 id=&#34;adding-a-hub-class&#34;&gt;Adding a Hub class&lt;/h2&gt;

&lt;p&gt;The very simple example here, as it is very common in the case of SignalR, a chat :)&lt;/p&gt;

&lt;p&gt;We have a &lt;code&gt;Connect&lt;/code&gt; method used to add a user to a connected users list and a &lt;code&gt;Send&lt;/code&gt; method that sends a message.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class ChatHub : Hub
    {
        public static List&amp;lt;string&amp;gt; ConnectedUsers;

        public void Send(string originatorUser, string message)
        {
            Clients.All.messageReceived(originatorUser, message);
        }

        public void Connect(string newUser)
        {
            if (ConnectedUsers == null)
                ConnectedUsers = new List&amp;lt;string&amp;gt;();

            ConnectedUsers.Add(newUser);
            Clients.Caller.getConnectedUsers(ConnectedUsers);
            Clients.Others.newUserAdded(newUser);
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;To keep things simple I didn&amp;rsquo;t use the &lt;code&gt;OnConnected&lt;/code&gt; override here.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;adding-the-client&#34;&gt;Adding the client&lt;/h2&gt;

&lt;p&gt;We will now create a &lt;code&gt;wwwroot&lt;/code&gt; directory that will contain all of our static files.&lt;/p&gt;

&lt;p&gt;We add a new HTML file called &lt;code&gt;chat.html&lt;/code&gt; that will simply have an unordered list for the messages, a text input and a button. As you can see, the SignalR script used here is the latest one, &lt;code&gt;2.2.1&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;Awesome Chat Application&amp;lt;/title&amp;gt;
	&amp;lt;meta charset=&amp;quot;utf-8&amp;quot; /&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;style type=&amp;quot;text/css&amp;quot;&amp;gt;
        .userListDiv{
            float: right;
        }
    &amp;lt;/style&amp;gt;

    &amp;lt;ul id=&amp;quot;messages&amp;quot;&amp;gt;&amp;lt;/ul&amp;gt;
    &amp;lt;input type=&amp;quot;text&amp;quot; id=&amp;quot;messageBox&amp;quot; /&amp;gt;
    &amp;lt;input type=&amp;quot;button&amp;quot; id=&amp;quot;sendMessage&amp;quot; value=&amp;quot;Send Message!&amp;quot; /&amp;gt;
    &amp;lt;div class=&amp;quot;userListDiv&amp;quot;&amp;gt;
        &amp;lt;ul id=&amp;quot;userList&amp;quot;&amp;gt; &amp;lt;/ul&amp;gt;
    &amp;lt;/div&amp;gt;

    &amp;lt;script src=&amp;quot;http://ajax.aspnetcdn.com/ajax/jQuery/jquery-3.1.0.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&amp;quot;http://ajax.aspnetcdn.com/ajax/signalr/jquery.signalr-2.2.1.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&amp;quot;signalr/hubs&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&amp;quot;chat.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We also add a &lt;code&gt;chat.js&lt;/code&gt; file that contains the SignalR connection and client methods:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var userName = prompt(&amp;quot;Enter your name: &amp;quot;);
var chat = $.connection.chatHub;
chat.client.messageReceived = function (originatorUser, message) {
    $(&amp;quot;#messages&amp;quot;).append(&#39;&amp;lt;li&amp;gt;&amp;lt;strong&amp;gt;&#39; + originatorUser + &#39;&amp;lt;/strong&amp;gt;: &#39; + message);
};

chat.client.getConnectedUsers = function (userList) {
    for (var i = 0; i &amp;lt; userList.length; i++)
        addUser(userList[i]);
};

chat.client.newUserAdded = function (newUser) {
    addUser(newUser);
}

$(&amp;quot;#messageBox&amp;quot;).focus();

$(&amp;quot;#sendMessage&amp;quot;).click(function () {
    chat.server.send(userName, $(&amp;quot;#messageBox&amp;quot;).val());
    $(&amp;quot;#messageBox&amp;quot;).val(&amp;quot;&amp;quot;);
    $(&amp;quot;#messageBox&amp;quot;).focus();
});

$(&amp;quot;#messageBox&amp;quot;).keyup(function (event) {
    if (event.keyCode == 13)
        $(&amp;quot;#sendMessage&amp;quot;).click();
});

function addUser(user){
    $(&amp;quot;#userList&amp;quot;).append(&#39;&amp;lt;li&amp;gt;&#39; + user + &#39;&amp;lt;/li&amp;gt;&#39;);
}

$.connection.hub.logging = true;
$.connection.hub.start().done(function () {
    chat.server.connect(userName);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Basically, ask the user for a user name, define the client methods that display messages and users and define the behaviour when clicking the button (and for pressing Enter).&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;This is a very simple example of integrating a very early preview of SignalR Core into an ASP.NET Core application. As the framework evolves, I will try to keep this example up to date.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Inject ASP.NET Core Dependencies from JSON files</title>
      <link>https://radu-matei.com/blog/aspnet-core-json-dependency-injection/</link>
      <pubDate>Thu, 18 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://radu-matei.com/blog/aspnet-core-json-dependency-injection/</guid>
      <description>

&lt;h2 id=&#34;table-of-content&#34;&gt;Table of Content&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#introduction&#34;&gt;Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#the-need-for-registering-services-through-a-json-file&#34;&gt;The need for registering services through a JSON file&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#adding-the-required-packages&#34;&gt;Adding the required packages&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#creating-a-dummy-service&#34;&gt;Creating a dummy service&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#how-to-inject-an-itest-service&#34;&gt;How to inject an &lt;code&gt;ITest&lt;/code&gt; service&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#the-json-file&#34;&gt;The JSON file&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#the-service-class&#34;&gt;The &lt;code&gt;Service&lt;/code&gt; class&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#adding-the-services&#34;&gt;Adding the services&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#testing-the-application&#34;&gt;Testing the application&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#the-startup-class&#34;&gt;The &lt;code&gt;Startup&lt;/code&gt; class&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#conclusion&#34;&gt;Conclusion&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;&amp;ldquo;Back in the days&amp;rdquo; of ASP.NET 4.x, each of the framework components (MVC, WebAPI, OWIN, SignalR) had its own dependency resolver and its own way of integrating with the framework.&lt;/p&gt;

&lt;p&gt;For example, if you had an application that used MVC/WebAPI, OWIN and SignalR and you wanted to use &lt;a href=&#34;http://autofac.readthedocs.io/en/latest/index.html&#34;&gt;Autofac&lt;/a&gt;, you would have needed individual integrations, with different method names (see &lt;a href=&#34;http://autofac.readthedocs.io/en/latest/integration/mvc.html#register-controllers&#34;&gt;&lt;code&gt;RegisterControllers&lt;/code&gt;&lt;/a&gt; for MVC and &lt;a href=&#34;http://autofac.readthedocs.io/en/latest/integration/webapi.html#register-controllers&#34;&gt;&lt;code&gt;RegisterApiControllers&lt;/code&gt;&lt;/a&gt; for WebAPI), different NuGet packages (see &lt;a href=&#34;https://www.nuget.org/packages/Autofac.WebApi2/&#34;&gt;the package for WebAPI&lt;/a&gt; and &lt;a href=&#34;https://www.nuget.org/packages/Autofac.Mvc5/&#34;&gt;the package for MVC&lt;/a&gt;) and different dependency resolvers and you even needed to take care at the order in which you replaced the dependency resolvers for these components.&lt;/p&gt;

&lt;p&gt;ASP.NET Core brings a consistent dependency injection mechanism with a unified meaning for lifetime or service registration,that is designed to server the needs of the framework &amp;ldquo;and most consumer applications built on it&amp;rdquo; (&lt;a href=&#34;https://docs.asp.net/en/latest/fundamentals/dependency-injection.html#replacing-the-default-services-container&#34;&gt;as the documentation states&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;Of course, you can replace the default DI engine that comes with the framework and use &lt;a href=&#34;http://autofac.readthedocs.io/en/latest/integration/aspnetcore.html&#34;&gt;Autofac&lt;/a&gt;, &lt;a href=&#34;https://www.nuget.org/packages/DryIoc.Microsoft.DependencyInjection&#34;&gt;Dryloc&lt;/a&gt;, &lt;a href=&#34;https://www.nuget.org/packages/Grace.DependencyInjection.Extensions&#34;&gt;Grace&lt;/a&gt;, &lt;a href=&#34;https://github.com/seesharper/LightInject.Microsoft.DependencyInjection&#34;&gt;LightInject&lt;/a&gt; or &lt;a href=&#34;https://github.com/structuremap/StructureMap.Microsoft.DependencyInjection&#34;&gt;StructureMap&lt;/a&gt; and in a future article, we will probably explore a couple of them.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;In this article, we will see a way of defining the service types and the implementation types we want to use based on a JSON file and switch between implementations without changing the code.&lt;/p&gt;

&lt;p&gt;This is a feature in Autofac for ASP.NET and you can &lt;a href=&#34;http://docs.autofac.org/en/latest/configuration/xml.html&#34;&gt;find it documented here&lt;/a&gt;, but we will implement a very basic way of adding services using only the built-in mechanism.&lt;/p&gt;

&lt;p&gt;Also, it will not use the &lt;a href=&#34;https://radu-matei.github.io/blog/aspnet-core-configuration-greeting/&#34;&gt;JSON configuration provider&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;the-need-for-registering-services-through-a-json-file&#34;&gt;The need for registering services through a JSON file&lt;/h2&gt;

&lt;p&gt;A very simple reason to think about using a JSON file when registering DI services is because you might not know (or cannot choose) the concrete implementation at compile-time.&lt;/p&gt;

&lt;p&gt;Another reason could be for switching implementations for testing purposes.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;You can also &lt;a href=&#34;https://docs.asp.net/en/latest/fundamentals/environments.html&#34;&gt;work with multiple environments&lt;/a&gt; and have &lt;code&gt;Startup{EnvironmentName}&lt;/code&gt; class for each environment - dev, testing, production and set the environment variable before running the application.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;But for this article, I thought it would be cool to inject the required dependencies based on a JSON file without using any DI engine other than the built-in one from ASP.NET Core.&lt;/p&gt;

&lt;h2 id=&#34;adding-the-required-packages&#34;&gt;Adding the required packages&lt;/h2&gt;

&lt;p&gt;Since this is going to be a web app, we need the Kestrel web server package (Microsoft.AspNetCore.Server.Kestrel). As I said earlier, we are not going to use the JSON Configuration provider (at this point), so we will only need a library to deserialize (part of) JSON, and we will use Newtonsoft.Json.&lt;/p&gt;

&lt;h2 id=&#34;creating-a-dummy-service&#34;&gt;Creating a dummy service&lt;/h2&gt;

&lt;p&gt;We are going to need a very simple service to inject in our application:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public interface ITest
{
    string DoSomething(string parameter);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And an even simpler implementation:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Test : ITest
{
    public string DoSomething(string parameter)
    {
        return $&amp;quot;Message from Test with { parameter }&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;how-to-inject-an-itest-service&#34;&gt;How to inject an &lt;code&gt;ITest&lt;/code&gt; service&lt;/h2&gt;

&lt;p&gt;In order to inject a service of type &lt;code&gt;ITest&lt;/code&gt;, you need to add a function in &lt;code&gt;Startup&lt;/code&gt; called &lt;code&gt;ConfigureServices&lt;/code&gt; that has a parameter of type &lt;code&gt;ISerciceCollection&lt;/code&gt; and add the service in this collection.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public void ConfigureServices(IServiceCollection services)
{
    services.Add(new ServiceDescriptor(serviceType: typeof(ITest), 
                                       implementationType: typeof(Test), 
                                       lifetime: ServiceLifetime.Transient));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, every time a component will request an instance of &lt;code&gt;ITest&lt;/code&gt;, the framework will provide &lt;em&gt;another&lt;/em&gt; instance of &lt;code&gt;Test&lt;/code&gt;, since the lifetime is passed as &lt;em&gt;Transient&lt;/em&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.asp.net/en/latest/fundamentals/dependency-injection.html&#34;&gt;Transient objects are always different; a new instance is provided to every controller and every service.&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;the-json-file&#34;&gt;The JSON File&lt;/h2&gt;

&lt;p&gt;Since we will use a JSON file, it might as well be the one we use for other configurations (or a completely different one). Regardless of what you choose, you can extract only the relevant part of the JSON file using a section name.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
    &amp;quot;services&amp;quot;: [
        {
            &amp;quot;serviceType&amp;quot;: &amp;quot;ITest&amp;quot;,
            &amp;quot;implementationType&amp;quot;: &amp;quot;Test&amp;quot;,
            &amp;quot;lifetime&amp;quot;: &amp;quot;Transient&amp;quot;
        }
    ],

    &amp;quot;otherConfigurations&amp;quot;: {
        &amp;quot;someKey&amp;quot;: &amp;quot;someValue&amp;quot;,
        &amp;quot;otherKey&amp;quot;: &amp;quot;otherValue&amp;quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this case, the JSON section we are interested in is &lt;code&gt;services&lt;/code&gt;. At this key, we have an array of JSON objects with 3 properties: &lt;code&gt;serviceType&lt;/code&gt;, &lt;code&gt;implementationType&lt;/code&gt; and &lt;code&gt;lifetime&lt;/code&gt;, which correspond to the parameters passed to the &lt;code&gt;ServiceDescriptor&lt;/code&gt; when adding the service.&lt;/p&gt;

&lt;h2 id=&#34;the-service-class&#34;&gt;The &lt;code&gt;Service&lt;/code&gt; class&lt;/h2&gt;

&lt;p&gt;These 3 properties are mapped into a class called &lt;code&gt;Service&lt;/code&gt;. For simplicity, the &lt;code&gt;ServiceType&lt;/code&gt; and &lt;code&gt;ImplementationType&lt;/code&gt; propeties are of type &lt;code&gt;string&lt;/code&gt;, but you can always implement a &lt;code&gt;JsonConverter&lt;/code&gt; that maps them to the type &lt;code&gt;Type&lt;/code&gt; (There is no immediate conversion from &lt;code&gt;string&lt;/code&gt; to &lt;code&gt;Type&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Since &lt;code&gt;Newtonsoft&lt;/code&gt; has implemented the conversion from &lt;code&gt;string&lt;/code&gt; to &lt;code&gt;enum&lt;/code&gt;, we used it here to convert to &lt;code&gt;ServiceLifetime&lt;/code&gt; enum from &lt;code&gt;Microsoft.Extensions.DependencyInjection&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;using Microsoft.Extensions.DependencyInjection;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;

public class Service
{
    public string ServiceType { get; set; }

    public string ImplementationType { get;set; }

    [JsonConverter(typeof(StringEnumConverter))]
    public ServiceLifetime Lifetime { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;adding-the-services&#34;&gt;Adding the services&lt;/h2&gt;

&lt;p&gt;Next, in the &lt;code&gt;Startup&lt;/code&gt; class we will simply deserialize the JSON section into a &lt;code&gt;List&amp;lt;Service&amp;gt;&lt;/code&gt;, iterate through it and add the services:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private void ConfigureJsonServices(IServiceCollection services)
{
    var jsonServices = JObject.Parse(File.ReadAllText(&amp;quot;appSettings.json&amp;quot;))[&amp;quot;services&amp;quot;];
    var requiredServices = JsonConvert.DeserializeObject&amp;lt;List&amp;lt;Service&amp;gt;&amp;gt;(jsonServices.ToString());

    foreach(var service in requiredServices)
    {
         services.Add(new ServiceDescriptor(serviceType: Type.GetType(service.ServiceType),
                                            implementationType: Type.GetType(service.ImplementationType),
                                            lifetime: service.Lifetime));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then, in the &lt;code&gt;ConfigureServices&lt;/code&gt; method, call this method with the &lt;code&gt;services&lt;/code&gt; argument.&lt;/p&gt;

&lt;h2 id=&#34;testing-the-application&#34;&gt;Testing the application&lt;/h2&gt;

&lt;p&gt;The first thing we can do is to add a breakpoint after executing the &lt;code&gt;ConfigureJsonServices&lt;/code&gt; method.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/aspnet-core-json-dependency-injection/services-breakpoint.JPG&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;We can see that our &lt;code&gt;ITest&lt;/code&gt; service was added and now we can inject it anywhere in our application.&lt;/p&gt;

&lt;p&gt;At this point, we can also inject an instance of the service in the &lt;code&gt;Configure&lt;/code&gt; method and have a message returned from the service:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public void Configure(IApplicationBuilder app, ITest test)
    {
        app.Run(context =&amp;gt;
        {
            var response = test.DoSomething(&amp;quot;startup&amp;quot;);
            return context.Response.WriteAsync(response);
        });
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Every time you need to provide another implementation for a service, you don&amp;rsquo;t have to recompile the entire application, simply modify the JSON file and start the application again.&lt;/p&gt;

&lt;h2 id=&#34;the-startup-class&#34;&gt;The &lt;code&gt;Startup&lt;/code&gt; class&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;using System;
using System.IO;
using System.Collections.Generic;
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Hosting;
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.DependencyInjection;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;

public class Startup
{
    public void ConfigureServices(IServiceCollection services)
    {
        ConfigureJsonServices(services);
    }

    public void Configure(IApplicationBuilder app, ITest test)
    {
        app.Run(context =&amp;gt;
        {
            var response = test.DoSomething(&amp;quot;startup&amp;quot;);
            return context.Response.WriteAsync(response);
        });
    }

    private void ConfigureJsonServices(IServiceCollection services)
    {
        var jsonServices = JObject.Parse(File.ReadAllText(&amp;quot;appSettings.json&amp;quot;))[&amp;quot;services&amp;quot;];
        var requiredServices = JsonConvert.DeserializeObject&amp;lt;List&amp;lt;Service&amp;gt;&amp;gt;(jsonServices.ToString());

        foreach(var service in requiredServices)
        {
            services.Add(new ServiceDescriptor(serviceType: Type.GetType(service.ServiceType),
                                               implementationType: Type.GetType(service.ImplementationType),
                                               lifetime: service.Lifetime));
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;This is a very basic and rudimentary way of injecting dependencies in the application. It is by no means production ready, it doesn&amp;rsquo;t deal with exceptions, services that don&amp;rsquo;t exist or incorrect lifetimes.&lt;/p&gt;

&lt;p&gt;It is only a simple alternative to registering each service manually, in code, recompiling the entire application evey time you needed to swap some services.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Introduction to ASP .NET Core MVC API</title>
      <link>https://radu-matei.com/blog/aspnet-core-api/</link>
      <pubDate>Fri, 05 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://radu-matei.com/blog/aspnet-core-api/</guid>
      <description>

&lt;h2 id=&#34;table-of-content&#34;&gt;Table of Content&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#introduction&#34;&gt;Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#adding-the-mvc-services-to-our-application&#34;&gt;Adding the MVC services to our application&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#adding-the-post-class&#34;&gt;Adding the &lt;code&gt;Post&lt;/code&gt; class&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#creating-an-ipostrepository-interface&#34;&gt;Creating an &lt;code&gt;IPostRepository&lt;/code&gt; interface&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#creating-an-in-memory-implementation-of-ipostrepository&#34;&gt;Creating an in-memory implementation of &lt;code&gt;IPostRepository&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#the-postcontroller-class&#34;&gt;The &lt;code&gt;PostController&lt;/code&gt; class&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#registering-the-repository-service-in-startup&#34;&gt;Registering the repository service in &lt;code&gt;Startup&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#startup-cs&#34;&gt;&lt;code&gt;Startup.cs&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#testing-the-application&#34;&gt;Testing the application&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#conclusion&#34;&gt;Conclusion&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;Up to this point, we have been learning about &lt;a href=&#34;https://radu-matei.github.io/blog/dot-net-core-introduction/&#34;&gt;.NET Core&lt;/a&gt; and &lt;a href=&#34;https://radu-matei.github.io/blog/dot-net-core-getting-started/&#34;&gt;VS Code&lt;/a&gt;, about &lt;a href=&#34;https://radu-matei.github.io/blog/aspnet-core-getting-started/&#34;&gt;ASP .NET Core&lt;/a&gt;, the &lt;a href=&#34;https://radu-matei.github.io/blog/aspnet-core-startup/&#34;&gt;&lt;code&gt;Startup&lt;/code&gt; class&lt;/a&gt;, &lt;a href=&#34;https://radu-matei.github.io/blog/aspnet-core-routing/&#34;&gt;Routing&lt;/a&gt; and &lt;a href=&#34;https://radu-matei.github.io/blog/aspnet-core-configuration-greeting/&#34;&gt;how to use JSON Configuration&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In this article we will be looking at ASP .NET Core MVC, more specifically at how to build an API that can be consumed from any type of application, be it web, mobile or desktop.&lt;/p&gt;

&lt;p&gt;We will build a very simple application that will enable the creation of posts (much like messages) and that will take us through adding the MVC services, creating models, controllers and consuming some data.&lt;/p&gt;

&lt;p&gt;We will start this article by building on the code form the &lt;a href=&#34;https://radu-matei.github.io/blog/aspnet-core-startup/&#34;&gt;Startup class&lt;/a&gt; tutorial.&lt;/p&gt;

&lt;h2 id=&#34;adding-the-mvc-services-to-our-application&#34;&gt;Adding the MVC services to our application&lt;/h2&gt;

&lt;p&gt;The first thing we have to do is add the &lt;code&gt;&amp;quot;Microsoft.AspNetCore.Mvc&amp;quot;: &amp;quot;1.0.0&amp;quot;&lt;/code&gt; dependency in &lt;code&gt;project.json&lt;/code&gt;, then add the &lt;code&gt;ConfigureServices&lt;/code&gt; method in the &lt;code&gt;Startup&lt;/code&gt; class.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public void ConfigureServices(IServiceCollection services)
    {
        services.AddMvc();
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we have to register some routes for the incoming requests, in this case, any incoming requests that match &lt;code&gt;/api/{controller}/{action}/{id?}&lt;/code&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;{controller}&lt;/code&gt; - the name of the controller (for example, &lt;code&gt;TestController&lt;/code&gt; - &lt;code&gt;/api/test&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;&lt;code&gt;{action}&lt;/code&gt; - the name of the method from the controller&lt;/p&gt;

&lt;p&gt;&lt;code&gt;{id?}&lt;/code&gt; - optional parameter passed to the method&lt;/p&gt;

&lt;p&gt;So a request for &lt;code&gt;/api/test/hello/3&lt;/code&gt; will be mapped to &lt;code&gt;TestController&lt;/code&gt; in the &lt;code&gt;Hello&lt;/code&gt; method which will have 3 as parameter for &lt;code&gt;id&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;    public void Configure(IApplicationBuilder app)
    {
        app.UseMvc(routes =&amp;gt;
        {
            routes.MapRoute(
                name: &amp;quot;default&amp;quot;,
                template: &amp;quot;api/{controller}/{action}/{id?}&amp;quot;
            );
        });
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Note that you can customize your route template in any way, I chose the &lt;code&gt;/api&lt;/code&gt; option because in previous versions of ASP .NET (Web Api) this was the default route for creating an API.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;At this point, we can add a controller and make some requests to test our framework. So let&amp;rsquo;s add a controller, I will call it &lt;code&gt;PostsController&lt;/code&gt; and it will have a very simple method that will return a &lt;code&gt;string&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;using Microsoft.AspNetCore.Mvc;

public class PostsController : Controller
{
	public string Hello()
	{
		return &amp;quot;Hello from MVC!&amp;quot;;
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To run the application, execute &lt;code&gt;dotnet restore&lt;/code&gt; and &lt;code&gt;dotnet run&lt;/code&gt; in the root of the project and browse to &lt;code&gt;http://localhost:5000/api/Posts/Hello&lt;/code&gt;. If everyting works, you should see the message received from the controller.&lt;/p&gt;

&lt;h2 id=&#34;adding-the-post-class&#34;&gt;Adding the &lt;code&gt;Post&lt;/code&gt; class&lt;/h2&gt;

&lt;p&gt;As we said earlier, each user that enters can publish a post containing his user name and a text, so our &lt;code&gt;Post&lt;/code&gt; class only contains two properties for the &lt;code&gt;UserName&lt;/code&gt; and &lt;code&gt;Text&lt;/code&gt; of the post and an &lt;code&gt;Id&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public class Post
    {
        public int Id { get; set; }
        public string UserName { get; set; }
        public string Text { get; set; }

        public Post(int id, string userName, string text)
        {
            Id = id;
            UserName = userName;
            Text = text;
        }

        public Post()
        {
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There is also a parameterless constructor and a constructor that takes arguments the three properties.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If you add a constructor in a C# class, the compiler will no longer create the default parameterless constructor, and JSON serialization needs a parameterless constructor when serializing and deserializing objects.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;creating-an-ipostrepository-interface&#34;&gt;Creating an &lt;code&gt;IPostRepository&lt;/code&gt; interface&lt;/h2&gt;

&lt;p&gt;In order for our API to work, we are going to need a way for it to store data. Regardless of where that data is going to be stored, there should be a consistent way of reading and writing, and we will achieve this through an interface, &lt;code&gt;IPostRepository&lt;/code&gt;, that will expose the minimum necessary methods: a method to read all posts, a method to add a post and a method to retrieve a post with a specified id.&lt;/p&gt;

&lt;p&gt;So the interface should look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;using System.Collections.Generic;

public interface IPostRepository
{
    List&amp;lt;Post&amp;gt; GetAll();
    Post GetPost(int id);
    void AddPost(Post post);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since this is a very simple example, we are going to store the data in a list in memory, but regardless of the location, the publicly available methods will be exactly the same, making any modifications to the data store easy to implement (more on this later).&lt;/p&gt;

&lt;h2 id=&#34;creating-an-in-memory-implementation-of-ipostrepository&#34;&gt;Creating an in-memory implementation of &lt;code&gt;IPostRepository&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;We will implement the &lt;code&gt;IPostRepository&lt;/code&gt; interface through an in-memory class we will call &lt;code&gt;PostRepository&lt;/code&gt; that will hold the data in a list.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    private List&amp;lt;Post&amp;gt; _posts = new List&amp;lt;Post&amp;gt;()
    {
        new Post(1, &amp;quot;Obi-Wan Kenobi&amp;quot;,&amp;quot;These are not the droids you&#39;re looking for&amp;quot;),
        new Post(2, &amp;quot;Darth Vader&amp;quot;,&amp;quot;I find your lack of faith disturbing&amp;quot;)
    };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since we have the three methods to access the data, there is no need to expose the post list outside the class, so it will be private. Besides the list, we only need to implement the three methods from the interface, so here is the full &lt;code&gt;PostRepository&lt;/code&gt; class:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;using System.Collections.Generic;
using System.Linq;

public class PostRepository : IPostRepository
{
    private List&amp;lt;Post&amp;gt; _posts = new List&amp;lt;Post&amp;gt;()
    {
        new Post(1, &amp;quot;Obi-Wan Kenobi&amp;quot;,&amp;quot;These are not the droids you&#39;re looking for&amp;quot;),
        new Post(2, &amp;quot;Darth Vader&amp;quot;,&amp;quot;I find your lack of faith disturbing&amp;quot;)
    };
    public void AddPost(Post post)
    {
        _posts.Add(post);
    }

    public List&amp;lt;Post&amp;gt; GetAll()
    {
        return _posts;
    }

    public Post GetPost(int id)
    {
        return _posts.FirstOrDefault(p =&amp;gt; p.Id == id);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;the-postcontroller-class&#34;&gt;The &lt;code&gt;PostController&lt;/code&gt; class&lt;/h2&gt;

&lt;p&gt;ASP .NET (MVC Core and other versions) maps requests to classes called controllers that are responsible for processing incoming requests, handling user input and generating the response (by themselves or by calling other services).&lt;/p&gt;

&lt;p&gt;We will create a very simple &lt;code&gt;PostController&lt;/code&gt;  that will have methods to get all posts, add a post and retrieve a single post based on the id.&lt;/p&gt;

&lt;p&gt;The controller will have some instance of &lt;code&gt;IPostRepository&lt;/code&gt;(we will see shortly how it will have it) and will call methods from the repository.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;using System.Collections.Generic;
using Microsoft.AspNetCore.Mvc;

public class PostsController : Controller
{
    private IPostRepository _postRepository { get; set; }

    public PostsController(IPostRepository postRepository)
    {
        _postRepository = postRepository;
    }

    public List&amp;lt;Post&amp;gt; GetPosts()
    {
        return _postRepository.GetAll();
    }

    public Post GetPost(int id)
    {
        return _postRepository.GetPost(id);
    }

    public void AddPost([FromBody]Post post)
    {
        _postRepository.AddPost(post);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Notice how the &lt;code&gt;AddPost&lt;/code&gt; method accepts a &lt;code&gt;Post&lt;/code&gt; parameter. Because it has the &lt;code&gt;FromBody&lt;/code&gt; attribute, the framework will automatically try to map the body of the request to an object of type &lt;code&gt;Post&lt;/code&gt; that is deserialized from JSON.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Besides from the publicly exposed methods of the API (any public method placed in a controller is publicly accessible from the web), we also have a constructor through which we can provide the appropriate implementation of &lt;code&gt;IPostRepository&lt;/code&gt; and we will specify this in the &lt;code&gt;Startup&lt;/code&gt; of our application.&lt;/p&gt;

&lt;h2 id=&#34;registering-the-repository-service-in-startup&#34;&gt;Registering the repository service in &lt;code&gt;Startup&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;So far, we have created an &lt;code&gt;IPostRepostitory&lt;/code&gt; interface, implemented it in &lt;code&gt;PostRepository&lt;/code&gt; and used it in &lt;code&gt;PostController&lt;/code&gt;(without creating any instance). So if we ran the application right now and navigated to &lt;code&gt;http://localhost:5000/api/Posts/GetPosts&lt;/code&gt; we would get a null reference exception simply because we haven&amp;rsquo;t specified what instance of &lt;code&gt;IPostRepository&lt;/code&gt; our application is supposed to use.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public void ConfigureServices(IServiceCollection services)
    {
        services.AddMvc();
        services.AddSingleton&amp;lt;IPostRepository, PostRepository&amp;gt;();
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We only need to specify that whenever someone needs an &lt;code&gt;IPostRepository&lt;/code&gt;, the framework should provide them (the same) instance of &lt;code&gt;PostRepository&lt;/code&gt;. So when the &lt;code&gt;PostController&lt;/code&gt; constructor has a parameter of type &lt;code&gt;IPostRepository&lt;/code&gt;, the framework will provide an instance of &lt;code&gt;PostRepository&lt;/code&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;We added the repository as singleton because of the in-memory impementation: if we made a new instance of &lt;code&gt;PostRepository&lt;/code&gt; for every request, then the post list would be instantiated every time, not saving the modifications.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;startup-cs&#34;&gt;&lt;code&gt;Startup.cs&lt;/code&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;using Microsoft.AspNetCore.Builder;
using Microsoft.Extensions.DependencyInjection;

public class Startup
{
    public void ConfigureServices(IServiceCollection services)
    {
        services.AddMvc();
        services.AddSingleton&amp;lt;IPostRepository, PostRepository&amp;gt;();
    }

    public void Configure(IApplicationBuilder app)
    {
        app.UseMvc(routes =&amp;gt;
        {
            routes.MapRoute(
                name: &amp;quot;default&amp;quot;,
                template: &amp;quot;api/{controller}/{action}/{id?}&amp;quot;
            );
        });
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;testing-the-application&#34;&gt;Testing the application&lt;/h2&gt;

&lt;p&gt;At this point, we can either execute &lt;code&gt;dotnet run&lt;/code&gt; in the root of our project or press &lt;code&gt;F5&lt;/code&gt; in Visual Studio Code.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;We will use &lt;a href=&#34;https://chrome.google.com/webstore/detail/postman/fhbjgbiflinjbdggehcddcbncdddomop&#34;&gt;PostMan for Google Chrome&lt;/a&gt; in order to test the functionality of our API.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;If we open PostMan and create a GET request to &lt;code&gt;http://localhost:5000/api/Posts/GetPosts&lt;/code&gt;, we will see the two posts that we used to populate the list in &lt;code&gt;PostRepository&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/aspnet-core-api/aspnet-core-api-postman-get.JPG&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;We can see that the response was JSON and it returned a 200 OK HTML code.&lt;/p&gt;

&lt;p&gt;In order to test the post functionality, we create a POST request to &lt;code&gt;http://localhost:5000/api/Posts/AddPost&lt;/code&gt; with a JSON object containing the properties of a &lt;code&gt;Post&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
    &amp;quot;Id&amp;quot;: 3,
    &amp;quot;UserName&amp;quot;: &amp;quot;Darth Vader&amp;quot;,
    &amp;quot;Text&amp;quot;: &amp;quot;Luke, I am your father!r&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;You can either use the upper camel case or the lower camel case notation (as you saw in the response from the server, the objects were in lower camel case), but the name and type of the properties must match the ones on the server:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;  {
    &amp;quot;id&amp;quot;: 3,
    &amp;quot;userName&amp;quot;: &amp;quot;Darth Vader&amp;quot;,
    &amp;quot;text&amp;quot;: &amp;quot;Luke, I am your father!r&amp;quot;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/aspnet-core-api/aspnet-core-api-postman-post.JPG&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Now, if we create another request to &lt;code&gt;http://localhost:5000/api/Posts/GetPosts&lt;/code&gt; we can see that the post we added was saved.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/aspnet-core-api/aspnet-core-api-postman-get-posts.JPG&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;So far we created an API that adds and reads posts from an in-memory data store. A real-life application would have a different type of data store (SQL/NoSQL database) and most certainly an application that consumes this data rather than using it from PostMan.&lt;/p&gt;

&lt;p&gt;This API can be consumed from a web application (HTML + JavaScript), a mobile application (virtually any type of mobile application, regardless of the OS), a desktop application (again, any type of desktop application for any OS), even console applications.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ASP .NET Core JSON Configuration and Dependency Injection</title>
      <link>https://radu-matei.com/blog/aspnet-core-configuration-greeting/</link>
      <pubDate>Sat, 23 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>https://radu-matei.com/blog/aspnet-core-configuration-greeting/</guid>
      <description>

&lt;h2 id=&#34;table-of-content&#34;&gt;Table of Content&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#introduction&#34;&gt;Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#using-the-asp-net-core-json-configuration-provider&#34;&gt;Using the ASP .NET Core JSON Configuration Provider&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#building-the-configurable-greeting-service&#34;&gt;Building the configurable Greeting service&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#making-use-of-asp-net-core-dependency-injection&#34;&gt;Making use of ASP .NET Core Dependency Injection&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#conclusion&#34;&gt;Conclusion&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;In the previous versions of ASP .NET, any configuration setting or parameter you needed was added in &lt;code&gt;web.config&lt;/code&gt; &lt;a href=&#34;http://www.codeproject.com/Articles/301726/Web-config-File-ASP-NET&#34;&gt;(complete description of the old &lt;code&gt;web.config&lt;/code&gt; file)&lt;/a&gt;, or added in a separate XML file and referenced in &lt;code&gt;web.config&lt;/code&gt; (for scenarios like database connection strings, or storing APIs access tokens).&lt;/p&gt;

&lt;p&gt;The new configuration system provides support for JSON, XML, INI and for in-memory configuration, while also allowing you to &lt;a href=&#34;https://docs.asp.net/en/latest/fundamentals/configuration.html#custom-config-providers&#34;&gt;create your custom configuration provider&lt;/a&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;For a detailed view of ASP .NET Core Configuration system, read the &lt;a href=&#34;https://docs.asp.net/en/latest/fundamentals/configuration.html&#34;&gt;Official ASP .NET Documentation&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;https://radu-matei.github.io/blog/aspnet-core-routing/&#34;&gt;In the tutorial about Routing&lt;/a&gt;, we created a very simple web application that used the Routing service to respond to some requests, but they were hardcoded and if we wanted to change the response message, we would have had to recompile the entire application.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;For more information about Routing, check the &lt;a href=&#34;https://radu-matei.github.io/blog/aspnet-core-routing/&#34;&gt;ASP .NET Core Routing Tutorial&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Let&amp;rsquo;s assume that in our application we want the response messages not to be hardcoded in &lt;code&gt;Startup&lt;/code&gt; anymore, but stored in a configuration file so we don&amp;rsquo;t have to stop, modify or recompile our application every time the messages or the routes change.&lt;/p&gt;

&lt;p&gt;More clearly, we want to map the keys from the JSON file below as routes and the values as the responses we want our application to give, so when a user browses in our application to &lt;code&gt;/some-route&lt;/code&gt;, if &lt;code&gt;some-route&lt;/code&gt; is present in the JSON configuration file, then the response will be the value from the file, if else to display a default message.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
    &amp;quot;hi&amp;quot;: &amp;quot;Hi!&amp;quot;,
    &amp;quot;hello&amp;quot;: &amp;quot;Hello!&amp;quot;,
    &amp;quot;bye&amp;quot;: &amp;quot;Goodbye!&amp;quot;,
    &amp;quot;default&amp;quot;: &amp;quot;This is default!&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Also, if we modify the configuration file while the application is running, our application should be able to use the latest configuration. (As we will see, we will not have much to do here since this is built into ASP .NET).&lt;/p&gt;

&lt;p&gt;There can be any number of defined paths in our configuration file and they can change with any frequency (so that hard-coding them in our application is not an option).&lt;/p&gt;

&lt;h2 id=&#34;using-the-asp-net-core-json-configuration-provider&#34;&gt;Using the ASP .NET Core JSON Configuration Provider&lt;/h2&gt;

&lt;p&gt;As we said earlier, the new ASP .NET implements a JSON configuration provider that allows us to read and use configurations from JSON files (and not only), and we can have strong typing (where we define classes for our configuration settings) or we can access them using directly their key.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;For a complete article on creating &lt;a href=&#34;https://weblog.west-wind.com/posts/2016/May/23/Strongly-Typed-Configuration-Settings-in-ASPNET-Core&#34;&gt;Strongly Typed Configuration Settings in ASP .NET Core, see this article by Rick Strahl&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;To use configuration settings in ASP .NET Core, simply instantiate a &lt;code&gt;Configuration&lt;/code&gt; object (using a &lt;code&gt;ConfigurationBuilder&lt;/code&gt;)  and indicate the source of the JSON file. Then, we can add multiple sources and types of sources that populate our application&amp;rsquo;s configuration.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;At its simplest, &lt;code&gt;Configuration&lt;/code&gt; is just a collection of sources, which provide the ability to read and write name/value pairs. If a name/value pair is written to &lt;code&gt;Configuration&lt;/code&gt;, it is not persisted. This means that the written value will be lost when the sources are read again.&lt;/p&gt;

&lt;p&gt;Developers are not limited to using a single configuration source. In fact several may be set up together such that a default configuration is overridden by settings from another source if they are present.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://docs.asp.net/en/latest/fundamentals/configuration.html#using-the-built-in-sources&#34;&gt;The Official ASP .NET Core Documentation&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Because at the time when we write the application we can&amp;rsquo;t know the exact paths, we will not create stronyly-typed configurations but we will take the path from our application an check to see wether that path exists in our configuration file.&lt;/p&gt;

&lt;h2 id=&#34;building-the-configurable-greeting-service&#34;&gt;Building the configurable Greeting service&lt;/h2&gt;

&lt;p&gt;First of all, &lt;a href=&#34;https://radu-matei.github.io/blog/aspnet-core-startup/&#34;&gt;follow all the steps in order to create an ASP .NET Core application with a &lt;code&gt;Startup&lt;/code&gt; class from this tutorial&lt;/a&gt;, that means:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;create new app using &lt;code&gt;dotnet new&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;add the &lt;code&gt;&amp;quot;Microsoft.AspNetCore.Server.Kestrel&amp;quot;: &amp;quot;1.0.0&amp;quot;&lt;/code&gt; NuGet package&lt;/li&gt;
&lt;li&gt;add an empty &lt;code&gt;Startup&lt;/code&gt; class&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Then, we create a new file, &lt;code&gt;greetings.json&lt;/code&gt; in the same folder as our &lt;code&gt;Program.cs&lt;/code&gt;, &lt;code&gt;Startup.cs&lt;/code&gt; and &lt;code&gt;project.json&lt;/code&gt; files, where we add our custom routes and messages we want our application to respond with.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
    &amp;quot;hi&amp;quot;: &amp;quot;Hi!&amp;quot;,
    &amp;quot;hello&amp;quot;: &amp;quot;Hello!&amp;quot;,
    &amp;quot;bye&amp;quot;: &amp;quot;Goodbye!&amp;quot;,
    &amp;quot;default&amp;quot;: &amp;quot;This is default!&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we need to add another NuGet package, &lt;code&gt;&amp;quot;Microsoft.Extensions.Configuration.Json&amp;quot;: &amp;quot;1.0.0&amp;quot;&lt;/code&gt; that will contain the necessary methods for using JSON files as configuration.&lt;/p&gt;

&lt;p&gt;In &lt;code&gt;Startup&lt;/code&gt; we create a property of type &lt;code&gt;IConfiguration&lt;/code&gt; where we will keep our configuration files: &lt;code&gt;public IConfiguration Configuration {get;set;}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Then, we add a constructor for the &lt;code&gt;Startup&lt;/code&gt; class that will instantiate a &lt;code&gt;ConfigurationBuilder&lt;/code&gt; that will actually get the configuration information in our &lt;code&gt;Configuration&lt;/code&gt; property.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public Startup(IHostingEnvironment env)
    {
        var configurationBuilder = new ConfigurationBuilder()
            .SetBasePath(Directory.GetCurrentDirectory())
            .AddJsonFile(&amp;quot;greetings.json&amp;quot;, optional: false, reloadOnChange: true);
        
        Configuration = configurationBuilder.Build();
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;The constructor has an &lt;code&gt;IHostingEnvironment&lt;/code&gt; parameter that is used to establish the directory of the JSON configuration file. Since we placed it in the same folder as the other files, we can simply get the current directory: &lt;code&gt;Directory.GetCurrentDirectory()&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;After we instantiate the &lt;code&gt;ConfigurationBuilder&lt;/code&gt; we chain two method calls - one for establishing the directory of the configuration file, the other for determing the actual name of the file.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;.AddJsonFile()&lt;/code&gt; method takes three arguments in this case:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;the name of the file - in our case &lt;code&gt;greetings.json&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;a &lt;code&gt;bool&lt;/code&gt; that determines wether this configuration file is optional or not, used to determine the order in which the system searches the files (if there are multiple files) if the same configuration name exists in multiple files.&lt;/li&gt;
&lt;li&gt;a &lt;code&gt;bool&lt;/code&gt; that specifies what happens if the configuration file is modified while the application is running - &lt;code&gt;reloadOnChange&lt;/code&gt;
After this, we set our &lt;code&gt;Configuration&lt;/code&gt; property to what the &lt;code&gt;configurationBuilder&lt;/code&gt; &amp;ldquo;builds&amp;rdquo;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The next step is to add the &amp;ldquo;&lt;code&gt;Microsoft.AspNetCore.Routing&amp;quot;: &amp;quot;1.0.0&amp;quot;&lt;/code&gt; package in &lt;code&gt;project.json&lt;/code&gt;, create the &lt;code&gt;Configure&lt;/code&gt; method in &lt;code&gt;Startup&lt;/code&gt; and add the routing service.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public void ConfigureServices(IServiceCollection services)
    {
        services.AddRouting();
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;As you write code in Visual Studio or Visual Studio Code, you can press Ctrl + . (period) to show suggestions for errors (like adding &lt;code&gt;using&lt;/code&gt; statements for you).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Then, we create the &lt;code&gt;Configure&lt;/code&gt; method where we will hook up incoming requests and map them with the routes from our configuration file.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public void Configure(IApplicationBuilder app)
    {
        var routeBuilder = new RouteBuilder(app);

        routeBuilder.MapGet(&amp;quot;{route}&amp;quot;, context =&amp;gt; 
        {
            var routeMessage = Configuration.AsEnumerable()
                .FirstOrDefault(r =&amp;gt; r.Key == context.GetRouteValue(&amp;quot;route&amp;quot;)
                .ToString())
                .Value;
            
            var defaultMessage = Configuration.AsEnumerable()
                .FirstOrDefault(r =&amp;gt; r.Key == &amp;quot;default&amp;quot;)
                .Value;

            var response = (routeMessage != null) ? routeMessage : defaultMessage;

            return context.Response.WriteAsync(response);
        });

        app.UseRouter(routeBuilder.Build());
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We create a new &lt;code&gt;RouteBuilder&lt;/code&gt; and map a new GET &lt;code&gt;route&lt;/code&gt; in &lt;a href=&#34;https://radu-matei.github.io/blog/aspnet-core-routing/&#34;&gt;the same way as in this article&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;            var routeMessage = Configuration.AsEnumerable()
                .FirstOrDefault(r =&amp;gt; r.Key == context.GetRouteValue(&amp;quot;route&amp;quot;)
                .ToString())
                .Value;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We know that our configuration is now accessible through the &lt;code&gt;Configuration&lt;/code&gt; property that we populated in the &lt;code&gt;Startup&lt;/code&gt; constructor, and the configuration settings are an &lt;code&gt;IEnumerable&amp;lt;KeyValuePair&amp;lt;string, string&amp;gt;&amp;gt;&lt;/code&gt;, that is a collection of key-value pairs of strings, so we can use Linq to search for the key-value pair in our file that has the same key as our path and take the value from that pair.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;For some examples of using Linq with lambdas &lt;a href=&#34;http://www.codemag.com/article/1001051&#34;&gt;check this article from Code Magazine&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;We also search for the default message in our JSON so that if the path does not exist in the file, we have a standard respone.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;            var defaultMessage = Configuration.AsEnumerable()
                .FirstOrDefault(r =&amp;gt; r.Key == &amp;quot;default&amp;quot;)
                .Value;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then, depending on wether the route actually exists in our configuration file or not, we return either the message of that specific route, or the default message.&lt;/p&gt;

&lt;p&gt;This is the full &lt;code&gt;Startup&lt;/code&gt; class:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;using System.IO;
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Hosting;
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Configuration;
using Microsoft.AspNetCore.Routing;
using Microsoft.Extensions.DependencyInjection;
using System.Linq;

public class Startup
{
    public IConfiguration Configuration {get;set;}
    public Startup(IHostingEnvironment env)
    {
        var configurationBuilder = new ConfigurationBuilder()
            .SetBasePath(Directory.GetCurrentDirectory())
            .AddJsonFile(&amp;quot;greetings.json&amp;quot;, optional: false, reloadOnChange: true);
        
        Configuration = configurationBuilder.Build();
    }
    public void ConfigureServices(IServiceCollection services)
    {
        services.AddRouting();
    }
    public void Configure(IApplicationBuilder app)
    {
        var routeBuilder = new RouteBuilder(app);

        routeBuilder.MapGet(&amp;quot;{route}&amp;quot;, context =&amp;gt; 
        {
            var routeMessage = Configuration.AsEnumerable()
                .FirstOrDefault(r =&amp;gt; r.Key == context.GetRouteValue(&amp;quot;route&amp;quot;)
                .ToString())
                .Value;
            
            var defaultMessage = Configuration.AsEnumerable()
                .FirstOrDefault(r =&amp;gt; r.Key == &amp;quot;default&amp;quot;)
                .Value;

            var response = (routeMessage != null) ? routeMessage : defaultMessage;

            return context.Response.WriteAsync(response);
        });

        app.UseRouter(routeBuilder.Build());
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we run the application and open a browser, we can check if our routing works:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http://localhost:5000/hello - This should display Hello!
http://localhost:5000/hi - This should display Hi!
http://localhost:5000/bye - This should display Goodbye!
http://localhost:5000/default or http://localhost:5000/anything-else - This should display This is default!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Without closing the application, go to &lt;code&gt;greeting.json&lt;/code&gt; and either add a new key-value pair, or modify an existing one&amp;rsquo;s value, save the file and navigate to that path.&lt;/p&gt;

&lt;p&gt;Normally, you should see that our application was able to load the configuration file without restarting or recompiling.&lt;/p&gt;

&lt;h2 id=&#34;making-use-of-asp-net-core-dependency-injection&#34;&gt;Making use of ASP .NET Core Dependency Injection&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;So far, the examples we&amp;rsquo;ve had were pretty easy to understand, straightforward and olny relied on information that built upon the previous articles.
This example will be about dependency injection, something we haven&amp;rsquo;t discussed yet and will not be an introductory tutorial,  which will be a topic for a future article.&lt;/p&gt;

&lt;p&gt;The reason for doing this is to show how to build a still very simple application, but one that is a lot more configurable.&lt;/p&gt;

&lt;p&gt;Martin Fowler has written an extensive article on &lt;a href=&#34;http://martinfowler.com/articles/injection.html&#34;&gt;Inversion of Control Containers and the Dependency Injection Pattern&lt;/a&gt;. Microsoft Patterns and Practices also has a great description of &lt;a href=&#34;https://msdn.microsoft.com/en-us/library/dn178469(v=pandp.30).aspx&#34;&gt;Dependency Injection&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;For a more detailed view of dependency injection in ASP .NET Core applications, &lt;a href=&#34;https://docs.asp.net/en/latest/fundamentals/dependency-injection.html&#34;&gt;read the article from the Official ASP .NET Core Documentation&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Our application works, but there is a lot of logic code in &lt;code&gt;Startup&lt;/code&gt;, a place for configuration.&lt;/p&gt;

&lt;p&gt;We will try to extract the part of &lt;code&gt;Startup&lt;/code&gt; that deals with actually getting the response from the &lt;code&gt;JSON&lt;/code&gt; file in a separate class and learn how to inject that service in various places (like other services, controllers or even in &lt;code&gt;Startup&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;First of all, let&amp;rsquo;s think at what public methods and properties should a greeting service should have. Basically, it should only have a single method that receives the path a user navigated to and should return a string, the response taken from the JSON file.&lt;/p&gt;

&lt;p&gt;In order to make dependency injection work, we will make use of interfaces. Meaning we will build an interface for the greeting service, &lt;code&gt;IGreetingService&lt;/code&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;To see an example with interfaces, &lt;a href=&#34;https://github.com/microsoft-dx/csharp-fundamentals/tree/master/CSharpFundamentals/csharp09%20-%20Interfaces&#34;&gt;check this tutorial&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Let&amp;rsquo;s create a new file, &lt;code&gt;IGreetingService.cs&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public interface IGreetingService
{
    string Greet(string route);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, in another file, &lt;code&gt;GreetingService.cs&lt;/code&gt; we will add the actual implementation of the service:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;using System.Linq;
using Microsoft.Extensions.Configuration;

public class GreeringService : IGreetingService
{
    private IConfiguration Configuration {get;set;}

    public GreeringService(IConfiguration configuration)
    {
        Configuration = configuration;
    }
    public string Greet(string route)
    {
            var routeMessage = Configuration.AsEnumerable()
                .FirstOrDefault(r =&amp;gt; r.Key == route)
                .Value;
            
            var defaultMessage = Configuration.AsEnumerable()
                .FirstOrDefault(r =&amp;gt; r.Key == &amp;quot;default&amp;quot;)
                .Value;

            return (routeMessage != null) ? routeMessage : defaultMessage;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Basically, this class has the &lt;code&gt;Greet&lt;/code&gt; method which contains most of the logic we had in &lt;code&gt;Startup&lt;/code&gt; for retrieving  the response from the JSON file. It also has an &lt;code&gt;IConfiguration&lt;/code&gt; property, this time injected in the controller (we will see a bit later where and how this is done).&lt;/p&gt;

&lt;p&gt;Now let&amp;rsquo;s take a look at the &lt;code&gt;Startup&lt;/code&gt; class, this time at the &lt;code&gt;Configure&lt;/code&gt; method:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public void Configure(IApplicationBuilder app, IGreetingService greetingService)
    {
        var routeBuilder = new RouteBuilder(app);

        routeBuilder.MapGet(&amp;quot;{route}&amp;quot;, context =&amp;gt; 
        {
            var route = context.GetRouteValue(&amp;quot;route&amp;quot;).ToString();
            return context.Response.WriteAsync(greetingService.Greet(route));
        });

        app.UseRouter(routeBuilder.Build());
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The new thing here is that we have an &lt;code&gt;IGreetingService&lt;/code&gt; parameter in the method signature that we use when returning the message.&lt;/p&gt;

&lt;p&gt;Both the &lt;code&gt;IGreetingService&lt;/code&gt; and &lt;code&gt;IConfiguration&lt;/code&gt; parameters are configured in the &lt;code&gt;ConfigureServices&lt;/code&gt; method, also from &lt;code&gt;Startup&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public void ConfigureServices(IServiceCollection services)
    {
        services.AddRouting();

        services.Add(new ServiceDescriptor(typeof(IConfiguration), 
                     provider =&amp;gt; new ConfigurationBuilder()
                                    .SetBasePath(Directory.GetCurrentDirectory())
                                    .AddJsonFile(&amp;quot;greetings.json&amp;quot;, 
                                                 optional: false, 
                                                 reloadOnChange: true)
                                    .Build(), 
                     ServiceLifetime.Singleton));
                     
        services.AddTransient&amp;lt;IGreetingService, GreeringService&amp;gt;();
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;First of all we add the routing service (just like in the previous examples).&lt;/p&gt;

&lt;p&gt;The last line of this method states that every time some class requests a parameter of type &lt;code&gt;IGreetingService&lt;/code&gt;, the DI (dependency injection) engine will provide it with a new (every time a new) implementation of &lt;code&gt;GreetingService&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The second method call is the most difficult of all: it says that every time someone requests an &lt;code&gt;IConfiguration&lt;/code&gt; parameter, the engine should provide the same instance (singleton) generated by this chain of method calls:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; new ConfigurationBuilder()
    .SetBasePath(Directory.GetCurrentDirectory())
    .AddJsonFile(&amp;quot;greetings.json&amp;quot;, 
                 optional: false, 
                 reloadOnChange: true)
     .Build(), 

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which is the same as earlier.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s have a look at the complete &lt;code&gt;Startup&lt;/code&gt; class:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;using System.IO;
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Configuration;
using Microsoft.AspNetCore.Routing;
using Microsoft.Extensions.DependencyInjection;

public class Startup
{
    public void ConfigureServices(IServiceCollection services)
    {
        services.AddRouting();

        services.Add(new ServiceDescriptor(typeof(IConfiguration), 
                     provider =&amp;gt; new ConfigurationBuilder()
                                    .SetBasePath(Directory.GetCurrentDirectory())
                                    .AddJsonFile(&amp;quot;greetings.json&amp;quot;, 
                                                 optional: false, 
                                                 reloadOnChange: true)
                                    .Build(), 
                     ServiceLifetime.Singleton));
                     
        services.AddTransient&amp;lt;IGreetingService, GreeringService&amp;gt;();
    }
    public void Configure(IApplicationBuilder app, IGreetingService greetingService)
    {
        var routeBuilder = new RouteBuilder(app);

        routeBuilder.MapGet(&amp;quot;{route}&amp;quot;, context =&amp;gt; 
        {
            var route = context.GetRouteValue(&amp;quot;route&amp;quot;).ToString();
            return context.Response.WriteAsync(greetingService.Greet(route));
        });

        app.UseRouter(routeBuilder.Build());
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;We created a web application for which we configured the paths and the associated responses in an external JSON file. We ectracted this functionality in a service, &lt;code&gt;GreetingService&lt;/code&gt; that was provided using dependency injection.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ASP .NET Core Routing</title>
      <link>https://radu-matei.com/blog/aspnet-core-routing/</link>
      <pubDate>Wed, 20 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>https://radu-matei.com/blog/aspnet-core-routing/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;Table of Contents&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#&#34;&gt;Routing&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#introduction&#34;&gt;Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#installing-the-routing-package&#34;&gt;Installing the Routing package&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#adding-the-routing-service-in-startup&#34;&gt;Adding the Routing Service in Startup&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#adding-and-handling-custom-routes&#34;&gt;Adding and handling custom routes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#the-full-startup-class&#34;&gt;The full Startup class&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#conclusion&#34;&gt;Conclusion&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;routing&#34;&gt;Routing&lt;/h1&gt;

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;In the previous example we built a very simple web application that responded with &lt;code&gt;Hello, Universe&lt;/code&gt; and the current server time for every request.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;When the application is running and you navigate to &lt;a href=&#34;http://localhost5000&#34;&gt;http://localhost5000&lt;/a&gt;, regardless of the path followed (&lt;a href=&#34;http://localhost:5000/something/something-else/etc&#34;&gt;http://localhost:5000/something/something-else/etc&lt;/a&gt;), the response is the same.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;However, any real-world application is going to need a more complex way of handling requests, so in this article we will see how to create route handlers for specific routes and how to extract parameters from the request URI.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The best place to start learning about Routing is the &lt;a href=&#34;https://docs.asp.net/en/latest/fundamentals/routing.html&#34;&gt;Official ASP .NET Core Documentation&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Since we haven&amp;rsquo;t started talking about MVC, the routing discussed here will not include any MVC-specific routing on controllers, actions or parameters, but routing done using &lt;a href=&#34;https://docs.asp.net/en/latest/fundamentals/routing.html#using-routing-middleware&#34;&gt;Routing Middleware&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;installing-the-routing-package&#34;&gt;Installing the &lt;code&gt;Routing&lt;/code&gt; package&lt;/h2&gt;

&lt;p&gt;First of all, we need to add the &lt;code&gt;Microsoft.AspNetCore.Routing&lt;/code&gt; dependency from NuGet.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      &amp;quot;dependencies&amp;quot;: {
        &amp;quot;Microsoft.NETCore.App&amp;quot;: {
          &amp;quot;type&amp;quot;: &amp;quot;platform&amp;quot;,
          &amp;quot;version&amp;quot;: &amp;quot;1.0.0&amp;quot;
        },
        &amp;quot;Microsoft.AspNetCore.Server.Kestrel&amp;quot;: &amp;quot;1.0.0&amp;quot;,
        &amp;quot;Microsoft.AspNetCore.Routing&amp;quot;: &amp;quot;1.0.0&amp;quot;
      }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is how the &lt;code&gt;dependencies&lt;/code&gt; node of &lt;code&gt;project.json&lt;/code&gt; should look like.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The difference form the &lt;a href=&#34;https://github.com/radu-matei/blog-content/blob/master/articles/aspnet-core-startup.md#building-the-hello-world-web-application-with-startup&#34;&gt;previous example&lt;/a&gt; is just the addition of the &lt;code&gt;Routing&lt;/code&gt; package.&lt;/p&gt;

&lt;p&gt;From now on, when adding a new dependency from NuGet the full &lt;code&gt;project.json&lt;/code&gt; will not be shown anymore, but only the new package added.&lt;/p&gt;

&lt;p&gt;At the time of writing this article, the latest version for all ASP .NET Core libraries is &lt;code&gt;1.0.0&lt;/code&gt;. As newer versions are released, check the release notes to see if there are any breaking changes when updating packages.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;adding-the-routing-service-in-startup&#34;&gt;Adding the &lt;code&gt;Routing&lt;/code&gt; Service in &lt;code&gt;Startup&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;When we discussed &lt;a href=&#34;https://github.com/radu-matei/blog-content/blob/master/articles/aspnet-core-startup.md#the-anatomy-of-the-startup-class&#34;&gt;the anatomy of the &lt;code&gt;Startup&lt;/code&gt; class&lt;/a&gt;, besides the &lt;code&gt;Configure&lt;/code&gt; method we have used before, there was also a method called &lt;code&gt;ConfigureServices&lt;/code&gt; used for configuring services that our application needs.&lt;/p&gt;

&lt;p&gt;Since we are going to use Routing, we should add it as a service in &lt;code&gt;Startup&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public void ConfigureServices(IServiceCollection services)
    {
        services.AddRouting();
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;adding-and-handling-custom-routes&#34;&gt;Adding and handling custom routes&lt;/h2&gt;

&lt;p&gt;First of all, in the &lt;code&gt;Configure&lt;/code&gt; method from &lt;code&gt;Startup&lt;/code&gt; we need to instantiate a new instance of the &lt;code&gt;RouteBuilder&lt;/code&gt; class that will allow us to build custom routes and handle them.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var routeBuilder = new RouteBuilder(app);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We will then use this instance to map requests to to specific paths with our request handlers, allowing us to handle&lt;code&gt;GET&lt;/code&gt; and &lt;code&gt;POST&lt;/code&gt; requests from clients.&lt;/p&gt;

&lt;p&gt;The way to map a &lt;code&gt;GET&lt;/code&gt; request is to use the &lt;code&gt;MapGet&lt;/code&gt; method from &lt;code&gt;RouteBuilder&lt;/code&gt;. Mapping the application root - &lt;a href=&#34;http://localhost:5000&#34;&gt;http://localhost:5000&lt;/a&gt; is done through:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;routeBuilder.MapGet(&amp;quot;&amp;quot;, context =&amp;gt; context.Response.WriteAsync(&amp;quot;Hello from root!&amp;quot;));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Mapping specific paths for &lt;code&gt;GET&lt;/code&gt; - for example &lt;a href=&#34;http://localhost:5000/hello&#34;&gt;http://localhost:5000/hello&lt;/a&gt; is done in the following way.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;routeBuilder.MapGet(&amp;quot;hello&amp;quot;, context =&amp;gt; context.Response.WriteAsync(&amp;quot;Hello from /hello&amp;quot;));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can create paths that contain multiple elements and we can extract the parameters entered when making the request. For example, when requesting on &lt;code&gt;hello/{name}&lt;/code&gt;, we can extract the parameter &lt;code&gt;{name}&lt;/code&gt; and use it when constructing the response:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;routeBuilder.MapGet(&amp;quot;hello/{name}&amp;quot;, context =&amp;gt; context.Response
                                                      .WriteAsync($&amp;quot;Hello, {context.GetRouteValue(&amp;quot;name&amp;quot;)}&amp;quot;));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can also add constrains on the parameters. For example, let&amp;rsquo;s create a respond for requests coming to the path &lt;code&gt;/square/{number}&lt;/code&gt;, where &lt;code&gt;{number}&lt;/code&gt; is an &lt;code&gt;int&lt;/code&gt; and responds with the square of the number.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;routeBuilder.MapGet(&amp;quot;square/{number:int}&amp;quot;, context =&amp;gt;
        {
            int number = Convert.ToInt32(context.GetRouteValue(&amp;quot;number&amp;quot;));
            return context.Response.WriteAsync($&amp;quot;The square of {number} is {number * number}&amp;quot;);
        });
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;For a full list of parameter constraints, see this table from &lt;a href=&#34;https://docs.asp.net/en/latest/fundamentals/routing.html#id7&#34;&gt;the Official ASP .NET Core Documentation&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In order to test wether the routing works properly, open a browser and navigate to your custom route and check if the output is the desired one.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;You can also place some breakpoint inside the custom route handlers and iterate through the handlers step-by-step, watching how the response is formed.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;http://localhost:5000
http://localhost:5000/hello
http://localhost:5000/hello/John
http://localhost:5000/square/3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So far we only created routing mapped for the &lt;code&gt;GET&lt;/code&gt; method, so we can test the output from a browser tab.
Now we will add routing for a &lt;code&gt;POST&lt;/code&gt; method (so we will not be able to test it by navigating to the URL in the browser).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;routeBuilder.MapPost(&amp;quot;post&amp;quot;, context =&amp;gt; context.Response.WriteAsync(&amp;quot;Posting!&amp;quot;));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In order to test this route, we need to use a tool that sends &lt;code&gt;HTTP&lt;/code&gt; requests to our application. We will use &lt;a href=&#34;https://chrome.google.com/webstore/detail/postman/fhbjgbiflinjbdggehcddcbncdddomop&#34;&gt;PostMan for Google Chrome&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/aspnet-core-routing/routing-postman.JPG&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If we try and change the method type in PostMan from &lt;code&gt;POST&lt;/code&gt; to &lt;code&gt;GET&lt;/code&gt;, we notice how the request fails.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;the-full-startup-class&#34;&gt;The full &lt;code&gt;Startup&lt;/code&gt; class&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;using System;
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Routing;
using Microsoft.Extensions.DependencyInjection;

public class Startup
{
    public void Configure(IApplicationBuilder app)
    {
        
        var routeBuilder = new RouteBuilder(app);
        
        routeBuilder.MapGet(&amp;quot;&amp;quot;, context =&amp;gt; context.Response.WriteAsync(&amp;quot;Hello from root!&amp;quot;));
        routeBuilder.MapGet(&amp;quot;hello&amp;quot;, context =&amp;gt; context.Response.WriteAsync(&amp;quot;Hello from /hello&amp;quot;));
        routeBuilder.MapGet(&amp;quot;hello/{name}&amp;quot;, context =&amp;gt; context.Response
                                                              .WriteAsync($&amp;quot;Hello, {context.GetRouteValue(&amp;quot;name&amp;quot;)}&amp;quot;));

        routeBuilder.MapGet(&amp;quot;square/{number:int}&amp;quot;, context =&amp;gt;
        {
            int number = Convert.ToInt32(context.GetRouteValue(&amp;quot;number&amp;quot;));
            return context.Response.WriteAsync($&amp;quot;The square of {number} is {number * number}&amp;quot;);
        });

        routeBuilder.MapPost(&amp;quot;post&amp;quot;, context =&amp;gt; context.Response.WriteAsync(&amp;quot;Posting!&amp;quot;));

        app.UseRouter(routeBuilder.Build());

    }

    public void ConfigureServices(IServiceCollection services)
    {
        services.AddRouting();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;We created a basic web application and we defined and handled custom routes. We also saw how to manage &lt;code&gt;GET&lt;/code&gt; and &lt;code&gt;POST&lt;/code&gt; requests.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>