<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Radu Matei - Developer Evangelist</title>
    <link>http://radu-matei.github.io/</link>
    <description>Recent content on Radu Matei - Developer Evangelist</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 05 Aug 2016 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://radu-matei.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Introduction to ASP .NET Core MVC API</title>
      <link>http://radu-matei.github.io/blog/aspnet-core-api/</link>
      <pubDate>Fri, 05 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>http://radu-matei.github.io/blog/aspnet-core-api/</guid>
      <description>

&lt;h2 id=&#34;table-of-content&#34;&gt;Table of Content&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#introduction&#34;&gt;Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#adding-the-mvc-services-to-our-application&#34;&gt;Adding the MVC services to our application&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#adding-the-post-class&#34;&gt;Adding the &lt;code&gt;Post&lt;/code&gt; class&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#creating-an-ipostrepository-interface&#34;&gt;Creating an &lt;code&gt;IPostRepository&lt;/code&gt; interface&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#creating-an-in-memory-implementation-of-ipostrepository&#34;&gt;Creating an in-memory implementation of &lt;code&gt;IPostRepository&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#the-postcontroller-class&#34;&gt;The &lt;code&gt;PostController&lt;/code&gt; class&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#registering-the-repository-service-in-startup&#34;&gt;Registering the repository service in &lt;code&gt;Startup&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#startup-cs&#34;&gt;&lt;code&gt;Startup.cs&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#testing-the-application&#34;&gt;Testing the application&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#conclusion&#34;&gt;Conclusion&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;Up to this point, we have been learning about &lt;a href=&#34;https://radu-matei.github.io/blog/dot-net-core-introduction/&#34;&gt;.NET Core&lt;/a&gt; and &lt;a href=&#34;https://radu-matei.github.io/blog/dot-net-core-getting-started/&#34;&gt;VS Code&lt;/a&gt;, about &lt;a href=&#34;https://radu-matei.github.io/blog/aspnet-core-getting-started/&#34;&gt;ASP .NET Core&lt;/a&gt;, the &lt;a href=&#34;https://radu-matei.github.io/blog/aspnet-core-startup/&#34;&gt;&lt;code&gt;Startup&lt;/code&gt; class&lt;/a&gt;, &lt;a href=&#34;https://radu-matei.github.io/blog/aspnet-core-routing/&#34;&gt;Routing&lt;/a&gt; and &lt;a href=&#34;https://radu-matei.github.io/blog/aspnet-core-configuration-greeting/&#34;&gt;how to use JSON Configuration&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In this article we will be looking at ASP .NET Core MVC, more specifically at how to build an API that can be consumed from any type of application, be it web, mobile or desktop.&lt;/p&gt;

&lt;p&gt;We will build a very simple application that will enable the creation of posts (much like messages) and that will take us through adding the MVC services, creating models, controllers and consuming some data.&lt;/p&gt;

&lt;p&gt;We will start this article by building on the code form the &lt;a href=&#34;https://radu-matei.github.io/blog/aspnet-core-startup/&#34;&gt;Startup class&lt;/a&gt; tutorial.&lt;/p&gt;

&lt;h2 id=&#34;adding-the-mvc-services-to-our-application&#34;&gt;Adding the MVC services to our application&lt;/h2&gt;

&lt;p&gt;The first thing we have to do is add the &lt;code&gt;&amp;quot;Microsoft.AspNetCore.Mvc&amp;quot;: &amp;quot;1.0.0&amp;quot;&lt;/code&gt; dependency in &lt;code&gt;project.json&lt;/code&gt;, then add the &lt;code&gt;ConfigureServices&lt;/code&gt; method in the &lt;code&gt;Startup&lt;/code&gt; class.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public void ConfigureServices(IServiceCollection services)
    {
        services.AddMvc();
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we have to register some routes for the incoming requests, in this case, any incoming requests that match &lt;code&gt;/api/{controller}/{action}/{id?}&lt;/code&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;{controller}&lt;/code&gt; - the name of the controller (for example, &lt;code&gt;TestController&lt;/code&gt; - &lt;code&gt;/api/test&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;&lt;code&gt;{action}&lt;/code&gt; - the name of the method from the controller&lt;/p&gt;

&lt;p&gt;&lt;code&gt;{id?}&lt;/code&gt; - optional parameter passed to the method&lt;/p&gt;

&lt;p&gt;So a request for &lt;code&gt;/api/test/hello/3&lt;/code&gt; will be mapped to &lt;code&gt;TestController&lt;/code&gt; in the &lt;code&gt;Hello&lt;/code&gt; method which will have 3 as parameter for &lt;code&gt;id&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;    public void Configure(IApplicationBuilder app)
    {
        app.UseMvc(routes =&amp;gt;
        {
            routes.MapRoute(
                name: &amp;quot;default&amp;quot;,
                template: &amp;quot;api/{controller}/{action}/{id?}&amp;quot;
            );
        });
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Note that you can customize your route template in any way, I chose the &lt;code&gt;/api&lt;/code&gt; option because in previous versions of ASP .NET (Web Api) this was the default route for creating an API.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;At this point, we can add a controller and make some requests to test our framework. So let&amp;rsquo;s add a controller, I will call it &lt;code&gt;PostsController&lt;/code&gt; and it will have a very simple method that will return a &lt;code&gt;string&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;using Microsoft.AspNetCore.Mvc;

public class PostsController : Controller
{
    public string Hello()
    {
        return &amp;quot;Hello from MVC!&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To run the application, execute &lt;code&gt;dotnet restore&lt;/code&gt; and &lt;code&gt;dotnet run&lt;/code&gt; in the root of the project and browse to &lt;code&gt;http://localhost:5000/api/Posts/Hello&lt;/code&gt;. If everyting works, you should see the message received from the controller.&lt;/p&gt;

&lt;h2 id=&#34;adding-the-post-class&#34;&gt;Adding the &lt;code&gt;Post&lt;/code&gt; class&lt;/h2&gt;

&lt;p&gt;As we said earlier, each user that enters can publish a post containing his user name and a text, so our &lt;code&gt;Post&lt;/code&gt; class only contains two properties for the &lt;code&gt;UserName&lt;/code&gt; and &lt;code&gt;Text&lt;/code&gt; of the post and an &lt;code&gt;Id&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public class Post
    {
        public int Id { get; set; }
        public string UserName { get; set; }
        public string Text { get; set; }

        public Post(int id, string userName, string text)
        {
            Id = id;
            UserName = userName;
            Text = text;
        }

        public Post()
        {
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There is also a parameterless constructor and a constructor that takes arguments the three properties.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If you add a constructor in a C# class, the compiler will no longer create the default parameterless constructor, and JSON serialization needs a parameterless constructor when serializing and deserializing objects.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;creating-an-ipostrepository-interface&#34;&gt;Creating an &lt;code&gt;IPostRepository&lt;/code&gt; interface&lt;/h2&gt;

&lt;p&gt;In order for our API to work, we are going to need a way for it to store data. Regardless of where that data is going to be stored, there should be a consistent way of reading and writing, and we will achieve this through an interface, &lt;code&gt;IPostRepository&lt;/code&gt;, that will expose the minimum necessary methods: a method to read all posts, a method to add a post and a method to retrieve a post with a specified id.&lt;/p&gt;

&lt;p&gt;So the interface should look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;using System.Collections.Generic;

public interface IPostRepository
{
    List&amp;lt;Post&amp;gt; GetAll();
    Post GetPost(int id);
    void AddPost(Post post);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since this is a very simple example, we are going to store the data in a list in memory, but regardless of the location, the publicly available methods will be exactly the same, making any modifications to the data store easy to implement (more on this later).&lt;/p&gt;

&lt;h2 id=&#34;creating-an-in-memory-implementation-of-ipostrepository&#34;&gt;Creating an in-memory implementation of &lt;code&gt;IPostRepository&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;We will implement the &lt;code&gt;IPostRepository&lt;/code&gt; interface through an in-memory class we will call &lt;code&gt;PostRepository&lt;/code&gt; that will hold the data in a list.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    private List&amp;lt;Post&amp;gt; _posts = new List&amp;lt;Post&amp;gt;()
    {
        new Post(1, &amp;quot;Obi-Wan Kenobi&amp;quot;,&amp;quot;These are not the droids you&#39;re looking for&amp;quot;),
        new Post(2, &amp;quot;Darth Vader&amp;quot;,&amp;quot;I find your lack of faith disturbing&amp;quot;)
    };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since we have the three methods to access the data, there is no need to expose the post list outside the class, so it will be private. Besides the list, we only need to implement the three methods from the interface, so here is the full &lt;code&gt;PostRepository&lt;/code&gt; class:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;using System.Collections.Generic;
using System.Linq;

public class PostRepository : IPostRepository
{
    private List&amp;lt;Post&amp;gt; _posts = new List&amp;lt;Post&amp;gt;()
    {
        new Post(1, &amp;quot;Obi-Wan Kenobi&amp;quot;,&amp;quot;These are not the droids you&#39;re looking for&amp;quot;),
        new Post(2, &amp;quot;Darth Vader&amp;quot;,&amp;quot;I find your lack of faith disturbing&amp;quot;)
    };
    public void AddPost(Post post)
    {
        _posts.Add(post);
    }

    public List&amp;lt;Post&amp;gt; GetAll()
    {
        return _posts;
    }

    public Post GetPost(int id)
    {
        return _posts.FirstOrDefault(p =&amp;gt; p.Id == id);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;the-postcontroller-class&#34;&gt;The &lt;code&gt;PostController&lt;/code&gt; class&lt;/h2&gt;

&lt;p&gt;ASP .NET (MVC Core and other versions) maps requests to classes called controllers that are responsible for processing incoming requests, handling user input and generating the response (by themselves or by calling other services).&lt;/p&gt;

&lt;p&gt;We will create a very simple &lt;code&gt;PostController&lt;/code&gt;  that will have methods to get all posts, add a post and retrieve a single post based on the id.&lt;/p&gt;

&lt;p&gt;The controller will have some instance of &lt;code&gt;IPostRepository&lt;/code&gt;(we will see shortly how it will have it) and will call methods from the repository.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;using System.Collections.Generic;
using Microsoft.AspNetCore.Mvc;

public class PostsController : Controller
{
    private IPostRepository _postRepository { get; set; }

    public PostsController(IPostRepository postRepository)
    {
        _postRepository = postRepository;
    }

    public List&amp;lt;Post&amp;gt; GetPosts()
    {
        return _postRepository.GetAll();
    }

    public Post GetPost(int id)
    {
        return _postRepository.GetPost(id);
    }

    public void AddPost([FromBody]Post post)
    {
        _postRepository.AddPost(post);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Notice how the &lt;code&gt;AddPost&lt;/code&gt; method accepts a &lt;code&gt;Post&lt;/code&gt; parameter. Because it has the &lt;code&gt;FromBody&lt;/code&gt; attribute, the framework will automatically try to map the body of the request to an object of type &lt;code&gt;Post&lt;/code&gt; that is deserialized from JSON.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Besides from the publicly exposed methods of the API (any public method placed in a controller is publicly accessible from the web), we also have a constructor through which we can provide the appropriate implementation of &lt;code&gt;IPostRepository&lt;/code&gt; and we will specify this in the &lt;code&gt;Startup&lt;/code&gt; of our application.&lt;/p&gt;

&lt;h2 id=&#34;registering-the-repository-service-in-startup&#34;&gt;Registering the repository service in &lt;code&gt;Startup&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;So far, we have created an &lt;code&gt;IPostRepostitory&lt;/code&gt; interface, implemented it in &lt;code&gt;PostRepository&lt;/code&gt; and used it in &lt;code&gt;PostController&lt;/code&gt;(without creating any instance). So if we ran the application right now and navigated to &lt;code&gt;http://localhost:5000/api/Posts/GetPosts&lt;/code&gt; we would get a null reference exception simply because we haven&amp;rsquo;t specified what instance of &lt;code&gt;IPostRepository&lt;/code&gt; our application is supposed to use.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public void ConfigureServices(IServiceCollection services)
    {
        services.AddMvc();
        services.AddSingleton&amp;lt;IPostRepository, PostRepository&amp;gt;();
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We only need to specify that whenever someone needs an &lt;code&gt;IPostRepository&lt;/code&gt;, the framework should provide them (the same) instance of &lt;code&gt;PostRepository&lt;/code&gt;. So when the &lt;code&gt;PostController&lt;/code&gt; constructor has a parameter of type &lt;code&gt;IPostRepository&lt;/code&gt;, the framework will provide an instance of &lt;code&gt;PostRepository&lt;/code&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;We added the repository as singleton because of the in-memory impementation: if we made a new instance of &lt;code&gt;PostRepository&lt;/code&gt; for every request, then the post list would be instantiated every time, not saving the modifications.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;startup-cs&#34;&gt;&lt;code&gt;Startup.cs&lt;/code&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;using Microsoft.AspNetCore.Builder;
using Microsoft.Extensions.DependencyInjection;

public class Startup
{
    public void ConfigureServices(IServiceCollection services)
    {
        services.AddMvc();
        services.AddSingleton&amp;lt;IPostRepository, PostRepository&amp;gt;();
    }

    public void Configure(IApplicationBuilder app)
    {
        app.UseMvc(routes =&amp;gt;
        {
            routes.MapRoute(
                name: &amp;quot;default&amp;quot;,
                template: &amp;quot;api/{controller}/{action}/{id?}&amp;quot;
            );
        });
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;testing-the-application&#34;&gt;Testing the application&lt;/h2&gt;

&lt;p&gt;At this point, we can either execute &lt;code&gt;dotnet run&lt;/code&gt; in the root of our project or press &lt;code&gt;F5&lt;/code&gt; in Visual Studio Code.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;We will use &lt;a href=&#34;https://chrome.google.com/webstore/detail/postman/fhbjgbiflinjbdggehcddcbncdddomop&#34;&gt;PostMan for Google Chrome&lt;/a&gt; in order to test the functionality of our API.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;If we open PostMan and create a GET request to &lt;code&gt;http://localhost:5000/api/Posts/GetPosts&lt;/code&gt;, we will see the two posts that we used to populate the list in &lt;code&gt;PostRepository&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://radu-matei.github.io/img/article-photos/aspnet-core-api/aspnet-core-api-postman-get.JPG&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;We can see that the response was JSON and it returned a 200 OK HTML code.&lt;/p&gt;

&lt;p&gt;In order to test the post functionality, we create a POST request to &lt;code&gt;http://localhost:5000/api/Posts/AddPost&lt;/code&gt; with a JSON object containing the properties of a &lt;code&gt;Post&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
    &amp;quot;Id&amp;quot;: 3,
    &amp;quot;UserName&amp;quot;: &amp;quot;Darth Vader&amp;quot;,
    &amp;quot;Text&amp;quot;: &amp;quot;Luke, I am your father!r&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;You can either use the upper camel case or the lower camel case notation (as you saw in the response from the server, the objects were in lower camel case), but the name and type of the properties must match the ones on the server:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;  {
    &amp;quot;id&amp;quot;: 3,
    &amp;quot;userName&amp;quot;: &amp;quot;Darth Vader&amp;quot;,
    &amp;quot;text&amp;quot;: &amp;quot;Luke, I am your father!r&amp;quot;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://radu-matei.github.io/img/article-photos/aspnet-core-api/aspnet-core-api-postman-post.JPG&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Now, if we create another request to &lt;code&gt;http://localhost:5000/api/Posts/GetPosts&lt;/code&gt; we can see that the post we added was saved.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://radu-matei.github.io/img/article-photos/aspnet-core-api/aspnet-core-api-postman-get-posts.JPG&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;So far we created an API that adds and reads posts from an in-memory data store. A real-life application would have a different type of data store (SQL/NoSQL database) and most certainly an application that consumes this data rather than using it from PostMan.&lt;/p&gt;

&lt;p&gt;This API can be consumed from a web application (HTML + JavaScript), a mobile application (virtually any type of mobile application, regardless of the OS), a desktop application (again, any type of desktop application for any OS), even console applications.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ASP .NET Core JSON Configuration and Dependency Injection</title>
      <link>http://radu-matei.github.io/blog/aspnet-core-configuration-greeting/</link>
      <pubDate>Sat, 23 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>http://radu-matei.github.io/blog/aspnet-core-configuration-greeting/</guid>
      <description>

&lt;h2 id=&#34;table-of-content&#34;&gt;Table of Content&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#introduction&#34;&gt;Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#using-the-asp-net-core-json-configuration-provider&#34;&gt;Using the ASP .NET Core JSON Configuration Provider&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#building-the-configurable-greeting-service&#34;&gt;Building the configurable Greeting service&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#making-use-of-asp-net-core-dependency-injection&#34;&gt;Making use of ASP .NET Core Dependency Injection&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#conclusion&#34;&gt;Conclusion&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;In the previous versions of ASP .NET, any configuration setting or parameter you needed was added in &lt;code&gt;web.config&lt;/code&gt; &lt;a href=&#34;http://www.codeproject.com/Articles/301726/Web-config-File-ASP-NET&#34;&gt;(complete description of the old &lt;code&gt;web.config&lt;/code&gt; file)&lt;/a&gt;, or added in a separate XML file and referenced in &lt;code&gt;web.config&lt;/code&gt; (for scenarios like database connection strings, or storing APIs access tokens).&lt;/p&gt;

&lt;p&gt;The new configuration system provides support for JSON, XML, INI and for in-memory configuration, while also allowing you to &lt;a href=&#34;https://docs.asp.net/en/latest/fundamentals/configuration.html#custom-config-providers&#34;&gt;create your custom configuration provider&lt;/a&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;For a detailed view of ASP .NET Core Configuration system, read the &lt;a href=&#34;https://docs.asp.net/en/latest/fundamentals/configuration.html&#34;&gt;Official ASP .NET Documentation&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;https://radu-matei.github.io/blog/aspnet-core-routing/&#34;&gt;In the tutorial about Routing&lt;/a&gt;, we created a very simple web application that used the Routing service to respond to some requests, but they were hardcoded and if we wanted to change the response message, we would have had to recompile the entire application.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;For more information about Routing, check the &lt;a href=&#34;https://radu-matei.github.io/blog/aspnet-core-routing/&#34;&gt;ASP .NET Core Routing Tutorial&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Let&amp;rsquo;s assume that in our application we want the response messages not to be hardcoded in &lt;code&gt;Startup&lt;/code&gt; anymore, but stored in a configuration file so we don&amp;rsquo;t have to stop, modify or recompile our application every time the messages or the routes change.&lt;/p&gt;

&lt;p&gt;More clearly, we want to map the keys from the JSON file below as routes and the values as the responses we want our application to give, so when a user browses in our application to &lt;code&gt;/some-route&lt;/code&gt;, if &lt;code&gt;some-route&lt;/code&gt; is present in the JSON configuration file, then the response will be the value from the file, if else to display a default message.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
    &amp;quot;hi&amp;quot;: &amp;quot;Hi!&amp;quot;,
    &amp;quot;hello&amp;quot;: &amp;quot;Hello!&amp;quot;,
    &amp;quot;bye&amp;quot;: &amp;quot;Goodbye!&amp;quot;,
    &amp;quot;default&amp;quot;: &amp;quot;This is default!&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Also, if we modify the configuration file while the application is running, our application should be able to use the latest configuration. (As we will see, we will not have much to do here since this is built into ASP .NET).&lt;/p&gt;

&lt;p&gt;There can be any number of defined paths in our configuration file and they can change with any frequency (so that hard-coding them in our application is not an option).&lt;/p&gt;

&lt;h2 id=&#34;using-the-asp-net-core-json-configuration-provider&#34;&gt;Using the ASP .NET Core JSON Configuration Provider&lt;/h2&gt;

&lt;p&gt;As we said earlier, the new ASP .NET implements a JSON configuration provider that allows us to read and use configurations from JSON files (and not only), and we can have strong typing (where we define classes for our configuration settings) or we can access them using directly their key.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;For a complete article on creating &lt;a href=&#34;https://weblog.west-wind.com/posts/2016/May/23/Strongly-Typed-Configuration-Settings-in-ASPNET-Core&#34;&gt;Strongly Typed Configuration Settings in ASP .NET Core, see this article by Rick Strahl&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;To use configuration settings in ASP .NET Core, simply instantiate a &lt;code&gt;Configuration&lt;/code&gt; object (using a &lt;code&gt;ConfigurationBuilder&lt;/code&gt;)  and indicate the source of the JSON file. Then, we can add multiple sources and types of sources that populate our application&amp;rsquo;s configuration.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;At its simplest, &lt;code&gt;Configuration&lt;/code&gt; is just a collection of sources, which provide the ability to read and write name/value pairs. If a name/value pair is written to &lt;code&gt;Configuration&lt;/code&gt;, it is not persisted. This means that the written value will be lost when the sources are read again.&lt;/p&gt;

&lt;p&gt;Developers are not limited to using a single configuration source. In fact several may be set up together such that a default configuration is overridden by settings from another source if they are present.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://docs.asp.net/en/latest/fundamentals/configuration.html#using-the-built-in-sources&#34;&gt;The Official ASP .NET Core Documentation&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Because at the time when we write the application we can&amp;rsquo;t know the exact paths, we will not create stronyly-typed configurations but we will take the path from our application an check to see wether that path exists in our configuration file.&lt;/p&gt;

&lt;h2 id=&#34;building-the-configurable-greeting-service&#34;&gt;Building the configurable Greeting service&lt;/h2&gt;

&lt;p&gt;First of all, &lt;a href=&#34;https://radu-matei.github.io/blog/aspnet-core-startup/&#34;&gt;follow all the steps in order to create an ASP .NET Core application with a &lt;code&gt;Startup&lt;/code&gt; class from this tutorial&lt;/a&gt;, that means:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;create new app using &lt;code&gt;dotnet new&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;add the &lt;code&gt;&amp;quot;Microsoft.AspNetCore.Server.Kestrel&amp;quot;: &amp;quot;1.0.0&amp;quot;&lt;/code&gt; NuGet package&lt;/li&gt;
&lt;li&gt;add an empty &lt;code&gt;Startup&lt;/code&gt; class&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Then, we create a new file, &lt;code&gt;greetings.json&lt;/code&gt; in the same folder as our &lt;code&gt;Program.cs&lt;/code&gt;, &lt;code&gt;Startup.cs&lt;/code&gt; and &lt;code&gt;project.json&lt;/code&gt; files, where we add our custom routes and messages we want our application to respond with.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
    &amp;quot;hi&amp;quot;: &amp;quot;Hi!&amp;quot;,
    &amp;quot;hello&amp;quot;: &amp;quot;Hello!&amp;quot;,
    &amp;quot;bye&amp;quot;: &amp;quot;Goodbye!&amp;quot;,
    &amp;quot;default&amp;quot;: &amp;quot;This is default!&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we need to add another NuGet package, &lt;code&gt;&amp;quot;Microsoft.Extensions.Configuration.Json&amp;quot;: &amp;quot;1.0.0&amp;quot;&lt;/code&gt; that will contain the necessary methods for using JSON files as configuration.&lt;/p&gt;

&lt;p&gt;In &lt;code&gt;Startup&lt;/code&gt; we create a property of type &lt;code&gt;IConfiguration&lt;/code&gt; where we will keep our configuration files: &lt;code&gt;public IConfiguration Configuration {get;set;}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Then, we add a constructor for the &lt;code&gt;Startup&lt;/code&gt; class that will instantiate a &lt;code&gt;ConfigurationBuilder&lt;/code&gt; that will actually get the configuration information in our &lt;code&gt;Configuration&lt;/code&gt; property.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public Startup(IHostingEnvironment env)
    {
        var configurationBuilder = new ConfigurationBuilder()
            .SetBasePath(Directory.GetCurrentDirectory())
            .AddJsonFile(&amp;quot;greetings.json&amp;quot;, optional: false, reloadOnChange: true);
        
        Configuration = configurationBuilder.Build();
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;The constructor has an &lt;code&gt;IHostingEnvironment&lt;/code&gt; parameter that is used to establish the directory of the JSON configuration file. Since we placed it in the same folder as the other files, we can simply get the current directory: &lt;code&gt;Directory.GetCurrentDirectory()&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;After we instantiate the &lt;code&gt;ConfigurationBuilder&lt;/code&gt; we chain two method calls - one for establishing the directory of the configuration file, the other for determing the actual name of the file.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;.AddJsonFile()&lt;/code&gt; method takes three arguments in this case:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;the name of the file - in our case &lt;code&gt;greetings.json&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;a &lt;code&gt;bool&lt;/code&gt; that determines wether this configuration file is optional or not, used to determine the order in which the system searches the files (if there are multiple files) if the same configuration name exists in multiple files.&lt;/li&gt;
&lt;li&gt;a &lt;code&gt;bool&lt;/code&gt; that specifies what happens if the configuration file is modified while the application is running - &lt;code&gt;reloadOnChange&lt;/code&gt;
After this, we set our &lt;code&gt;Configuration&lt;/code&gt; property to what the &lt;code&gt;configurationBuilder&lt;/code&gt; &amp;ldquo;builds&amp;rdquo;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The next step is to add the &amp;ldquo;&lt;code&gt;Microsoft.AspNetCore.Routing&amp;quot;: &amp;quot;1.0.0&amp;quot;&lt;/code&gt; package in &lt;code&gt;project.json&lt;/code&gt;, create the &lt;code&gt;Configure&lt;/code&gt; method in &lt;code&gt;Startup&lt;/code&gt; and add the routing service.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public void ConfigureServices(IServiceCollection services)
    {
        services.AddRouting();
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;As you write code in Visual Studio or Visual Studio Code, you can press Ctrl + . (period) to show suggestions for errors (like adding &lt;code&gt;using&lt;/code&gt; statements for you).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Then, we create the &lt;code&gt;Configure&lt;/code&gt; method where we will hook up incoming requests and map them with the routes from our configuration file.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public void Configure(IApplicationBuilder app)
    {
        var routeBuilder = new RouteBuilder(app);

        routeBuilder.MapGet(&amp;quot;{route}&amp;quot;, context =&amp;gt; 
        {
            var routeMessage = Configuration.AsEnumerable()
                .FirstOrDefault(r =&amp;gt; r.Key == context.GetRouteValue(&amp;quot;route&amp;quot;)
                .ToString())
                .Value;
            
            var defaultMessage = Configuration.AsEnumerable()
                .FirstOrDefault(r =&amp;gt; r.Key == &amp;quot;default&amp;quot;)
                .Value;

            var response = (routeMessage != null) ? routeMessage : defaultMessage;

            return context.Response.WriteAsync(response);
        });

        app.UseRouter(routeBuilder.Build());
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We create a new &lt;code&gt;RouteBuilder&lt;/code&gt; and map a new GET &lt;code&gt;route&lt;/code&gt; in &lt;a href=&#34;https://radu-matei.github.io/blog/aspnet-core-routing/&#34;&gt;the same way as in this article&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;            var routeMessage = Configuration.AsEnumerable()
                .FirstOrDefault(r =&amp;gt; r.Key == context.GetRouteValue(&amp;quot;route&amp;quot;)
                .ToString())
                .Value;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We know that our configuration is now accessible through the &lt;code&gt;Configuration&lt;/code&gt; property that we populated in the &lt;code&gt;Startup&lt;/code&gt; constructor, and the configuration settings are an &lt;code&gt;IEnumerable&amp;lt;KeyValuePair&amp;lt;string, string&amp;gt;&amp;gt;&lt;/code&gt;, that is a collection of key-value pairs of strings, so we can use Linq to search for the key-value pair in our file that has the same key as our path and take the value from that pair.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;For some examples of using Linq with lambdas &lt;a href=&#34;http://www.codemag.com/article/1001051&#34;&gt;check this article from Code Magazine&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;We also search for the default message in our JSON so that if the path does not exist in the file, we have a standard respone.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;            var defaultMessage = Configuration.AsEnumerable()
                .FirstOrDefault(r =&amp;gt; r.Key == &amp;quot;default&amp;quot;)
                .Value;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then, depending on wether the route actually exists in our configuration file or not, we return either the message of that specific route, or the default message.&lt;/p&gt;

&lt;p&gt;This is the full &lt;code&gt;Startup&lt;/code&gt; class:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;using System.IO;
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Hosting;
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Configuration;
using Microsoft.AspNetCore.Routing;
using Microsoft.Extensions.DependencyInjection;
using System.Linq;

public class Startup
{
    public IConfiguration Configuration {get;set;}
    public Startup(IHostingEnvironment env)
    {
        var configurationBuilder = new ConfigurationBuilder()
            .SetBasePath(Directory.GetCurrentDirectory())
            .AddJsonFile(&amp;quot;greetings.json&amp;quot;, optional: false, reloadOnChange: true);
        
        Configuration = configurationBuilder.Build();
    }
    public void ConfigureServices(IServiceCollection services)
    {
        services.AddRouting();
    }
    public void Configure(IApplicationBuilder app)
    {
        var routeBuilder = new RouteBuilder(app);

        routeBuilder.MapGet(&amp;quot;{route}&amp;quot;, context =&amp;gt; 
        {
            var routeMessage = Configuration.AsEnumerable()
                .FirstOrDefault(r =&amp;gt; r.Key == context.GetRouteValue(&amp;quot;route&amp;quot;)
                .ToString())
                .Value;
            
            var defaultMessage = Configuration.AsEnumerable()
                .FirstOrDefault(r =&amp;gt; r.Key == &amp;quot;default&amp;quot;)
                .Value;

            var response = (routeMessage != null) ? routeMessage : defaultMessage;

            return context.Response.WriteAsync(response);
        });

        app.UseRouter(routeBuilder.Build());
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we run the application and open a browser, we can check if our routing works:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http://localhost:5000/hello - This should display Hello!
http://localhost:5000/hi - This should display Hi!
http://localhost:5000/bye - This should display Goodbye!
http://localhost:5000/default or http://localhost:5000/anything-else - This should display This is default!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Without closing the application, go to &lt;code&gt;greeting.json&lt;/code&gt; and either add a new key-value pair, or modify an existing one&amp;rsquo;s value, save the file and navigate to that path.&lt;/p&gt;

&lt;p&gt;Normally, you should see that our application was able to load the configuration file without restarting or recompiling.&lt;/p&gt;

&lt;h2 id=&#34;making-use-of-asp-net-core-dependency-injection&#34;&gt;Making use of ASP .NET Core Dependency Injection&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;So far, the examples we&amp;rsquo;ve had were pretty easy to understand, straightforward and olny relied on information that built upon the previous articles.
This example will be about dependency injection, something we haven&amp;rsquo;t discussed yet and will not be an introductory tutorial,  which will be a topic for a future article.&lt;/p&gt;

&lt;p&gt;The reason for doing this is to show how to build a still very simple application, but one that is a lot more configurable.&lt;/p&gt;

&lt;p&gt;Martin Fowler has written an extensive article on &lt;a href=&#34;http://martinfowler.com/articles/injection.html&#34;&gt;Inversion of Control Containers and the Dependency Injection Pattern&lt;/a&gt;. Microsoft Patterns and Practices also has a great description of &lt;a href=&#34;https://msdn.microsoft.com/en-us/library/dn178469(v=pandp.30).aspx&#34;&gt;Dependency Injection&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;For a more detailed view of dependency injection in ASP .NET Core applications, &lt;a href=&#34;https://docs.asp.net/en/latest/fundamentals/dependency-injection.html&#34;&gt;read the article from the Official ASP .NET Core Documentation&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Our application works, but there is a lot of logic code in &lt;code&gt;Startup&lt;/code&gt;, a place for configuration.&lt;/p&gt;

&lt;p&gt;We will try to extract the part of &lt;code&gt;Startup&lt;/code&gt; that deals with actually getting the response from the &lt;code&gt;JSON&lt;/code&gt; file in a separate class and learn how to inject that service in various places (like other services, controllers or even in &lt;code&gt;Startup&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;First of all, let&amp;rsquo;s think at what public methods and properties should a greeting service should have. Basically, it should only have a single method that receives the path a user navigated to and should return a string, the response taken from the JSON file.&lt;/p&gt;

&lt;p&gt;In order to make dependency injection work, we will make use of interfaces. Meaning we will build an interface for the greeting service, &lt;code&gt;IGreetingService&lt;/code&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;To see an example with interfaces, &lt;a href=&#34;https://github.com/microsoft-dx/csharp-fundamentals/tree/master/CSharpFundamentals/csharp09%20-%20Interfaces&#34;&gt;check this tutorial&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Let&amp;rsquo;s create a new file, &lt;code&gt;IGreetingService.cs&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public interface IGreetingService
{
    string Greet(string route);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, in another file, &lt;code&gt;GreetingService.cs&lt;/code&gt; we will add the actual implementation of the service:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;using System.Linq;
using Microsoft.Extensions.Configuration;

public class GreeringService : IGreetingService
{
    private IConfiguration Configuration {get;set;}

    public GreeringService(IConfiguration configuration)
    {
        Configuration = configuration;
    }
    public string Greet(string route)
    {
            var routeMessage = Configuration.AsEnumerable()
                .FirstOrDefault(r =&amp;gt; r.Key == route)
                .Value;
            
            var defaultMessage = Configuration.AsEnumerable()
                .FirstOrDefault(r =&amp;gt; r.Key == &amp;quot;default&amp;quot;)
                .Value;

            return (routeMessage != null) ? routeMessage : defaultMessage;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Basically, this class has the &lt;code&gt;Greet&lt;/code&gt; method which contains most of the logic we had in &lt;code&gt;Startup&lt;/code&gt; for retrieving  the response from the JSON file. It also has an &lt;code&gt;IConfiguration&lt;/code&gt; property, this time injected in the controller (we will see a bit later where and how this is done).&lt;/p&gt;

&lt;p&gt;Now let&amp;rsquo;s take a look at the &lt;code&gt;Startup&lt;/code&gt; class, this time at the &lt;code&gt;Configure&lt;/code&gt; method:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public void Configure(IApplicationBuilder app, IGreetingService greetingService)
    {
        var routeBuilder = new RouteBuilder(app);

        routeBuilder.MapGet(&amp;quot;{route}&amp;quot;, context =&amp;gt; 
        {
            var route = context.GetRouteValue(&amp;quot;route&amp;quot;).ToString();
            return context.Response.WriteAsync(greetingService.Greet(route));
        });

        app.UseRouter(routeBuilder.Build());
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The new thing here is that we have an &lt;code&gt;IGreetingService&lt;/code&gt; parameter in the method signature that we use when returning the message.&lt;/p&gt;

&lt;p&gt;Both the &lt;code&gt;IGreetingService&lt;/code&gt; and &lt;code&gt;IConfiguration&lt;/code&gt; parameters are configured in the &lt;code&gt;ConfigureServices&lt;/code&gt; method, also from &lt;code&gt;Startup&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public void ConfigureServices(IServiceCollection services)
    {
        services.AddRouting();

        services.Add(new ServiceDescriptor(typeof(IConfiguration), 
                     provider =&amp;gt; new ConfigurationBuilder()
                                    .SetBasePath(Directory.GetCurrentDirectory())
                                    .AddJsonFile(&amp;quot;greetings.json&amp;quot;, 
                                                 optional: false, 
                                                 reloadOnChange: true)
                                    .Build(), 
                     ServiceLifetime.Singleton));
                     
        services.AddTransient&amp;lt;IGreetingService, GreeringService&amp;gt;();
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;First of all we add the routing service (just like in the previous examples).&lt;/p&gt;

&lt;p&gt;The last line of this method states that every time some class requests a parameter of type &lt;code&gt;IGreetingService&lt;/code&gt;, the DI (dependency injection) engine will provide it with a new (every time a new) implementation of &lt;code&gt;GreetingService&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The second method call is the most difficult of all: it says that every time someone requests an &lt;code&gt;IConfiguration&lt;/code&gt; parameter, the engine should provide the same instance (singleton) generated by this chain of method calls:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; new ConfigurationBuilder()
    .SetBasePath(Directory.GetCurrentDirectory())
    .AddJsonFile(&amp;quot;greetings.json&amp;quot;, 
                 optional: false, 
                 reloadOnChange: true)
     .Build(), 

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which is the same as earlier.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s have a look at the complete &lt;code&gt;Startup&lt;/code&gt; class:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;using System.IO;
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Configuration;
using Microsoft.AspNetCore.Routing;
using Microsoft.Extensions.DependencyInjection;

public class Startup
{
    public void ConfigureServices(IServiceCollection services)
    {
        services.AddRouting();

        services.Add(new ServiceDescriptor(typeof(IConfiguration), 
                     provider =&amp;gt; new ConfigurationBuilder()
                                    .SetBasePath(Directory.GetCurrentDirectory())
                                    .AddJsonFile(&amp;quot;greetings.json&amp;quot;, 
                                                 optional: false, 
                                                 reloadOnChange: true)
                                    .Build(), 
                     ServiceLifetime.Singleton));
                     
        services.AddTransient&amp;lt;IGreetingService, GreeringService&amp;gt;();
    }
    public void Configure(IApplicationBuilder app, IGreetingService greetingService)
    {
        var routeBuilder = new RouteBuilder(app);

        routeBuilder.MapGet(&amp;quot;{route}&amp;quot;, context =&amp;gt; 
        {
            var route = context.GetRouteValue(&amp;quot;route&amp;quot;).ToString();
            return context.Response.WriteAsync(greetingService.Greet(route));
        });

        app.UseRouter(routeBuilder.Build());
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;We created a web application for which we configured the paths and the associated responses in an external JSON file. We ectracted this functionality in a service, &lt;code&gt;GreetingService&lt;/code&gt; that was provided using dependency injection.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ASP .NET Core Routing</title>
      <link>http://radu-matei.github.io/blog/aspnet-core-routing/</link>
      <pubDate>Wed, 20 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>http://radu-matei.github.io/blog/aspnet-core-routing/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;Table of Contents&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#&#34;&gt;Routing&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#introduction&#34;&gt;Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#installing-the-routing-package&#34;&gt;Installing the Routing package&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#adding-the-routing-service-in-startup&#34;&gt;Adding the Routing Service in Startup&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#adding-and-handling-custom-routes&#34;&gt;Adding and handling custom routes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#the-full-startup-class&#34;&gt;The full Startup class&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#conclusion&#34;&gt;Conclusion&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;routing&#34;&gt;Routing&lt;/h1&gt;

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;In the previous example we built a very simple web application that responded with &lt;code&gt;Hello, Universe&lt;/code&gt; and the current server time for every request.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;When the application is running and you navigate to &lt;a href=&#34;http://localhost5000&#34;&gt;http://localhost5000&lt;/a&gt;, regardless of the path followed (&lt;a href=&#34;http://localhost:5000/something/something-else/etc&#34;&gt;http://localhost:5000/something/something-else/etc&lt;/a&gt;), the response is the same.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;However, any real-world application is going to need a more complex way of handling requests, so in this article we will see how to create route handlers for specific routes and how to extract parameters from the request URI.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The best place to start learning about Routing is the &lt;a href=&#34;https://docs.asp.net/en/latest/fundamentals/routing.html&#34;&gt;Official ASP .NET Core Documentation&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Since we haven&amp;rsquo;t started talking about MVC, the routing discussed here will not include any MVC-specific routing on controllers, actions or parameters, but routing done using &lt;a href=&#34;https://docs.asp.net/en/latest/fundamentals/routing.html#using-routing-middleware&#34;&gt;Routing Middleware&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;installing-the-routing-package&#34;&gt;Installing the &lt;code&gt;Routing&lt;/code&gt; package&lt;/h2&gt;

&lt;p&gt;First of all, we need to add the &lt;code&gt;Microsoft.AspNetCore.Routing&lt;/code&gt; dependency from NuGet.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      &amp;quot;dependencies&amp;quot;: {
        &amp;quot;Microsoft.NETCore.App&amp;quot;: {
          &amp;quot;type&amp;quot;: &amp;quot;platform&amp;quot;,
          &amp;quot;version&amp;quot;: &amp;quot;1.0.0&amp;quot;
        },
        &amp;quot;Microsoft.AspNetCore.Server.Kestrel&amp;quot;: &amp;quot;1.0.0&amp;quot;,
        &amp;quot;Microsoft.AspNetCore.Routing&amp;quot;: &amp;quot;1.0.0&amp;quot;
      }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is how the &lt;code&gt;dependencies&lt;/code&gt; node of &lt;code&gt;project.json&lt;/code&gt; should look like.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The difference form the &lt;a href=&#34;https://github.com/radu-matei/blog-content/blob/master/articles/aspnet-core-startup.md#building-the-hello-world-web-application-with-startup&#34;&gt;previous example&lt;/a&gt; is just the addition of the &lt;code&gt;Routing&lt;/code&gt; package.&lt;/p&gt;

&lt;p&gt;From now on, when adding a new dependency from NuGet the full &lt;code&gt;project.json&lt;/code&gt; will not be shown anymore, but only the new package added.&lt;/p&gt;

&lt;p&gt;At the time of writing this article, the latest version for all ASP .NET Core libraries is &lt;code&gt;1.0.0&lt;/code&gt;. As newer versions are released, check the release notes to see if there are any breaking changes when updating packages.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;adding-the-routing-service-in-startup&#34;&gt;Adding the &lt;code&gt;Routing&lt;/code&gt; Service in &lt;code&gt;Startup&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;When we discussed &lt;a href=&#34;https://github.com/radu-matei/blog-content/blob/master/articles/aspnet-core-startup.md#the-anatomy-of-the-startup-class&#34;&gt;the anatomy of the &lt;code&gt;Startup&lt;/code&gt; class&lt;/a&gt;, besides the &lt;code&gt;Configure&lt;/code&gt; method we have used before, there was also a method called &lt;code&gt;ConfigureServices&lt;/code&gt; used for configuring services that our application needs.&lt;/p&gt;

&lt;p&gt;Since we are going to use Routing, we should add it as a service in &lt;code&gt;Startup&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public void ConfigureServices(IServiceCollection services)
    {
        services.AddRouting();
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;adding-and-handling-custom-routes&#34;&gt;Adding and handling custom routes&lt;/h2&gt;

&lt;p&gt;First of all, in the &lt;code&gt;Configure&lt;/code&gt; method from &lt;code&gt;Startup&lt;/code&gt; we need to instantiate a new instance of the &lt;code&gt;RouteBuilder&lt;/code&gt; class that will allow us to build custom routes and handle them.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var routeBuilder = new RouteBuilder(app);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We will then use this instance to map requests to to specific paths with our request handlers, allowing us to handle&lt;code&gt;GET&lt;/code&gt; and &lt;code&gt;POST&lt;/code&gt; requests from clients.&lt;/p&gt;

&lt;p&gt;The way to map a &lt;code&gt;GET&lt;/code&gt; request is to use the &lt;code&gt;MapGet&lt;/code&gt; method from &lt;code&gt;RouteBuilder&lt;/code&gt;. Mapping the application root - &lt;a href=&#34;http://localhost:5000&#34;&gt;http://localhost:5000&lt;/a&gt; is done through:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;routeBuilder.MapGet(&amp;quot;&amp;quot;, context =&amp;gt; context.Response.WriteAsync(&amp;quot;Hello from root!&amp;quot;));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Mapping specific paths for &lt;code&gt;GET&lt;/code&gt; - for example &lt;a href=&#34;http://localhost:5000/hello&#34;&gt;http://localhost:5000/hello&lt;/a&gt; is done in the following way.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;routeBuilder.MapGet(&amp;quot;hello&amp;quot;, context =&amp;gt; context.Response.WriteAsync(&amp;quot;Hello from /hello&amp;quot;));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can create paths that contain multiple elements and we can extract the parameters entered when making the request. For example, when requesting on &lt;code&gt;hello/{name}&lt;/code&gt;, we can extract the parameter &lt;code&gt;{name}&lt;/code&gt; and use it when constructing the response:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;routeBuilder.MapGet(&amp;quot;hello/{name}&amp;quot;, context =&amp;gt; context.Response
                                                      .WriteAsync($&amp;quot;Hello, {context.GetRouteValue(&amp;quot;name&amp;quot;)}&amp;quot;));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can also add constrains on the parameters. For example, let&amp;rsquo;s create a respond for requests coming to the path &lt;code&gt;/square/{number}&lt;/code&gt;, where &lt;code&gt;{number}&lt;/code&gt; is an &lt;code&gt;int&lt;/code&gt; and responds with the square of the number.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;routeBuilder.MapGet(&amp;quot;square/{number:int}&amp;quot;, context =&amp;gt;
        {
            int number = Convert.ToInt32(context.GetRouteValue(&amp;quot;number&amp;quot;));
            return context.Response.WriteAsync($&amp;quot;The square of {number} is {number * number}&amp;quot;);
        });
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;For a full list of parameter constraints, see this table from &lt;a href=&#34;https://docs.asp.net/en/latest/fundamentals/routing.html#id7&#34;&gt;the Official ASP .NET Core Documentation&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In order to test wether the routing works properly, open a browser and navigate to your custom route and check if the output is the desired one.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;You can also place some breakpoint inside the custom route handlers and iterate through the handlers step-by-step, watching how the response is formed.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;http://localhost:5000
http://localhost:5000/hello
http://localhost:5000/hello/John
http://localhost:5000/square/3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So far we only created routing mapped for the &lt;code&gt;GET&lt;/code&gt; method, so we can test the output from a browser tab.
Now we will add routing for a &lt;code&gt;POST&lt;/code&gt; method (so we will not be able to test it by navigating to the URL in the browser).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;routeBuilder.MapPost(&amp;quot;post&amp;quot;, context =&amp;gt; context.Response.WriteAsync(&amp;quot;Posting!&amp;quot;));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In order to test this route, we need to use a tool that sends &lt;code&gt;HTTP&lt;/code&gt; requests to our application. We will use &lt;a href=&#34;https://chrome.google.com/webstore/detail/postman/fhbjgbiflinjbdggehcddcbncdddomop&#34;&gt;PostMan for Google Chrome&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://radu-matei.github.io/img/article-photos/aspnet-core-routing/routing-postman.JPG&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If we try and change the method type in PostMan from &lt;code&gt;POST&lt;/code&gt; to &lt;code&gt;GET&lt;/code&gt;, we notice how the request fails.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;the-full-startup-class&#34;&gt;The full &lt;code&gt;Startup&lt;/code&gt; class&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;using System;
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Routing;
using Microsoft.Extensions.DependencyInjection;

public class Startup
{
    public void Configure(IApplicationBuilder app)
    {
        
        var routeBuilder = new RouteBuilder(app);
        
        routeBuilder.MapGet(&amp;quot;&amp;quot;, context =&amp;gt; context.Response.WriteAsync(&amp;quot;Hello from root!&amp;quot;));
        routeBuilder.MapGet(&amp;quot;hello&amp;quot;, context =&amp;gt; context.Response.WriteAsync(&amp;quot;Hello from /hello&amp;quot;));
        routeBuilder.MapGet(&amp;quot;hello/{name}&amp;quot;, context =&amp;gt; context.Response
                                                              .WriteAsync($&amp;quot;Hello, {context.GetRouteValue(&amp;quot;name&amp;quot;)}&amp;quot;));

        routeBuilder.MapGet(&amp;quot;square/{number:int}&amp;quot;, context =&amp;gt;
        {
            int number = Convert.ToInt32(context.GetRouteValue(&amp;quot;number&amp;quot;));
            return context.Response.WriteAsync($&amp;quot;The square of {number} is {number * number}&amp;quot;);
        });

        routeBuilder.MapPost(&amp;quot;post&amp;quot;, context =&amp;gt; context.Response.WriteAsync(&amp;quot;Posting!&amp;quot;));

        app.UseRouter(routeBuilder.Build());

    }

    public void ConfigureServices(IServiceCollection services)
    {
        services.AddRouting();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;We created a basic web application and we defined and handled custom routes. We also saw how to manage &lt;code&gt;GET&lt;/code&gt; and &lt;code&gt;POST&lt;/code&gt; requests.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>About Me</title>
      <link>http://radu-matei.github.io/about/</link>
      <pubDate>Wed, 20 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>http://radu-matei.github.io/about/</guid>
      <description>

&lt;h1 id=&#34;who-am-i&#34;&gt;Who am I?&lt;/h1&gt;

&lt;p&gt;My name is Radu Matei, I&amp;rsquo;m an Automatic Control &amp;amp; Computer Science student from Bucharest, Romania, studying at the Politehnica University of Bucharest.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m a Microsoft Technical Evangelist Intern and I&amp;rsquo;ve been a Microsoft Student Partner since my junior year.&lt;/p&gt;

&lt;h1 id=&#34;what-is-this-blog-about&#34;&gt;What is this blog about?&lt;/h1&gt;

&lt;p&gt;This blog is about software development, mostly .NET, with Cloud, IoT and micro-services.
I also enjoy giving technical presentations, so I will keep a record of the ones I&amp;rsquo;ve given.&lt;/p&gt;

&lt;p&gt;The views presented here are my own and are not affiliated with any organization I am part of.&lt;/p&gt;

&lt;h1 id=&#34;how-can-you-contact-me&#34;&gt;How can you contact me?&lt;/h1&gt;

&lt;p&gt;On the sidebar in the left there is pretty much every place you can find me, including my email, so do not hesitate to comment or contact me.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ASP .NET Core Startup</title>
      <link>http://radu-matei.github.io/blog/aspnet-core-startup/</link>
      <pubDate>Tue, 19 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>http://radu-matei.github.io/blog/aspnet-core-startup/</guid>
      <description>

&lt;h1 id=&#34;the-startup-class&#34;&gt;The &lt;code&gt;Startup&lt;/code&gt; class&lt;/h1&gt;

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;In the &lt;a href=&#34;https://github.com/radu-matei/blog-content/blob/master/articles/aspnet-core-getting-started.md&#34;&gt;previous article&lt;/a&gt; we built a very basic web application that for every request had a very basic response - &lt;code&gt;Hello, Universe&lt;/code&gt; with the server current time and date.&lt;/p&gt;

&lt;p&gt;Any non-trivial application is going to need a mechanism to handle different types of requests and map them to specific services and middleware and configure services. This is accomplished through the &lt;code&gt;Startup&lt;/code&gt; class, which is also the entry point for any incoming HTTP request.&lt;/p&gt;

&lt;h2 id=&#34;the-anatomy-of-the-startup-class&#34;&gt;The anatomy of the &lt;code&gt;Startup&lt;/code&gt; class&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;Startup&lt;/code&gt; class needs to have two methods:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Configure&lt;/code&gt; - this method will respond to each incoming HTTP request. In the following example, we will use it to have the same functionality as in our previous example - returning a message with the current server time.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;However,  most real-world applications require more functionality than this. More complex sets of pipeline configuration can be encapsulated in &lt;a href=&#34;https://docs.asp.net/en/latest/fundamentals/middleware.html&#34;&gt;middleware&lt;/a&gt; and added using extension methods on &lt;code&gt;IApplicationBuilder&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Your &lt;code&gt;Configure&lt;/code&gt; method must accept an &lt;a href=&#34;https://docs.asp.net/projects/api/en/latest/autoapi/Microsoft/AspNetCore/Builder/IApplicationBuilder/index.html&#34;&gt;&lt;code&gt;IApplicationBuilder&lt;/code&gt;&lt;/a&gt; parameter. Additional services, like &lt;code&gt;IHostingEnvironment&lt;/code&gt; and &lt;code&gt;ILoggerFactory&lt;/code&gt; may also be specified, in which case these services will be injected by the server if they are available.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ConfigureServices&lt;/code&gt; - this &lt;strong&gt;optional&lt;/strong&gt; method is used for configuring services used by the application and is called before the &lt;code&gt;Configure&lt;/code&gt; method.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;This is the place where we will start discussing dependency injection, which will be covered in a separate topic.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;building-the-hello-world-web-application-with-startup&#34;&gt;Building the &lt;code&gt;Hello, World&lt;/code&gt; web application with &lt;code&gt;Startup&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;We are going to build the same application that responds with &lt;code&gt;Hello, World&lt;/code&gt; and the current time, this time with a &lt;code&gt;Startup&lt;/code&gt; class.&lt;/p&gt;

&lt;p&gt;First of all, if this is a new application (created using &lt;code&gt;dotnet new&lt;/code&gt;), you should add the dependency to the web server Kestrel in &lt;code&gt;project.json&lt;/code&gt;, which should look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;version&amp;quot;: &amp;quot;1.0.0-*&amp;quot;,
  &amp;quot;buildOptions&amp;quot;: {
    &amp;quot;debugType&amp;quot;: &amp;quot;portable&amp;quot;,
    &amp;quot;emitEntryPoint&amp;quot;: true
  },
  &amp;quot;dependencies&amp;quot;: {},
  &amp;quot;frameworks&amp;quot;: {
    &amp;quot;netcoreapp1.0&amp;quot;: {
      &amp;quot;dependencies&amp;quot;: {
        &amp;quot;Microsoft.NETCore.App&amp;quot;: {
          &amp;quot;type&amp;quot;: &amp;quot;platform&amp;quot;,
          &amp;quot;version&amp;quot;: &amp;quot;1.0.0&amp;quot;
        },
        &amp;quot;Microsoft.AspNetCore.Server.Kestrel&amp;quot;: &amp;quot;1.0.0&amp;quot;
      },
      &amp;quot;imports&amp;quot;: &amp;quot;dnxcore50&amp;quot;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then, add a new file called &lt;code&gt;Startup.cs&lt;/code&gt; and add the following code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;using System;
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Http;

public class Startup
{
    public void Configure(IApplicationBuilder app)
    {
        app.Run(context =&amp;gt;
        {
            var response = String.Format(&amp;quot;Hello, Universe! It is {0}&amp;quot;, DateTime.Now);
            return context.Response.WriteAsync(response);
        });
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see, the code in &lt;code&gt;Configure&lt;/code&gt; is the same as the code in &lt;code&gt;Main&lt;/code&gt; from the previous example.&lt;/p&gt;

&lt;p&gt;Then, in the &lt;code&gt;Main&lt;/code&gt; method we simply indicate that we have a &lt;code&gt;Startup&lt;/code&gt; class we want to use.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;using Microsoft.AspNetCore.Hosting;
using Microsoft.AspNetCore.Builder;

namespace ConsoleApplication
{
    public class Program
    {
        public static void Main(string[] args)
        {
            var host = new WebHostBuilder()
                .UseKestrel()
                .UseStartup&amp;lt;Startup&amp;gt;()
                .Build();

                host.Run();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now if we run the application (from the command line or from VS Code) and navigate to &lt;a href=&#34;http://localhost:5000&#34;&gt;http://localhost:5000&lt;/a&gt;, we see the expected output.&lt;/p&gt;

&lt;p&gt;From now on, we will use the &lt;code&gt;Startup&lt;/code&gt; class when building web applications with ASP .NET Core and we will add middleware and services in it.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ASP .NET Core Introduction</title>
      <link>http://radu-matei.github.io/blog/aspnet-core-getting-started/</link>
      <pubDate>Mon, 18 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>http://radu-matei.github.io/blog/aspnet-core-getting-started/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;Table of Contents&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#introduction&#34;&gt;Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#getting-started-with-asp-net-core-10&#34;&gt;Getting Started with ASP .NET Core 1.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#make-the-project-a-web-application&#34;&gt;Make the project a web application&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#conclusion&#34;&gt;Conclusion&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;ASP.NET Core is a new open-source and cross-platform framework for building modern cloud based internet connected applications, such as web apps, IoT apps and mobile backends.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;ASP.NET Core apps can run on .NET Core or on the full .NET Framework. It was architected to provide an optimized development framework for apps that are deployed to the cloud or run on-premises. It consists of modular components with minimal overhead, so you retain flexibility while constructing your solutions. You can develop and run your ASP.NET Core apps cross-platform on Windows, Mac and Linux. ASP.NET Core is open source at GitHub.&lt;/p&gt;

&lt;p&gt;The best way to understand what ASP.NET Core is and why it was built is the &lt;a href=&#34;https://docs.asp.net/en/latest/intro.html&#34;&gt;Official ASP .NET Core Documentation&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;ASP .NET Core is a complete re-write of the 4.6 framework that came out last year and comes with a completely new architecture based on .NET Core.&lt;/p&gt;

&lt;p&gt;ASP .NET Core is no longer based on&lt;code&gt;System.Web&lt;/code&gt;. Instead, everything in the framework is modular and comes as NuGet packages which allows you to only include in your application the packages that you will use, resulting in a smaller application footprint and better performance.&lt;/p&gt;

&lt;p&gt;It comes with integrated &lt;a href=&#34;https://docs.asp.net/en/latest/fundamentals/dependency-injection.html&#34;&gt;dependency injection&lt;/a&gt;, a new request pipeline middleware and the ability to plug in your own web server (IIS - Windows only or Kestrel inside your own process in Windows, macOS and Linux) and run across operating systems with very similar development processes and tools.&lt;/p&gt;

&lt;p&gt;Together with &lt;a href=&#34;https://www.typescriptlang.org/&#34;&gt;TypeScript&lt;/a&gt;, the client-side framework of your choice (Angular 2, React, Aurelia etc), familiar tools for web developers (that didn&amp;rsquo;t have very good support on Windows until very recently) like Grunt, Gulp or Bower and with a superior performance compared to Node, for example, Microsoft bets on ASP .NET Core to become one of the preferred frameworks when building modern web and cloud applications.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;For the complete section on client-side development with ASP .NET Core see &lt;a href=&#34;https://docs.asp.net/en/latest/client-side/index.html&#34;&gt;the Official ASP .NET Core Documentation&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The ASP .NET Core team made a priority building a great development experience for client-side frameworks and you can see the work-in-progress on the &lt;a href=&#34;https://github.com/aspnet/JavaScriptServices/&#34;&gt;JavaScriptServices repository on GitHub&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;getting-started-with-asp-net-core-1-0&#34;&gt;Getting Started with ASP .NET Core 1.0&lt;/h2&gt;

&lt;p&gt;The first step in beginning development is to install .NET Core. You should &lt;a href=&#34;https://github.com/radu-matei/blog-content/blob/master/articles/dot-net-core-getting-started.md&#34;&gt;follow this tutorial on how to get started with .NET Core and build a basic console application&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;After installing .NET Core, open a command-line prompt, create a new directory and add a &lt;code&gt;dotnet&lt;/code&gt; application.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkdir aspnet-core-tutorial
cd aspnet-core-tutorial
dotnet new
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://radu-matei.github.io/img/article-photos/aspnet-core-getting-started/powershell-dotnet-new.JPG&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The same commands work across Windows PowerShell and the macOS and Linux Terminal&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;To check if everything is in place, execute the following commands:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dotnet restore
dotnet run
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://radu-matei.github.io/img/article-photos/aspnet-core-getting-started/powershell-dotnet-restore-run.JPG&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/radu-matei/blog-content/blob/master/articles/dot-net-core-getting-started.md&#34;&gt;This tutorial&lt;/a&gt; explains all commands involved here.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/radu-matei/blog-content/blob/master/articles/dot-net-core-getting-started.md#installing-visual-studio-code&#34;&gt;Install Visual Studio Code&lt;/a&gt; and open the project you created.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;make-the-project-a-web-application&#34;&gt;Make the project a web application&lt;/h2&gt;

&lt;p&gt;As we established earlier, every library in the new .NET Core is a package. So in order to use some packages, we will add them in &lt;code&gt;project.json&lt;/code&gt; and at compile time, the packages get downloaded from NuGet.&lt;/p&gt;

&lt;p&gt;In order to host a web application, we need to have a dependency on the web server - Kestrel. After adding this dependency, the &lt;code&gt;project.json&lt;/code&gt; file should look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;version&amp;quot;: &amp;quot;1.0.0-*&amp;quot;,
  &amp;quot;buildOptions&amp;quot;: {
    &amp;quot;debugType&amp;quot;: &amp;quot;portable&amp;quot;,
    &amp;quot;emitEntryPoint&amp;quot;: true
  },
  &amp;quot;dependencies&amp;quot;: {},
  &amp;quot;frameworks&amp;quot;: {
    &amp;quot;netcoreapp1.0&amp;quot;: {
      &amp;quot;dependencies&amp;quot;: {
        &amp;quot;Microsoft.NETCore.App&amp;quot;: {
          &amp;quot;type&amp;quot;: &amp;quot;platform&amp;quot;,
          &amp;quot;version&amp;quot;: &amp;quot;1.0.0&amp;quot;
        },
        &amp;quot;Microsoft.AspNetCore.Server.Kestrel&amp;quot;: &amp;quot;1.0.0&amp;quot;
      },
      &amp;quot;imports&amp;quot;: &amp;quot;dnxcore50&amp;quot;
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;When running on Windows, we can choose between the classic IIS web server and the new web server Kestrel web server (based on &lt;a href=&#34;https://github.com/libuv/libuv&#34;&gt;libuv&lt;/a&gt;) that runs across operating systems.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In &lt;code&gt;Program.cs&lt;/code&gt; we add the following:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;using System;
using Microsoft.AspNetCore.Hosting;
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Http;

namespace ConsoleApplication
{
    public class Program
    {
        public static void Main(string[] args)
        {
            var host = new WebHostBuilder()
                .UseKestrel()
                .Configure(app =&amp;gt; app.Run(context =&amp;gt; 
                {
                    var response = String.Format(&amp;quot;Hello, Universe! It is {0}&amp;quot;, DateTime.Now);
                    return context.Response.WriteAsync(response);
                }))
                .Build();

                host.Run();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In &lt;code&gt;Main&lt;/code&gt; we create an instance of &lt;code&gt;WebHostBuilder&lt;/code&gt;, which follows the &lt;a href=&#34;https://en.wikipedia.org/wiki/Builder_pattern&#34;&gt;builder pattern&lt;/a&gt; to create a web application host, which then is used to define which web server to use - &lt;code&gt;.UseKestrel()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;.Build()&lt;/code&gt; and &lt;code&gt;.Run()&lt;/code&gt; methods will start listening for HTTP requests.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Even if we create a web app, we started with a console application and added elements that allowed it to start listening for incoming HTTP requests.&lt;/p&gt;

&lt;p&gt;The entry point for web applications in ASP .NET Core is also the &lt;code&gt;Main&lt;/code&gt; method.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This is a very basic web application. For every request, it will simply respond with &lt;code&gt;Hello, Universe!&lt;/code&gt; and the current time of the server. It is the most simple application logic and in further examples we will examine handling more complex requests.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; .Configure(app =&amp;gt; app.Run(context =&amp;gt; 
   {
      var response = String.Format(&amp;quot;Hello, Universe! It is {0}&amp;quot;, DateTime.Now);
      return context.Response.WriteAsync(response);
    }))

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is the part that actually creates the response - it is a &lt;a href=&#34;https://msdn.microsoft.com/en-us/library/bb397687.aspx&#34;&gt;Lambda Expression&lt;/a&gt; that takes the &lt;code&gt;context&lt;/code&gt; as parameter and writes the response asynchrounously and is called a &lt;a href=&#34;https://docs.asp.net/en/latest/fundamentals/middleware.html#what-is-middleware&#34;&gt;request delegate&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;You can either run the application from the command line (&lt;code&gt;dotnet run&lt;/code&gt;) or from VS Code.
To run it from VS Code, go to the debugging pane (or press Ctrl/Cmd + Shift + D) and start the application.&lt;/p&gt;

&lt;p&gt;After the application starts, open a browser and navigate to &lt;a href=&#34;http://localhost:5000&#34;&gt;http://localhost:5000&lt;/a&gt;.
If everything worked as expected, you should see the following:
&lt;img src=&#34;http://radu-matei.github.io/img/article-photos/aspnet-core-getting-started//aspnet-core-hello-universe-browser.JPG&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;We built a very basic web application starting from the console application template by adding the Kestrel dependency and by using &lt;code&gt;WebHostBuilder&lt;/code&gt; to create the application host.&lt;/p&gt;

&lt;p&gt;We then, for each request we built the response containing a simple message and the current time of the server.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Getting Started with .NET Core and VS Code</title>
      <link>http://radu-matei.github.io/blog/dot-net-core-getting-started/</link>
      <pubDate>Sun, 17 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>http://radu-matei.github.io/blog/dot-net-core-getting-started/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;Table of Contents&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#getting-started-with-net-core&#34;&gt;Getting started with .NET Core&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#installing-net-core&#34;&gt;Installing .NET Core&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#building-a-net-core-application-using-the-command-line-interface&#34;&gt;Building a .NET Core application using the command line interface&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#installing-visual-studio-code&#34;&gt;Installing Visual Studio Code&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#running-in-visual-studio-code&#34;&gt;Running in Visual Studio Code&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#debugging-in-visual-studio-code&#34;&gt;Debugging in Visual Studio Code&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#adding-classes-and-navigating-through-code&#34;&gt;Adding classes and navigating through code&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#conclusion&#34;&gt;Conclusion&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;getting-started-with-net-core&#34;&gt;Getting started with .NET Core&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://radu.microsoft.pub.ro/dot-net-core-introduction/&#34;&gt;In the previous article&lt;/a&gt;, we saw what is .NET Core and what can we build with it. In this article, we will install .NET Core and start with some basic examples using the command line and Visual Studio Code.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This tutorial can be done using Windows, Linux or macOS..&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;installing-net-core&#34;&gt;Installing .NET Core&lt;/h2&gt;

&lt;p&gt;Wether your OS is Windows, Linux or macOS, you can &lt;a href=&#34;https://www.microsoft.com/net/core&#34;&gt;go to this page and follow the instructions&lt;/a&gt; for getting .NET Core on your machine.&lt;/p&gt;

&lt;p&gt;When the installation is complete, you should be able to open a command line interface (CMD, PowerShell for Windows, Terminal for Linux and macOS) and check if the installation was successful by executing the following command: &lt;a href=&#34;https://docs.microsoft.com/en-us/dotnet/articles/core/tools/dotnet&#34;&gt;&lt;code&gt;dotnet&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://radu-matei.github.io/img/article-photos/dot-net-getting-started/dotnet-powershell.JPG&#34; alt=&#34;dotnet PowerShell&#34; /&gt;
&amp;gt; Output for the &lt;a href=&#34;https://docs.microsoft.com/en-us/dotnet/articles/core/tools/dotnet&#34;&gt;&lt;code&gt;dotnet&lt;/code&gt;&lt;/a&gt; command in PowerShell. The output is similar for Linux and macOS.&lt;/p&gt;

&lt;p&gt;At this point, you have successfully installed .NET Core and you can start building applications.&lt;/p&gt;

&lt;h2 id=&#34;building-a-net-core-application-using-the-command-line-interface&#34;&gt;Building a .NET Core application using the command line interface&lt;/h2&gt;

&lt;p&gt;In Windows PowerShell or the Linux / macOS Terminal, let&amp;rsquo;s create a new directory. I will call it &lt;code&gt;dot-net-tutorial&lt;/code&gt; and navigate to it and create a new console application here using the &lt;a href=&#34;https://docs.microsoft.com/en-us/dotnet/articles/core/tools/dotnet-new&#34;&gt;&lt;code&gt;dotnet new&lt;/code&gt;&lt;/a&gt; command.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkdir dot-net-tutorial
cd dot-net-tutorial
dotnet new
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is how it should look like after executing these commands.
&lt;img src=&#34;https://raw.githubusercontent.com/radu-matei/blog-content/master/media/dot-net-getting-started/dotnet-powershell-new.JPG&#34; alt=&#34;enter image description here&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Notice how we got two files after creating the project&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Program.cs&lt;/code&gt;- C# file containing the entry point in the console application - the &lt;code&gt;Main&lt;/code&gt; method&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;using System;

namespace ConsoleApplication
{
    public class Program
    {
        public static void Main(string[] args)
        {
            Console.WriteLine(&amp;quot;Hello World!&amp;quot;);
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;This is a basic &lt;code&gt;Hello World&lt;/code&gt; example in C# and you can &lt;a href=&#34;https://radu.microsoft.pub.ro/csharp-fundamentals-01/&#34;&gt;find more information about everything in the code in this article&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;project.json&lt;/code&gt; - JSON file that contains all necessary dependencies and the frameworks for the application to run, including .NET frameworks and NuGet packages.
&lt;code&gt;
{
&amp;quot;version&amp;quot;: &amp;quot;1.0.0-*&amp;quot;,
&amp;quot;buildOptions&amp;quot;: {
&amp;quot;debugType&amp;quot;: &amp;quot;portable&amp;quot;,
&amp;quot;emitEntryPoint&amp;quot;: true
},
&amp;quot;dependencies&amp;quot;: {},
&amp;quot;frameworks&amp;quot;: {
&amp;quot;netcoreapp1.0&amp;quot;: {
  &amp;quot;dependencies&amp;quot;: {
    &amp;quot;Microsoft.NETCore.App&amp;quot;: {
      &amp;quot;type&amp;quot;: &amp;quot;platform&amp;quot;,
      &amp;quot;version&amp;quot;: &amp;quot;1.0.0&amp;quot;
    }
  },
  &amp;quot;imports&amp;quot;: &amp;quot;dnxcore50&amp;quot;
}
}
}
&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;In a future release, the &lt;code&gt;project&lt;/code&gt; file will return to a &lt;code&gt;.csproj&lt;/code&gt; extension in order to maitain compatibility with all Visual Studio and Xamarin projects.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Calling &lt;a href=&#34;https://docs.microsoft.com/en-us/dotnet/articles/core/tools/dotnet-restore&#34;&gt;&lt;code&gt;dotnet restore&lt;/code&gt;&lt;/a&gt;  will restore all dependencies of the application.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dotnet restore
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.microsoft.com/en-us/dotnet/articles/core/tools/dotnet-restore&#34;&gt;&lt;code&gt;dotnet restore&lt;/code&gt;&lt;/a&gt; calls into NuGet to restore the tree of dependencies. NuGet analyzes the &lt;code&gt;project.json&lt;/code&gt; file, downloads the dependencies stated in the file (or grabs them from a cache on your machine), and writes the &lt;code&gt;project.lock.json&lt;/code&gt; file. The &lt;code&gt;project.lock.json&lt;/code&gt; file is necessary to be able to compile and run.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;project.lock.json&lt;/code&gt; file is a persisted and complete set of the graph of NuGet dependencies and other information describing an app. This file is read by other tools, such as dotnet build and dotnet run, enabling them to process the source code with a correct set of NuGet dependencies and binding resolutions.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;http://radu-matei.github.io/img/article-photos/dot-net-getting-started/dotnet-restore.JPG&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;At this point, we can run the application and see if the output is the expected one using the &lt;a href=&#34;https://docs.microsoft.com/en-us/dotnet/articles/core/tools/dotnet-run&#34;&gt;&lt;code&gt;dotnet run&lt;/code&gt;&lt;/a&gt; command.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://radu-matei.github.io/img/article-photos/dot-net-getting-started/dotnet-run.JPG&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;This is how you create, build and run a basic .NET Core application using the command line.&lt;/p&gt;

&lt;h2 id=&#34;installing-visual-studio-code&#34;&gt;Installing Visual Studio Code&lt;/h2&gt;

&lt;p&gt;We saw how to create, build and run applications from the command line, now it is time to move to a complete code editor that has IntelliSense and debugging built in - &lt;a href=&#34;https://code.visualstudio.com/&#34;&gt;Visual Studio Code&lt;/a&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://code.visualstudio.com/&#34;&gt;Install Visual Studio code from here&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In order to get IntelliSense working, you need to install the C# extension for Visual Studio Code that also installs &lt;a href=&#34;omnisharp.net/&#34;&gt;OmniSharp&lt;/a&gt; for IntelliSense.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://radu-matei.github.io/img/article-photos/dot-net-getting-started/vs-code-extensions.JPG&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;After it installs, enable it and restart VS Code. At this point, we can open the folder with the earlier project in VS Code.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;You can do this in the command line by using &lt;code&gt;code .&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;running-in-visual-studio-code&#34;&gt;Running in Visual Studio Code&lt;/h2&gt;

&lt;p&gt;In order to enable debugging and running the code from VS Code, a prompt is shown asking to add the configuration files.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://radu-matei.github.io/img/article-photos/dot-net-getting-started/vs-code-assets.JPG&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This will add a &lt;code&gt;.vscode&lt;/code&gt; folder in the solution root with two &lt;code&gt;.json&lt;/code&gt; files - &lt;code&gt;tasks.json&lt;/code&gt; and &lt;code&gt;launch.json&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;We can run the application by going to the Debug pane (or by pressing Ctrl(Cmd)+Shift+D) and press the run button (or F5).&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://radu-matei.github.io/img/article-photos/dot-net-getting-started/vs-code-run.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;If everything goes well, you should be able to see the output in the debug console.&lt;/p&gt;

&lt;h2 id=&#34;debugging-in-visual-studio-code&#34;&gt;Debugging in Visual Studio Code&lt;/h2&gt;

&lt;p&gt;We saw how to run the application, not let&amp;rsquo;s add a method that adds two integers.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;using System;

namespace ConsoleApplication
{
    public class Program
    {
        public static void Main(string[] args)
        {
            int a = 7, b = 12;

            Console.WriteLine(Add(a, b));
        }

        public static int Add(int a, int b)
        {
            int sum = a + b;
            return sum;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we add a breakpoint at the &lt;code&gt;return sum&lt;/code&gt; line and we run the application, we get the following output:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://radu-matei.github.io/img/article-photos/dot-net-getting-started/vs-code-breakpoint.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The execution stopped at the line with the breakpoint and we can see the state of our program at this point.&lt;/p&gt;

&lt;h2 id=&#34;adding-classes-and-navigating-through-code&#34;&gt;Adding classes and navigating through code&lt;/h2&gt;

&lt;p&gt;At this point, we can start using VS Code to its full potential - IntelliSense, code completion, navigating code and going to definitions.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;You can see a &lt;a href=&#34;https://github.com/Microsoft/vscode-tips-and-tricks&#34;&gt;full list of VS Code tips and tricks on the official Microsoft GitHub organization here&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;We will add a very basic &lt;code&gt;Person&lt;/code&gt; class based on &lt;a href=&#34;https://github.com/microsoft-dx/csharp-fundamentals/tree/master/CSharpFundamentals/csharp05%20-%20Classes&#34;&gt;this project&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Person
    {
        public string FirstName { get; set; }
        public string LastName { get; set; }
        public int Age { get; set; }

        public Person()
        {
        }

        public Person(string firstName, string lastName, int age)
        {
            FirstName = firstName;
            LastName = lastName;
            Age = age;
        }

        public void PrintPerson()
        {
            Console.WriteLine(&amp;quot;First Name: {0}, Last Name: {1}, Age: {2}&amp;quot;, FirstName, LastName, Age);
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It is a very basic class with three properties, two constructors and a method that prints the information to the console.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;You can &lt;a href=&#34;https://github.com/microsoft-dx/csharp-fundamentals&#34;&gt;find all necessary materials to learn C# in this repository&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In the &lt;code&gt;Main&lt;/code&gt; method, we instantiate a new &lt;code&gt;Person&lt;/code&gt; object and use the &lt;code&gt;PrintPerson&lt;/code&gt; method to display the properties.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://radu-matei.github.io/img/article-photos/dot-net-getting-started/vs-code-person-debugging.JPG&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;We saw how to install .NET Core and how to build and run a console application using the command line.&lt;/p&gt;

&lt;p&gt;Then, we installed Visual Studio Code and saw how easy it is to debug, navigate through and run our code.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Introduction to .NET Core</title>
      <link>http://radu-matei.github.io/blog/dot-net-core-introduction/</link>
      <pubDate>Sat, 16 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>http://radu-matei.github.io/blog/dot-net-core-introduction/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;Table of Contents&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#what-is-net-core&#34;&gt;What is .NET Core?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#scenarios-for-net-core&#34;&gt;Scenarios for .NET Core&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#net-standard---one-library-to-rule-them-all&#34;&gt;.NET Standard - One library to rule them all&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#tools&#34;&gt;Tools&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#conclusion&#34;&gt;Conclusion&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;what-is-net-core&#34;&gt;What is .NET Core?&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;.NET Core is a general purpose development platform maintained by Microsoft and the .NET community on &lt;a href=&#34;https://github.com/dotnet&#34;&gt;GitHub&lt;/a&gt;. It is cross-platform, &lt;strong&gt;supporting Windows, macOS and Linux&lt;/strong&gt;, and can be used in device, cloud, and embedded/IoT scenarios.&lt;/p&gt;

&lt;p&gt;The following characteristics best define .NET Core:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Flexible deployment: Can be included in your app or installed side-by-side user- or machine-wide.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Cross-platform: Runs on Windows, macOS and Linux; can be ported to other OSes. The supported Operating Systems (OS), CPUs and application scenarios will grow over time, provided by Microsoft, other companies, and individuals.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Command-line tools: All product scenarios can be exercised at the command-line.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Compatible: .NET Core is compatible with .NET Framework, Xamarin and Mono, via the .NET Standard Library.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Open source: The .NET Core platform is open source, using MIT an  Apache 2 licenses. Documentation is licensed under CC-BY. .NET Core is a .NET Foundation project.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Supported by Microsoft: .NET Core is supported by Microsoft, per .NET Core Support&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;https://docs.microsoft.com/en-us/dotnet/articles/core/index&#34;&gt;More on the Official .NET Core Documentation from Microsoft&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Basically, Microsoft built a version of .NET to allow developers to write cross-platform and cloud-optimized applications.&lt;/p&gt;

&lt;p&gt;First, .NET is cross-platform. It runs on Windows, macOS and Linux, which allows the developer to share and run the exact same code between machines running different operating systems, with no changes in code and minimum or no changes in the deveopment process.
(Watch out for OS specific APIs!)&lt;/p&gt;

&lt;p&gt;But the true innovation in .NET came with the modularization in design and architecture.
The compiler (&lt;a href=&#34;https://github.com/dotnet/roslyn&#34;&gt;Roslyn&lt;/a&gt;) and the runtime (&lt;a href=&#34;https://github.com/dotnet/coreclr&#34;&gt;CoreCLR&lt;/a&gt;) are separate components that allow you to use different implementations (or even write your own).&lt;/p&gt;

&lt;p&gt;Every library comes as a NuGet package, so when you start a new project, you don&amp;rsquo;t have any libraries, but a project file (currently a &lt;code&gt;.json&lt;/code&gt;, in the future a &lt;code&gt;.csproj&lt;/code&gt; to maintain consistency with all .NET projects) and a &lt;code&gt;Program.cs&lt;/code&gt;.  As you develop your app, you add libraries as you need them, allowing you to minimize the size of your application.&lt;/p&gt;

&lt;p&gt;.NET Core also allows you to have multiple versions installed at the same time without having apps / parts of the OS breaking when you update or install a newer version of the framework, and will even allow you to ship the framework / parts of the framework with the application (since the footprint of the framework si small enough).&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;.NET Core will favor performance with a standard library that minimizes allocations and the overall memory footprint of your system.
&lt;a href=&#34;https://msdn.microsoft.com/en-us/magazine/mt694084.aspx&#34;&gt;The complete MSDN article.&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;scenarios-for-net-core&#34;&gt;Scenarios for .NET Core&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://developer.microsoft.com/en-us/windows/develop/building-universal-windows-apps&#34;&gt;Universal Windows Apps&lt;/a&gt; that run on all various Windows versions (on laptops, tablets, phones, IoT devices, xBox, HoloLens)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://www.xamarin.com/platform&#34;&gt;Xamarin Apps&lt;/a&gt; that run on Android, iOS and macOS using the same shared C# code&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://docs.microsoft.com/en-us/dotnet/articles/core/index&#34;&gt;.NET Core&lt;/a&gt; - cross-platform console applications and libraries&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://docs.asp.net/&#34;&gt;ASP .NET Core&lt;/a&gt; - cross-platform web applications that run on Windows (inside IIS and with the dedicated web server - Kestrel), macOS and Linux (with the dedicated web server - Kestrel) with &lt;a href=&#34;http://web.ageofascent.com/asp-net-core-exeeds-1-15-million-requests-12-6-gbps/&#34;&gt;superior performance&lt;/a&gt; compared to the standard ASP .NET 4.6 or to Node.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://gupaja.bn1301.livefilestore.com/y3mLAmG-73wdLvYRFdnmUwYciTpGlCYf5WdiTSlRQ2hWJOiK9XB1piAiuvT_9auvQTIwmi-LuhH3qsYoVXGq1rNJ05HLWEu4ifcT6qiiMmqb27g5yG-7PuV4Y7i8qFMkKijgxTAKYjCkOdEAlBqh2hfyFrkqrbagfm0Fvp4LLpl56s?width=1280&amp;amp;height=720&amp;amp;cropmode=none&#34; alt=&#34;Exciting times&#34; /&gt;&lt;/p&gt;

&lt;p&gt;So right now, using C# and .NET you can build almost any type of application and target multiple frameworks.&lt;/p&gt;

&lt;h2 id=&#34;net-standard-one-library-to-rule-them-all&#34;&gt;.NET Standard - One library to rule them all&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;The .NET Standard Library is a formal specification of .NET APIs that are intended to be available on all .NET runtimes. The motivation behind the Standard Library is establishing greater uniformity in the .NET ecosystem. ECMA 335 continues to establish uniformity for .NET runtime behavior, but there is no similar spec for the .NET Base Class Libraries (BCL) for .NET library implementations.&lt;/p&gt;

&lt;p&gt;The .NET Standard Library enables the following key scenarios:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Defines uniform set of BCL APIs for all .NET platforms to implement, independent of workload.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Enables developers to produce portable libraries that are usable across .NET runtimes, using this same set of APIs.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Reduces and hopefully eliminates conditional compilation of shared source due to .NET APIs, only for OS APIs.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;More on the .NET Standard Library on the &lt;a href=&#34;https://docs.microsoft.com/en-us/dotnet/articles/standard/library&#34;&gt;Official Microsoft Documentation&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;https://tl4blw.bn1301.livefilestore.com/y3m6sNWtdUd2Htc9yvtCL6sEvqjaJaEHh-2uGizu_fLU3hH7DL23-0nW104ESwTFZ32v6KmBeekCkZLmPQZIh6RklD-zE2vG4fi5Zo1mnqIR_gWugP1Es97QkxhK74JazU8NFgWomXCkbvgO7jZd5nxThPRrMGdCfwwc4THeX7eqU4?width=1280&amp;amp;height=720&amp;amp;cropmode=none&#34; alt=&#34;.NET&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The goal of .NET Standard is to have a single, unified set of libraries that you target when building an application, regardless of the type - console, web or mobile - you simply target .NET Standard and you are guaranteed that libraries there will work when shared across all platforms.&lt;/p&gt;

&lt;p&gt;This is the part of the framework most of the work will take place in the future and you can follow the progress or contribute in &lt;a href=&#34;https://github.com/dotnet/corefx&#34;&gt;this GitHub repository&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;tools&#34;&gt;Tools&lt;/h2&gt;

&lt;p&gt;Historically, .NET developers didn&amp;rsquo;t have to (or couldn&amp;rsquo;t) use the command line so often. Visual Studio took care of most processes involved in building and running the applications.&lt;/p&gt;

&lt;p&gt;But with the open-source of .NET Core, all development efforts became CLI-first, so everything involved in building, compiling or running .NET Core applications can be done using the command line.&lt;/p&gt;

&lt;p&gt;In fact, all these things were built for the command line first and then were wrapped in the multiple tools available.&lt;/p&gt;

&lt;p&gt;Regardless of the OS, you use the same command line interface (which is also &lt;a href=&#34;https://github.com/dotnet/cli&#34;&gt;open source and available on GitHub&lt;/a&gt;) to create new apps, build, or run.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://9o6coq.bn1301.livefilestore.com/y3m9rWnsOG_vk6tONR1SWQFdThTblC_-OgmT8LZKbysS2EONc3azyFoPROy9DRCaauouG9HlOUBqk29uFbPK9Q_OPFC7QEyG_KcihlQYolIjnzOwTyhm1m_vI9ck5FfypPYz5mYRUDXW2V_8_Dn8YrvP5vSD88fXwvHKou-pU1PzsA?width=1280&amp;amp;height=720&amp;amp;cropmode=none&#34; alt=&#34;Tools&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.visualstudio.com/en-us/products/code-vs.aspx&#34;&gt;Visual Studio Code&lt;/a&gt; is the cross-platform code editor for Linux, macOS and Windows. With VS Code you can build, debug and run web applications (ASP .NET Core, Node) or .NET Core console applications, with IntelliSense, code completion and Git integration.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Using &lt;a href=&#34;http://www.omnisharp.net/&#34;&gt;OmniSharp&lt;/a&gt; you can add IntelliSense to any of the following code editors - Atom, Brackets, Emacs, Sublime or Vim.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;https://www.xamarin.com/studio&#34;&gt;Xamarin Studio&lt;/a&gt; is the IDE for macOS that lets you build cross-platform mobile applications for iOS, Android or macOS, and even web applications.&lt;/p&gt;

&lt;p&gt;With &lt;a href=&#34;https://www.visualstudio.com/products/visual-studio-community-vs&#34;&gt;Visual Studio Community&lt;/a&gt; you can build all types of applications on the .NET Framework, including Xamarin apps, Azure integration and source control support. For Windows, it is the best IDE for building .NET applications.&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://www.microsoft.com/net&#34;&gt;You can install .NET Core 1.0 on your system right now&lt;/a&gt; and start using the command line interface (&lt;code&gt;dotnet new&lt;/code&gt;, &lt;code&gt;dotnet restore&lt;/code&gt;, &lt;code&gt;dotnet build&lt;/code&gt;, &lt;code&gt;dotnet run&lt;/code&gt;) or install &lt;a href=&#34;https://www.visualstudio.com/en-us/products/code-vs.aspx&#34;&gt;Visual Studio Code&lt;/a&gt; with IntelliSense and debugging.&lt;/p&gt;

&lt;p&gt;It is one of the most exciting times to be a .NET developer, being able to write code that runs across IoT devices, phones, tablets, laptops, desktops, holographic devices, servers or the cloud and share it across multiple operating systems, with familiar processes and tools.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>